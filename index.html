<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta name="referrer" content="no-referrer"> 
    <title>OpenCharacters - Create and share ChatGPT/AI characters</title>

    <script>
      let scriptsLeftToLoad = 0;
      let scriptLoadErrors = 0;

      async function waitForAllScriptsToLoad() {
        while (scriptsLeftToLoad > 0) {
          console.log(`Waiting for ${scriptsLeftToLoad} script load(s) to complete.`);
          await new Promise((resolve) => setTimeout(resolve, 300));
        }
      }

      async function haveAnyScriptsFailedToLoad() {
        return (scriptLoadErrors > 0);
      }

      // Do not call this function directly. It is only used by loadRemoteScript.
      async function loaderScript(scriptUrl){
        return new Promise(function (res, rej) {
          let script = document.createElement('script');
          script.src = scriptUrl;
          script.type = 'text/javascript';
          script.onerror = rej;
          script.async = false;
          script.onload = res;
          script.addEventListener('error',rej);
          script.addEventListener('load',res);
          document.head.appendChild(script);
        })
      }   

      // Do not call this function directly. It is for use by loadLocalOrRemoteScript.
      async function loadRemoteScript(localScriptName,remoteScriptUrl) {
        try{
          await loaderScript(remoteScriptUrl);
          console.log(`Script ${localScriptName} loaded remotely.`);
          scriptsLeftToLoad--; 
        }catch{
          const warnmsg = `Script ${localScriptName} could not be loaded from ${remoteScriptUrl} . This may just be a network error. If you are trying to host OpenCharacters purely locally, you will need to save a local copy of this script. See the documentation.`;
          console.error(warnmsg);
          alert(warnmsg);
          scriptLoadErrors++;
          scriptsLeftToLoad--;
        }
      }

      async function loadLocalOrRemoteDependency(localScriptName,remoteScriptUrl){
        scriptsLeftToLoad++;
        try{
          await loaderScript("dependencies/optionallocalcopies/" + localScriptName);
          console.log(`Script ${localScriptName} loaded locally.`); 
          scriptsLeftToLoad--;
        }catch{
          await loadRemoteScript(localScriptName, remoteScriptUrl);
        }
      }    

      async function loadLocalDependency(localScriptName)
      {
        scriptsLeftToLoad++;
        try{
          await loaderScript("dependencies/" + localScriptName);
          console.log(`Script ${localScriptName} loaded locally.`); 
          scriptsLeftToLoad--;
        } catch {
          const warnmsg = `Script ${localScriptName} could not be loaded. This may just be a network error. If you are trying to host OpenCharacters purely locally, you will need to save a local copy of this script. See the documentation.`;
          console.error(warnmsg);
          alert(warnmsg);
          scriptLoadErrors++;
          scriptsLeftToLoad--;
        }
      }
      loadLocalOrRemoteDependency("dexie.js", "https://unpkg.com/dexie@4.0.11/dist/dexie.min.js");
      loadLocalOrRemoteDependency("dexie-export-import.js", "https://unpkg.com/dexie-export-import@4.1.4/dist/dexie-export-import.js");
      loadLocalOrRemoteDependency("marked.js", "https://cdn.jsdelivr.net/npm/marked/marked.min.js");
      loadLocalOrRemoteDependency("purify.js", "https://cdn.jsdelivr.net/npm/dompurify/dist/purify.js");
      loadLocalDependency("smartquotes.js");
    </script>
  </head>
  <body>
    <style>
      :root, :root.light {
        --background: #e8e8e8;
        --button-bg: #c8c8c8;
        --button-bg-hover: #b4b4b4;
        --text-color: black;
        --textarea-bg: #f1f1f1;
        --selected-thread-bg: lightgray;
        --border-color: #c8c8c8;
        --border-radius: 3px;
        --avatar-bg: lightgrey;
        --notification-bg-color: #005ac2;
        --button-border-color: #b4b4b4;
        --button-font-size: 0.825rem;
      }


      /* Detect browser dark mode and change variables */
      @media (prefers-color-scheme: dark) {
        :root {
          --background: #151515;
          --button-bg: #333;
          --button-bg-hover: #444;
          --text-color: white;
          --textarea-bg: #333;
          --selected-thread-bg: #444;
          --border-color: #333;
          --avatar-bg: #333;
          --button-border-color: #515151;
        }
      }

      body, html {
        margin:0;
        background: var(--background);
        color: var(--text-color);
        font-family: sans-serif;
      }
      body * {
        box-sizing:border-box;
        color: inherit;
        font-family: inherit;
      }
      body a {
        color: blue;
      }

      .messageText pre[data-markdown-codeblock] {
        font-family: monospace;
        background: rgb(35 35 35);
        padding: 0.5rem;
        color: rgb(232, 232, 232);
        border-radius: var(--border-radius);
        overflow-x: auto;
      }
      .messageText p code {
        font-family: monospace;
        background: rgb(35 35 35);
        padding: 0.125rem;
        color: rgb(232, 232, 232);
        border-radius: var(--border-radius);
      }
      .messageText table {
        border-collapse: collapse;
      }
      .messageText table, .messageText th, .messageText td {
        border: 1px solid var(--border-color);
      }

      button {
        background: var(--button-bg);
        border-radius: var(--border-radius);
        cursor:pointer;
        padding: 0.125rem;
        border: 1px solid var(--button-border-color);
        font-size: var(--button-font-size);
      }
      button:hover {
        background: var(--button-bg-hover);
      }
      button:disabled {
        cursor: not-allowed;
      }
      textarea {
        background: var(--textarea-bg);
        border: 1px solid var(--button-border-color);
        border-radius: var(--border-radius);
      }

      input[type="text"], select {
        background: var(--textarea-bg);
        border: 1px solid var(--button-border-color);
        border-radius: var(--border-radius);
      }

      #appOptions .appOptionButton {
        width:100%;
        cursor:pointer;
        margin-top:0.5rem;
        min-height: 2rem;
      }
      #chatThreads {
        flex-grow:1;
        overflow-y:auto;
        margin-top:0.5rem;
        -webkit-mask-image: linear-gradient(to bottom, black calc(100% - 30px), #ffffff00 100%);
        mask-image: linear-gradient(to bottom, black calc(100% - 30px), #ffffff00 100%);
        padding-bottom:2rem;
      }
      #chatThreads .thread, #chatThreads .threadFolder {
        border-radius: var(--border-radius);
        display:flex;
        padding:0.5rem;
        cursor:pointer;
        border: 1px solid var(--border-color);
        position: relative;
        -webkit-user-select: none;
        user-select:none;
      }
      #chatThreads .thread, #chatThreads .threadFolder {
        margin-top: 0.5rem;
      }
      #chatThreads .thread:first-child, #chatThreads .threadFolder:first-child {
        margin-top: 0;
      }

      #chatThreads .threadFolder {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      #chatThreads .thread .favStar, #chatThreads .thread .changeFolderPath {
        position: absolute;
        font-size: 80%;
        opacity: 0.5;
        display: none;
        text-shadow: 0px 1px 2px #515151;
      }
      #chatThreads .thread .favStar {
        top: 0.0625rem;
        left: 0.0625rem;
      }
      #chatThreads .thread .changeFolderPath {
        bottom: 0.0625rem;
        left: 0.0625rem;
      }
      body:not(.isMobile) #chatThreads .thread .favStar:hover {
        opacity: 1;
      }
      #chatThreads .thread .changeFolderPath:hover {
        opacity: 1;
      }
      #chatThreads .thread:hover .favStar, #chatThreads .thread:hover .changeFolderPath {
        display: inline;
      }
      /* can't hover on mobile, so display button on selected thread: */
      body.isMobile #chatThreads .thread.selected .favStar, body.isMobile #chatThreads .thread.selected .changeFolderPath {
        display: inline;
      }
      #chatThreads .thread .favStar[data-is-fav="true"] {
        opacity: 1;
        display: inline;
      }

      #chatThreads .thread:not(:first-child) {
        margin-top: 0.5rem;
      }
      #chatThreads .thread .button {
        opacity:0.5;
      }
      #chatThreads .thread .button:hover {
        opacity:1;
      }
      #chatThreads .thread.selected {
        background-color: var(--selected-thread-bg);
      }
      #chatThreads .thread .info {
        max-width: 100%;
      }
      #chatThreads .thread .nameWrapper {
        overflow: hidden;
        white-space: nowrap;
        max-width: 150px;
        display: flex;
      }
      #chatThreads .thread .name {
        /* truncate long thread names */
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        flex-grow: 1;
      }
      #chatThreads .thread .avatar, #characterSelection  .character .avatar {
        width:50px;
        height:50px;
        border-radius: var(--border-radius);
        min-width:50px;
        background-position: center;
        background-size: cover;
        background-repeat: no-repeat;
        background-color: var(--avatar-bg);
      }
      #messageFeed .message .avatar {
        width: 50px;
        height: 50px;
        border-radius: var(--border-radius);
        min-width: 50px;
        background-position: center;
        background-size: cover;
        background-repeat: no-repeat;
        background-color: var(--avatar-bg);
      }
      #chatThreads .characterEditButton {
        font-size: 0.65rem;
        opacity: 0.5;
      }
      #chatThreads .characterEditButton:hover {
        opacity: 1;
      }

      /* hide threads scrollbar */
      #chatThreads {
        -ms-overflow-style: -ms-autohiding-scrollbar;  /* Internet Explorer 10+ */
        scrollbar-width: thin;
      }
      #chatThreads::-webkit-scrollbar { 
        display: none;  /* Safari and Chrome */
      }

      /* hide message feed scrollbar */
      /* #messageFeed {
        -ms-overflow-style: none; 
        scrollbar-width: none; 
      }
      #messageFeed::-webkit-scrollbar { 
        display: none;  
      } */

      /* custom scrollbar */
      ::-webkit-scrollbar {
        width: 10px;
        height: 10px;
      }
      ::-webkit-scrollbar-track {
        background-color: transparent;
      }
      ::-webkit-scrollbar-thumb {
        background-color: var(--button-bg);
        border-radius: 10px;
        border: 3px solid transparent;
        background-clip: content-box;
      }
      ::-webkit-scrollbar-thumb:hover {
        background-color: var(--button-bg-hover);
      }


      #builtInChatInterfaceWrapper {
        display: flex;
        flex-grow: 1;
        flex-direction: column;
        height: 100%;
        position:relative;
        padding-left: 0.5rem;
        padding-right: 0.5rem;
      }

      #messageFeed .message {
        margin-top:0.5rem;
        margin-bottom:0.5rem;
      }

      #messageFeed .message .bottomButtons {
        display:none;
        position:absolute;
        bottom: 0.25rem;
        right: 0.5rem;
      }
      #messageFeed .message:hover .bottomButtons {
        display: flex;
      }
      .emojiButton {
        opacity:0.5;
        cursor:pointer;
      }
      .emojiButton:hover {
        opacity:1;
      }

      #messageFeed .message.hiddenFromUser .showHiddenMessageButton {
        display: inline-block;
      }
      #messageFeed .message:not(.hiddenFromUser) .showHiddenMessageButton {
        display: none;
      }
      #messageFeed .message.hiddenFromUser .messageWrap {
        display: none;
      }
      #messageFeed .message:not(.hiddenFromUser) .messageWrap {
        display: flex;
      }
      #messageFeed .messageText p {
        white-space: pre-wrap;
      }
      #messageFeed .messageText {
        margin-top: 0.125rem;
        overflow: hidden; /* keep messageText content from "escaping" the message area */
      }
      #messageFeed .messageText p:first-child {
        margin-top:0;
      }
      #messageFeed .messageText img {
        max-width: 100%;
      }

      #messageFeed > *:first-child {
        margin-top: 3rem;
      }

      #characterFoldersList {
        display: grid;
        grid-template-columns: repeat(auto-fill, 280px);
        grid-gap: 0.5rem;
        justify-content: center;
        margin-bottom: 0.5rem;
      }
      #characterFoldersList .characterFolder {
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        width: 100%;
        padding:0.5rem;
        cursor:pointer;
        -webkit-user-select: none;
        user-select:none;
      }

      #characterSelection .character {
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
        width: 100%;
      }
      #characterSelection .character .info .buttons {
        margin-top: 0.25rem;
      }
      #characterSelection .character .info .buttons button {
        font-size: 0.7rem;
        margin-left: 0.25rem;
      }
      #characterList, #starterCharacterList {
        display: grid;
        grid-template-columns: repeat(auto-fill, 280px);
        grid-gap: 0.5rem;
        justify-content: center;
      }
      #characterFoldersList .characterFolder {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      #characterSelection .character {
        -webkit-user-select: none;
        user-select:none;
      }

      #customCodeIframeHorizontalResizeBar {
        width:5px;
        background:var(--button-bg);
        cursor:ew-resize;
      }
      #customCodeIframeHorizontalResizeBar:hover {
        background:var(--button-bg-hover);
      }

      #userMessagesSentHistoryCtn {
        margin-bottom:0.25rem;
        position:relative;
      }
      #userMessagesSentHistoryCtn:empty {
        display: none;
      }
      #userMessagesSentHistoryCtn .historyItem {
        cursor: pointer;
        padding: 0.25rem;
        font-size: 85%;
        overflow: hidden;
        white-space: pre;
        display: flex;
      }
      #userMessagesSentHistoryCtn .historyItem .text {
        text-overflow: ellipsis;
        overflow: hidden;
        margin-left: 0.25rem;
      }
      #userMessagesSentHistoryCtn .historyItem .deleteButton {
        margin-left: auto;
      }
      #userMessagesSentHistoryCtn .historyItem:hover {
        background: var(--background);
      }
      #userMessagesSentHistoryCtn .historyItem .pinButton,
      #userMessagesSentHistoryCtn .historyItem .deleteButton {
        opacity: 0.5;
      }
      #userMessagesSentHistoryCtn .historyItem[data-is-pinned="true"] .pinButton {
        opacity: 1;
      }
      body:not(.isMobile) #userMessagesSentHistoryCtn .historyItem .pinButton:hover,
      body:not(.isMobile) #userMessagesSentHistoryCtn .historyItem .deleteButton:hover {
        opacity: 1;
      }

      #shortcutButtonsCtn {
        margin-bottom:0.25rem;
        position:relative;
        overflow-y: auto;
      }
      #shortcutButtonsCtn:empty {
        display:none;
      }

      #shortcutButtonsCtn button:not(:first-child) {
        margin-left:0.25rem;
      }

      /* typing indicator from https://codepen.io/arthak/pen/rmqvgo */
      .tiblock { align-items: center; display: flex; height: 17px; }
      .ticontainer{ display: inline-block; }
      .ticontainer .tidot { background-color: #90949c;  }
      .tidot { animation: mercuryTypingAnimation 1.5s infinite ease-in-out; border-radius: 2px; display: inline-block; height: 4px; margin-right: 2px; width: 4px; }
      @keyframes mercuryTypingAnimation{ 0%{ -webkit-transform:translateY(0px); transform:translateY(0px); } 28% { transform:translateY(-5px); } 44%{ transform:translateY(0px); } } .tidot:nth-child(1){ animation-delay:200ms; } .tidot:nth-child(2){ animation-delay:300ms; } .tidot:nth-child(3){ animation-delay:400ms; }
    </style>

    <div id="topNotification" style="position:fixed; top:1rem; left:0; right:0; z-index:1000; display:none;">
      <div id="topNotificationContent" style="margin:0 auto; max-width:350px; background:var(--notification-bg-color); color:white; text-align: center; padding: 0.5rem; border-radius: var(--border-radius);"></div>
    </div>

    <div id="main" style="display:flex; position:fixed; top:0; right:0; left:0; bottom:0;">
      <div id="leftColumn" style="display:flex; flex-direction:column; width:270px; min-width:270px; padding:0.5rem; ">
        <div style="display:flex;">
          <button id="newThreadButton" type="button" title="New thread" style="width:100%; cursor:pointer; min-height:2rem;">üí¨ new chat</button>
          <button id="closeLeftColumnButton" type="button" title="Open or close thread list and controls" style="cursor:pointer;min-height:2rem;margin-left: 0.5rem;min-width: 2rem;">‚ò∞</button>
        </div>
        <div id="threadSearchCtn" style="display:flex; width:100%; margin-top:0.5rem;">
          <input id="threadSearchInput" style="height: 100%; flex-grow: 1; min-width: 0; padding-left: 0.5rem;" type="text" placeholder="search threads...">
          <button id="threadSearchButton" type="button" title="Search threads" style="cursor:pointer;min-height: 2rem;min-width: 2rem;margin-left: 0.5rem;">üîé</button>
        </div>
        <!-- <div id="threadFolderNavigationBar" style="display:flex; width:100%; margin-top:0.5rem;">
          <button id="threadFolderBackButton" style="cursor:pointer;min-height: 2rem;min-width: 2rem;margin-left: 0.5rem;">üîô</button>
          </div> -->
        <!-- <div id="chatThreadFolders" data-current-folder-path=""></div> -->
        <div id="chatThreads" data-current-folder-path=""></div>
        <div id="appOptions">
          <div style="display:flex;">
            <button type="button" title="Settings" id="settingsButton" class="appOptionButton">‚öôÔ∏è settings</button>
            <!-- <button id="statsButton" class="appOptionButton" style="margin-left: 0.5rem; width: 2rem;">üìä</button> -->
          </div>
          <div style="display:flex;">
            <button type="button" title="Clear all data" id="clearDataButton" class="appOptionButton" style="width: 4rem;">üóëÔ∏è</button>
            <button type="button" title="Export all data" id="exportDataButton" class="appOptionButton" style="margin-left: 0.5rem; margin-right: 0.5rem;">üíæ export <span id="exportDataButtonOperationCount" style="font-size:70%;">0</span></button>
            <button type="button" title="Options" class="appOptionButton" style="position:relative;">üìÅ import<input title="Import data file" id="importDataFileInput" style="position:absolute; top:0; left:0; right:0; bottom:0; opacity:0; cursor:pointer;" type="file"></button>
          </div>
          <div style="display:flex;">
            <button type="button" title="Documentation" type="button" id="documentationButton" class="appOptionButton">‚ùì Documentation</button>
            <button type="button" title="Release notes" type="button" id="releaseNotesButton" style="margin-left: 0.5rem; width:fit-content;" class="appOptionButton">Release notes</button>
          </div>
        </div>
      </div>

      <div id="middleColumn" style="flex-grow:1; display:flex; flex-direction:column; position:relative; overflow:hidden; min-width:200px; z-index:1;">
        <div id="middleColumnShadowOverlay" style="display:none; position:absolute;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5); z-index:20;"></div>
        <div id="characterSelection" class="middleColumnScreen" style="flex-grow:1; display:none; overflow: auto;">
          <button type="button" id="characterSelectionOpenLeftColumnButton" class="openLeftColumnButton" style="background: var(--button-bg);border-radius: var(--border-radius);border: 1px solid var(--button-border-color);padding: 0.25rem;width: 2rem;min-height: 2rem;margin-right: 0.5rem;position: absolute;top: 0.5rem;left: 0.5rem;">‚ò∞</button>
          <div>
            <h2 style="text-align:center;margin-bottom: 0.5rem;">Your Characters</h2>
            <div style="margin-bottom: 0.5rem;display: flex;justify-content: center;">
              <button type="button" id="newCharacterButton" style="padding: 0.25rem;">üÜï new character</button>
              <!-- <button id="newFolderCharacterButton" style="padding: 0.25rem; margin-left: 0.5rem;">üìÅ new folder</button> -->
            </div>
          </div>
          <div id="characterFoldersList" data-current-folder-path=""></div>
          <div id="characterList"></div>
          <div><h2 style="text-align:center; margin-top:4rem;">Starter Characters</h2></div>
          <div id="starterCharacterList"></div>
          <br><br>
        </div>
        <div id="chatInterface" class="middleColumnScreen" style="display:flex; flex-grow:1; flex-direction:column; height:100%; position:relative;">
          <div id="customCodeChatInterfaceWrapper" style="display:none;"></div>
          <div id="builtInChatInterfaceWrapper">
            <div id="messageFeedHeaderBar" style="display: flex; position:absolute;height: 2rem;right: 0;left: 0;margin: 0.5rem; z-index:30;">
              <button id="messageFeedOpenLeftColumnButton" type="button" class="openLeftColumnButton" style="display:none; background: var(--button-bg);border-radius: var(--border-radius);border: 1px solid var(--button-border-color);padding: 0.25rem; min-width: 2rem; height: 100%; margin-right:0.5rem;">‚ò∞</button>
              <div id="messageFeedFloatingMenu" style="background: var(--button-bg); display:flex; height: 100%; border-radius: var(--border-radius);border: 1px solid var(--button-border-color);padding: 0.25rem;">
                <div style="display: flex;align-items: center;font-size:var(--button-font-size);margin-right: 0.25rem;">model:</div>
                <select id="threadModelSelector" title="Thread model" style="max-width:180px;"></select>
                <button id="threadModelSelectorInfoButton" type="button" style="display:flex; align-items:center; font-size:var(--button-font-size); margin-right: 0.25rem;">‚ÑπÔ∏è</button>
                <button id="adviceOnThreadsButton" type="button" title="Advice on creating good chats" style="align-items:center; margin-left:10px;">‚ùì</button>
              </div>
              <div id="threadSettingsButton" style="margin-left:0.5rem; cursor:pointer;   background: var(--button-bg); display:flex; height: 100%; border-radius: var(--border-radius);border: 1px solid var(--button-border-color);padding: 0.25rem;">
                <div style="display: flex;align-items: center;justify-content:center;font-size:var(--button-font-size);min-width:1.5rem;">‚öôÔ∏è</div>
              </div>
            </div>
            <div id="chatBackgroundCtn" style="pointer-events:none; position:absolute; top:0; left:0; right:0; bottom:0; z-index:-10;"></div>
            <div id="noMessagesNotice" style="display:none; text-align:center; padding:1rem; margin-top:4rem;">Type a message to begin the chat.</div>
            <div id="messageFeed" style="flex-grow:1; overflow-y:auto;"></div>
            <div id="statusNotifier" style="text-align: center; display: none; height: 0; position: relative; top: -0.4rem; display: flex; align-items: center; justify-content: center;"></div>
            <div id="inputWrapper" style="display:flex; padding:0.5rem; padding-left:0; padding-right:0; flex-direction:column;">
              <!-- <div style="display:flex;margin-bottom: 0.25rem;">
                <button id="editReminderMessageButton" style="font-size:0.7rem;">‚úèÔ∏è reminder msg</button>
                </div> -->
              <div id="userMessagesSentHistoryCtn"></div>
              <div id="shortcutButtonsCtn"></div>
              <div style="display:flex;">
                <textarea id="messageInput" style="flex-grow:1; min-height:4rem; font-size:100%;" title="commands:&#10;/ai - prompt a reply from ai&#10;/ai &lt;instruction&gt; - prompt reply with instruction&#10;/ai @CharName#123 &lt;instruction&gt; - prompt reply with another character (ID=123)&#10;/user &lt;instruction&gt; - generate a user reply&#10;/sys &lt;message&gt; - reply as system&#10;/sum - open summary editor&#10;/mem - open memory editor&#10;/lore - open lore editor&#10;/lore &lt;text&gt; - add a lore entry&#10;/name &lt;name&gt; - set your name for this thread&#10;/avatar &lt;url&gt; - set your avatar image for this thread&#10;/import - add chat messages in bulk&#10;/flushembeds - flush the embedding cache that's used to determine what memories are relevant&#10;/respacemessageorders -- renumber the order values of messages&#10;&#10;‚Ä¢ You can add '/ai &lt;instruction&gt;' as the final line in your normal messages to instruct AI for its reply.&#10;‚Ä¢ Double-click this text box to show input history"></textarea>
                <div style="display:flex; flex-direction:column; margin-left:0.25rem;">
                  <button id="sendButton" type="button" style="min-width:80px; min-height: 50px; margin-bottom: 3px; flex-grow:1;">send</button>
                  <select id="repliesPerSendMenu" title="Replies generated each time you click Send" style="margin-bottom:3px; vertical-align:middle;">
                    <option value="1">1 reply</option>
                    <option value="2">2 replies</option>
                    <option value="3">3 replies</option>
                    <option value="4">4 replies</option>
                    <option value="5">5 replies</option>
                    <option value="6">6 replies</option>
                    <option value="7">7 replies</option>
                    <option value="8">8 replies</option>
                    <option value="9">9 replies</option>
                  </select>
                  <div style="position:relative;">
                    <div id="threadOptionsPopup" style="position:absolute; display:none; padding:0.5rem; background:var(--background); border-radius:var(--border-radius); width:max-content; right:0; bottom:0; border:1px solid var(--border-color);">
                      <button id="addShortcutButton" type="button">‚ú® add shortcut</button>
                      <!-- <button id="replyLoopButton">‚û∞ reply loop</button> -->
                    </div>
                  </div>
                  <div style="display:flex; flex-direction:row; align-items:center;">
                    <button id="threadOptionsButton" type="button" style="flex-grow:1; vertical-align:middle;">options</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="rightColumn" style="width:min-content;" data-visible="no">
        <div id="customCodeColumn" style="width:min-content; display:none; height:100%;">
          <div id="customCodeIframeHorizontalResizeBar"></div>
          <div id="customCodeIframeCtn" style="height:100%; flex-grow:1;"></div>
        </div>
      </div>
    </div>

    <button id="toggleRightColumnButton" style="position:fixed; top:0.5rem; right:0.5rem; min-height:2rem; min-width:2rem; display:none; align-items:center; justify-content:center; z-index:500;">‚öõÔ∏è</button>

    <audio id="musicPlayer" style="display:none;"></audio>

    <script type="module">
      import { $, $$, delay, showEl, hideEl, prompt2, createFloatingWindow, sanitizeHtml, textToSpeech, sha256Text, dedent, downloadTextOrBlob, createGpt3Tokenizer, cosineDistance, createLoadingModal, applyObjectOverrides, objectKeysAndTypesAreValid, addBackgroundToElement, importStylesheet, htmlToElement, jsonToBlob, plainquotes, removeEmoji } from "./utils.js?v=34";

      let JSON5;
      (async function() {
        JSON5 = await import('https://unpkg.com/json5@2/dist/index.min.mjs').then(m => m.default);
      })();

      await waitForAllScriptsToLoad();
      if (await haveAnyScriptsFailedToLoad()) {
        throw new Error("Script load failure");
      }
      // TODO: allow <style> when you work out how to scope it to the current message only - maybe just use a CSS parser and add .messageText prefix to selectors - https://github.com/jotform/css.js
      // TODO: allow sandboxed iframes in messages? so devs can add dynamic/interactive message content? I think they may even be able to communicate with their custom code iframe?!
      let domPurifyOptions = {
        FORBID_TAGS: ['style'],
        ADD_ATTR: ['onclick'], // WARNING: I'm using a hook (below) to make this safe. Be careful when editing this stuff.
      };
      DOMPurify.addHook('uponSanitizeAttribute', function (node, data) {
        if(data.attrName === "onclick") {
          node.dataset.onClickCode = data.attrValue;
          data.attrValue = "window.runCodeInCustomCodeIframe(this.dataset.onClickCode)";
        }
      });

      const markedRenderer = new marked.Renderer();
      markedRenderer.code = (source, lang) => {
        const escapedSource = sanitizeHtml(source);
        if(lang) {
          return `<pre data-markdown-codeblock="${sanitizeHtml(lang)}">${escapedSource}</pre>`;
        } else {
          return `<pre data-markdown-codeblock>${escapedSource}</pre>`;
        }
      };
      marked.setOptions({
        renderer: markedRenderer,
      });

      window.onerror = function(errorMsg, url, lineNumber, columnNumber, errorObj) {
        alert(`Please report this error on the Discord or Github:\n\n${errorMsg}\n\nstack: ${errorObj?.stack}\n\nline: ${lineNumber}`);
        if(errorObj?.stack.toLowerCase().includes("databaseclosederror")) {

        }
        return false;
      }

      if(!window.isSecureContext) {
        alert("Hey, looks like you're trying to host this locally, but you have hosted it in an insecure context - i.e. you're serving it on HTTP instead of HTTPS. Unfortunately there are a bunch of features that are disabled on HTTP connections for modern browsers. localhost is treated as a secure context for development purposes, but if you want to server it on the internet, then I recommend using Cloudflare - you just switch your domain's nameservers to them and then it's basically a button click and you've got HTTPS. Much easier than setting up your own certificate stuff.");
      }

      const projectURL = 'https://github.com/markphaedrus/OpenCharacters';
      const projectHomePageURL = projectURL + '/blob/main/README.md';
      const projectDocsURL = projectURL + '/blob/main/docs';

      $.messageFeed.addEventListener("keydown", async function(e) {
        debugger;
      });

      // polyfill for navigator.userActivation
      if(!navigator.userActivation) {
        navigator.userActivation = {hasBeenActive:false};
        let pageActivationClickHandler = (e) => {
          if(e.isTrusted) {
            navigator.userActivation.hasBeenActive = true;
            window.removeEventListener("click", pageActivationClickHandler);
          }
        }
        window.addEventListener("click", pageActivationClickHandler);
      }

      const sceneBackground = addBackgroundToElement($.chatBackgroundCtn);

      // dragula([$.messageFeed], {
      //   moves: function (el, source, handle, sibling) {
      //     return el.classList.contains("message") && handle.classList.contains("avatar");
      //   },
      //   revertOnSpill: true,
      // });

      prompt2.defaults = {
        backgroundColor: "var(--background)",
        borderColor: "var(--border-color)",
      };
      createFloatingWindow.defaults = {
        backgroundColor: "var(--background)",
        borderColor: "var(--border-color)",
      };

      let summariesWindow = createFloatingWindow({header:"Logs"});
      summariesWindow.hide();
      function addToDebugLog(html) {
        let ctn = document.createElement("div");
        ctn.innerHTML = html;
        ctn.style.cssText = "font-size:0.8rem; padding:0.5rem; solid var(--border-color); font-family:monospace;";
        let initialScrollTop = summariesWindow.bodyEl.scrollTop;
        summariesWindow.bodyEl.appendChild(ctn);

        setTimeout(function() {
          // wait for render and then scroll to bottom if it was near bottom previously
          if(Math.abs(initialScrollTop - summariesWindow.bodyEl.scrollTop) < 10) {
            summariesWindow.bodyEl.scrollTop = summariesWindow.bodyEl.scrollHeight;
          }
        }, 10);
        
        // delete earlier children if there are too many
        while(summariesWindow.bodyEl.children.length > 50) {
          summariesWindow.bodyEl.removeChild(summariesWindow.bodyEl.children[0]);
        }
      }

      // TODO: improve this heuristic. this isn't just about screen width - it's also about touch screens (no pointer hover events).
      // ALSO: This is a bit of a misnomer. It's used for stuff like determining how to show the right column, which is really about screen width, not mobile/touchscreen stuff.
      const isMobile = window.innerWidth < 700;

      if(isMobile) {
        document.body.classList.add("isMobile"); // to use in CSS selectors
      }
      
      function openLeftColumn() {
        showEl($.leftColumn);
        document.querySelectorAll(".openLeftColumnButton").forEach(el => hideEl(el));
        showEl($.closeLeftColumnButton);
        if(isMobile) {
          showEl($.middleColumnShadowOverlay);
        }
      }
      function closeLeftColumn() {
        hideEl($.leftColumn);
        document.querySelectorAll(".openLeftColumnButton").forEach(el => showEl(el));
        hideEl($.closeLeftColumnButton);
        if(isMobile) {
          hideEl($.middleColumnShadowOverlay);
        }
      }
      $.closeLeftColumnButton.addEventListener("click", closeLeftColumn);
      document.querySelectorAll(".openLeftColumnButton").forEach(el => {
        el.addEventListener("click", (e) => {
          e.stopPropagation(); // <-- since this hovers over middle column, and on mobile we close left column when they tap middle column
          openLeftColumn();
        });
      });
      if(isMobile) {
        closeLeftColumn();
        // if they click anywhere in the middle column, close the menu
        $.middleColumnShadowOverlay.addEventListener("click", (e) => {
          e.stopPropagation();
          closeLeftColumn();
        });
      }


      {
        let messageFeedHeaderBarHideTimeout = null;
        let isMouseInTriggerArea = false;
        function showMessageFeedTopMenu() {
          clearTimeout(messageFeedHeaderBarHideTimeout);
          messageFeedHeaderBarHideTimeout = null;
          showEl($.messageFeedHeaderBar);
        }
        function hideMessageFeedTopMenu() {
          if(messageFeedHeaderBarHideTimeout !== null) return; // hiding settimeout already in progress
          clearTimeout(messageFeedHeaderBarHideTimeout);
          messageFeedHeaderBarHideTimeout = setTimeout(() => {
            hideEl($.messageFeedHeaderBar);
          }, 2000);
        }
        window.addEventListener("mousemove", (e) => {
          if (e.pageY < 80) { // show:
            isMouseInTriggerArea = true;
            showMessageFeedTopMenu();
          } else { // hide if visible:
            isMouseInTriggerArea = false;
            if ($.messageFeedHeaderBar.offsetHeight > 0 && !lastMessageFeedScrollWasUp) {
              hideMessageFeedTopMenu();
            }
          }
        });
        let messageFeedScrollTop = 0;
        let lastMessageFeedScrollWasUp = true;
        $.messageFeed.addEventListener("scroll", function (e) {
          let newScrollTop = e.target.scrollTop;
          if (newScrollTop < messageFeedScrollTop) { // they scrolled up, so show menu
            lastMessageFeedScrollWasUp = true;
            showMessageFeedTopMenu();
          }
          if (newScrollTop > messageFeedScrollTop) { // they scrolled down, so hide menu if their mouse isn't in trigger area
            lastMessageFeedScrollWasUp = false;
            if(!isMouseInTriggerArea || isMobile) {
              hideMessageFeedTopMenu();
            }
          }
          messageFeedScrollTop = newScrollTop;
        }, { passive: true });
      }

      if(isMobile) {
        $.customCodeIframeHorizontalResizeBar.style.display = "none";
        $.customCodeColumn.style.width = "100%";

        $.rightColumn.style.position = "fixed";
        $.rightColumn.style.top = "0";
        $.rightColumn.style.right = "0";
        $.rightColumn.style.bottom = "0";
        $.rightColumn.style.left = "0";
        $.rightColumn.style.zIndex = "100";
        $.rightColumn.style.width = "";

        $.rightColumn.style.pointerEvents = "none";
        $.rightColumn.style.opacity = "0";

        $.toggleRightColumnButton.addEventListener("click", function() {
          if($.rightColumn.dataset.visible === "yes") {
            $.rightColumn.style.pointerEvents = "none";
            $.rightColumn.style.opacity = "0";
            $.rightColumn.dataset.visible = "no";
            $.toggleRightColumnButton.textContent = "‚öõÔ∏è";
          } else {
            $.rightColumn.style.pointerEvents = "";
            $.rightColumn.style.opacity = "1";
            $.rightColumn.dataset.visible = "yes";
            $.toggleRightColumnButton.textContent = "üí¨";
          }
        });
      }


      const dbName = "chatbot-ui-v1";
      const dbVersion = 90;

      let db = await new Dexie(dbName).open().catch(e => {
        console.warn(e);
        return false;
      }); // throws if db doesn't exist
      let dbLoadingModal;
      if(db) {
        console.log("Existing user, checking database version...");
        let usersOriginalDbVersion = db.verno;
        if(usersOriginalDbVersion < dbVersion) {
          let result = await prompt2({
            message: {type:"none", "html":`<p style="margin:0;">A database upgrade will be done when you click continue. A full export/backup will be downloaded first in case anything goes wrong.</p>`},
          }, {cancelButtonText:null, submitButtonText:"Continue"});
          
          dbLoadingModal = createLoadingModal(`Please wait...<br><span style="font-size:80%; opacity:0.6;">This could take a while if you have a lot of data.</span>`);

          const originalDbJsonBlob = await db.export({prettyJson: true});
          let yyyymmdd = new Date().toISOString().split("T")[0];
          downloadTextOrBlob(originalDbJsonBlob, `opencharacters-export-${yyyymmdd}.json`);
        }
        await db.close(); // we need to close before db.version() call below and re-open afterwards
      } else {
        // brand new user, so create the db:
        console.log("New user, creating database...");
        db = new Dexie(dbName);
      }
      
      db.version(dbVersion).stores({
        // REMEMBER: If you update the database schema, you may also need to update the export/import code
        // in particular: the character hash code shouldn't include fields like `id` and `creationTime` and `lastMessageTime`.
        
        // Things to check:
        // - character hash computation
        // - $.exportDataButton.addEventListener
        // - import code

        // NOTE: The properties listed here are just the INDEXES, not *all* the columns/properties.
        characters: "++id,modelName,fitMessagesInContextMethod,uuid,creationTime,lastMessageTime",
        threads: "++id,name,characterId,creationTime,lastMessageTime,lastViewTime",
        messages: "++id,threadId,characterId,creationTime,order", // characterId is -1 for user, and for system it is -2.
        misc: "key", // key=>value
        summaries: "hash,threadId", // EDIT: This does not make sense, because the `hash` is used as the primary key, so in the case where two threads end up with the same summary hash (which is actually common because you can import a thread which you already have), then you can only have one entry for both threads. So for summary deletion you actually need to (OLD: we track threadId so when we delete threads, we can delete the associated summaries. we also need it for grabbing summaries for the edit interface.)
        memories: "++id,[summaryHash+threadId],[characterId+status],[threadId+status],[threadId+index],threadId", // memories are associated with a summary hash because they are computed alongside the summary. We need to track the hash so that if earlier messages are edited (and therefore the summaries need to be recomputed), we know to only consider "valid"/"current" the memories that are associated with currently-"used". The "type" property is used to track the "currentness", and also to track whether a memory was manually added by the user (in which case it is *always* considered valid)
        lore: "++id,bookId,bookUrl",
        textEmbeddingCache: "++id,textHash,&[textHash+modelName]",
        textCompressionCache: "++id,uncompressedTextHash,&[uncompressedTextHash+modelName+tokenLimit]",
        usageStats: "[dateHour+threadId+modelName],threadId,characterId,dateHour", // note that characterId can be derived from threadId - it's just included for quick aggregation. modelName is like "gpt-3.5-turbo", dateHour is like "2023-3-29-14"
      }).upgrade(async tx => {

        await tx.table("characters").toCollection().modify(character => {
          upgradeCharacterFromOldVersion(character);
        });
        
        await tx.table("messages").toCollection().modify(message => {
          upgradeMessageFromOldVersion(message);
        });

        let characters = await tx.table("characters").toArray();
        await tx.table("threads").toCollection().modify(async thread => {
          await upgradeThreadFromOldVersion(thread, {characters});
        });        

        if(db.apiUsage) await db.apiUsage.delete();

        await tx.table("usageStats").toCollection().modify((entry, ref) => {
          if(entry.threadId === undefined) delete ref.value; // delete rows/entries that don't have a threadId - this was caused by some sort of bug in early implementation
        });

        await tx.table("summaries").toCollection().modify((entry, ref) => {
          if(entry.messageIds === undefined) delete ref.value; // old summaries didn't have messageIds or prevSummaryHash
        });


        let memories = await tx.table("memories").toArray();
        let userWrittenMemories = memories.filter(m => m.type === "user-written");
        if(userWrittenMemories.length > 0) {
          let loreEntries = [];
          for(let m of userWrittenMemories) {
            loreEntries.push({ bookId:m.threadId, text:m.text, embedding:m.embedding, triggers:[] });
          }
          await tx.table("lore").bulkAdd(loreEntries);
          await tx.table("memories").toCollection().modify((entry, ref) => {
            if(entry.type === "user-written") delete ref.value;
          });
          memories = memories.filter(m => m.type !== "user-written");
        }
        let memoryIdToIndexMap = createMemoryIdToIndexMapForIncorrectlyIndexedOrUnindexedMemories(memories);
        await tx.table("memories").toCollection().modify(memory => {
          let opts = {};
          if(memoryIdToIndexMap[memory.id] !== undefined) opts.index = memoryIdToIndexMap[memory.id];
          upgradeMemoryFromOldVersion(memory, opts);
        });

        await tx.table("lore").toCollection().modify(entry => {
          upgradeLoreFromOldVersion(entry);
        });
        

      });

      await db.open();

      if(dbLoadingModal) dbLoadingModal.delete();

      console.log("Database ready.");

      // Operation count management
      // Displays an approximate count of the number of operations since the last export was done
      let operationsSinceLastExport = (await db.misc.get("operationsSinceLastExport"))?.value || 0;

      async function updateExportDataButton() {
        if (operationsSinceLastExport == 0) {
          $.exportDataButton.title = "Export all data";
          $.exportDataButtonOperationCount.innerText = "";
        } else {
          $.exportDataButton.title = `Export all data (approximately ${operationsSinceLastExport} new/revised/deleted messages since last export)`;
          $.exportDataButtonOperationCount.innerText = operationsSinceLastExport;
        }
      }

      async function incrementOperationsSinceLastExport() {
        operationsSinceLastExport++;
        await db.misc.put({key:"operationsSinceLastExport", value:operationsSinceLastExport});
        await updateExportDataButton();
      }

      async function resetOperationsSinceLastExport() {
        operationsSinceLastExport = 0;
        await db.misc.put({key:"operationsSinceLastExport", value:operationsSinceLastExport});
        await updateExportDataButton();
      }

      await updateExportDataButton();

      // Release Notes
      // These are messages automatically displayed to the user when they load the page, if the user has not yet seen them.
      // Release notes should be kept in chronological order, oldest-first, in the array. ADD NEW RELEASE NOTES TO THE END.
      // DO NOT DELETE RELEASE NOTES UNLESS YOU'RE RESETTING THE NOTES COMPLETELY. (See releaseNotesSeries below for how to reset the notes.)
      // If an individual release note turns out to be wrong or obsolete, change it to the empty string and it will be skipped.
      // Editing the text of a release note will not redisplay it to users who have already seen it. If it's important that all users see the edited note, blank the existing release note out and create a new one with the edited text instead.

      const releaseNotesHTML = [
        "If you are using non-OpenAI models like HuggingFace, be aware that the properties used by OpenCharacters have changed slightly. See <a target='_blank' href='docs/custom-code.md'>the Custom Models documentation</a> for details.",
        "OpenCharacters now supports generating multiple reply variants at once. The menu next to the Send button controls how many reply variants are generated each time you use the Send or üîÅ buttons. This can save a lot of time and money if you frequently use the üîÅ button. For example, if you generate 5 reply variants at once, you'll only be charged once for the length of the existing conversation, though you'll still be charged for the length of all 5 replies.",
        "The 'Export' button will now display approximately how many things you've done since you last exported the database. This provides a little reminder to export regularly.",
        "Some OpenAI models mix smart (curly) quotation marks with normal quotation marks. OpenCharacters now tries to convert everything to smart quotes for consistency. When you're only receiving one reply at a time (the default), this won't happen until the reply is completely received. There's an advanced setting to let you choose whether each character should convert plain quotes to curly quotes, curly quotes to plain quotes, or leave it unchanged. This also applies to user messages sent to that character.",
        "There's now a thread settings button (‚öôÔ∏è) at the top of the chat window. That currently just lets you control the maximum token length of the message history that gets sent to the bots. This is good for long chats where you want to use an expensive model because you like its replies, but don't like how expensive it gets with long chats. If you set this, you have to use multiples of 1000.",
        "There's now an advanced character option to delete emoji from messages, if you like your replies emoji-free. Just like smart-quote handling, if you're receiving just one reply (the default), emoji won't be removed until after the whole reply is retrieved.",
        "There's now a checkbox in the character editing screen that lets you turn streaming replies on and off. Streaming replies mean that the message is displayed word-by-word as it arrives. It looks cool, but it's slower and uses quite a bit more bandwidth. Streaming is disabled if you're generating more than one reply at once.",
        "The model pricing information now includes the price of 'cached prompt tokens'. Some OpenAI models charge reduced prices if the start of the prompt stays the same from message to message. You may find that this reduces your cost (especially if you don't use memories and lore), but OpenAI's handling of prompt caching is unpredictable, so sometimes this won't work.",
        "There's now an advanced option in the character editing screen that lets you choose where to place memory/lore information in the prompt sent to the model. This has no effect if you don't use memories and lore. You can find that different models respond differently when the memories and lore are moved around. Also, moving memories and lore to the start or end of the conversation (rather than the start of the prompt) can reduce costs on models that support reduced pricing for cached tokens.",
      ];

      // If you ever want to do a full documentation update and delete the existing release notes, then do the following:
      // * Change releaseNotesHTML to an empty array.
      // * Increment the value of releaseNotesSeries.
      // This will reset each user's local database to reflect that they haven't seen any release notes.
      const releaseNotesSeries = 0;

      async function showReleaseNotes(forceAllReleaseNotes) {
        let lastReleaseNotesCount = 0;
        if (!forceAllReleaseNotes) {
          lastReleaseNotesCount = (await db.misc.get("lastReleaseNotesCount"))?.value || 0;
        }
        const lastReleaseNotesSeries = (await db.misc.get("lastReleaseNotesSeries"))?.value || 0;
        if (lastReleaseNotesSeries != releaseNotesSeries) {
          lastReleaseNotesCount = 0;
        }
        const releaseNotesCount = releaseNotesHTML.length;
        if (lastReleaseNotesCount > releaseNotesCount) {
          console.warn(`That's odd. The database thinks that ${lastReleaseNotesCount} notes have been shown, but there are only ${releaseNotesCount} release notes. Resetting.`);
          await db.misc.put({key:"lastReleaseNotesSeries", value:releaseNotesSeries});
          await db.misc.put({key:"lastReleaseNotesCount", value:releaseNotesCount});
        }
        else if (lastReleaseNotesCount < releaseNotesCount) {
          console.log(`Displaying new release notes. Release notes previously shown: ${lastReleaseNotesCount}. Release note count: ${releaseNotesCount}.`);
          let releaseNotes = "<h1>OpenCharacters release notes:</h1>";
          if (lastReleaseNotesCount == 0) {
            releaseNotes += "<p>Here are all the release notes for OpenCharacters -- things that might not be reflected in the documentation yet.</p>";
          } else {
            releaseNotes += "<p>It looks like there's been a recent update to OpenCharacters. Here are the new release notes you haven't seen.</p>";
          }
          releaseNotes += "<p><i>Don't panic!</i> If you don't understand what any of these release notes are saying, they don't apply to you.</p><ul>";
          let releaseNoteItems = "";  
          for (let i = lastReleaseNotesCount; i < releaseNotesCount; i++) {
            // Release notes might be blank if they're no longer applicable. Skip the blank ones.
            if (releaseNotesHTML[i] !== "") {
              releaseNoteItems += "<li>" + releaseNotesHTML[i] + "</li>";
            }
          }
          // If all the new release notes are blank, we don't actually have to show the dialog at all
          if (releaseNoteItems !== "") {
            releaseNotes += releaseNoteItems;
            releaseNotes += "</ul>";
            await prompt2({
              releaseNotes: {type: "none", height: "fit-content", html: releaseNotes},
            }, {
              cancelButtonText:null,
              submitButtonText:"OK"
            });
          }
          // Update the database whether we displayed anything or not
          await db.misc.put({key:"lastReleaseNotesSeries", value:releaseNotesSeries});
          await db.misc.put({key:"lastReleaseNotesCount", value:releaseNotesCount});
        }
      }

      showReleaseNotes(false);

      function upgradeCharacterInitialMessagesArrayIfNeeded(character) {
        // upgrade from the ["foo", "bar"] format to [{author:"user", content:"foo"}, {author:"ai", content:"bar"}]
        if(character.initialMessages && character.initialMessages.length === 1 && character.initialMessages[0] === "") {
          // bugfix:
          character.initialMessages = [];
        } else if(character.initialMessages && character.initialMessages.length > 0 && character.initialMessages[0] === "" && typeof character.initialMessages[1] === "object") {
          // bugfix:
          character.initialMessages = character.initialMessages.slice(1);
        } else if(character.initialMessages && character.initialMessages.length > 0 && typeof character.initialMessages[0] === "string") {
          // actual upgrade:
          let author = "user";
          for(let i = 0; i < character.initialMessages.length; i++) {   
            let content = character.initialMessages[i];
            if(content === "") { // if first message is empty, this indicates that character maker wanted AI to speak first
              author = (author === "user" ? "ai" : "user");
              continue;
            }
            character.initialMessages[i] = {
              author,
              content,
            };
            author = (author === "user" ? "ai" : "user");
          }
          if(character.initialMessages[0] === "") character.initialMessages = character.initialMessages.slice(1);
        }
      }

      function upgradeCharacterFromOldVersion(character) {
        upgradeCharacterInitialMessagesArrayIfNeeded(character);
        if(character.customCode === undefined) character.customCode = "";
        if(character.modelVersion) {
          character.modelName = character.modelVersion;
          delete character.modelVersion;
        }
        if (getCharacterModel(character.modelName) === undefined) {
          character.modelName = "good";
          alert("Character '" + character.name + "' is using a model that is no longer supported. Switching to the current OpenAI good/cheap model. If this isn't what you want, please edit the character.");
        }

        if(character.textEmbeddingModelName === undefined) {
          character.textEmbeddingModelName = character.associativeMemoryEmbeddingModelName ?? "default";
          delete character.associativeMemoryEmbeddingModelName;
        }

        if (getTextEmbeddingModel(character.textEmbeddingModelName) === undefined) {
          character.textEmbeddingModelName = "default";
          alert("Character '" + character.name + "' is using a text embedding model that is no longer supported. Switching to the current default embedding model.");
        }

        if(character.userCharacter === undefined) character.userCharacter = {};
        if(character.avatar === undefined) character.avatar = {url:character.avatarUrl, size:1, shape:"square"};
        if(character.hasOwnProperty("avatarUrl")) delete character.avatarUrl;
        if(character.scene === undefined) character.scene = {background:{}, music:{}};
        if(character.streamingResponse === undefined) character.streamingResponse = false;
        if(character.roleInstruction === undefined) {
          character.roleInstruction = character.systemMessage;
          delete character.systemMessage;
        }
        if(character.folderPath === undefined) character.folderPath = "";
        if(character.uuid === undefined) character.uuid = null;
        if(character.customData === undefined) character.customData = {};
        if(character.systemCharacter === undefined) character.systemCharacter = {avatar:{}};
        if(character.loreBookUrls === undefined) character.loreBookUrls = [];
        if(character.associativeMemoryMethod !== undefined) {
          character.autoGenerateMemories = character.associativeMemoryMethod;
          delete character.associativeMemoryMethod;
        }
        if(character.autoGenerateMemories === undefined) {
          character.autoGenerateMemories = "none"; // we need this because very old characters could have had not had a associativeMemoryMethod property at all (it didn't exist in the original schema)
        }
        if(character.maxTokensPerMessage === undefined) character.maxTokensPerMessage = null;
        
        // WARNING: If you add something here, you'll likely have to edit:
        //  - characterDetailsPrompt (characterDetailsPrompt should return a valid character object - addCharacter only adds creationTime and lastMessageTime, so characterDetailsPrompt should fill in everything else, even if it's not visible in the editor)
        //  - getUserCharacterObj
        //  - getSystemCharacterObj
        //  - characterPropertiesVisibleToCustomCode
        //  - addThread - for things like `character.scene` where it's copied over to the thread at the start, and custom code can only edit it from there
        //  - the "share link" creation code (if you add any other private/user-specific data like id, lastMessageTime, etc.)
        return character;
      }

      function upgradeMessageFromOldVersion(message) {
        if(!message.variants) message.variants = [null]; // null is the placeholder for the currently-chosen variant (stored in `message.message`)
        if(!message.hasOwnProperty("expectsReply")) message.expectsReply = undefined;
        if(!message.hasOwnProperty("summaryHashUsed")) message.summaryHashUsed = undefined; // undefined means that we don't know whether a summary was used because the message was created before this 'summaryUsed' feature was added
        if(message.memoryIdBatchesUsed === undefined) message.memoryIdBatchesUsed = [];
        if(message.loreIdsUsed === undefined) message.loreIdsUsed = [];
        if(message.scene === undefined) message.scene = null;
        if(message.avatar === undefined) message.avatar = {};
        if(message.customData === undefined) message.customData = {};
        if(message.wrapperStyle === undefined) message.wrapperStyle = "";
        if(message.memoryQueriesUsed === undefined) message.memoryQueriesUsed = [];
        if(message.messageIdsUsed === undefined) message.messageIdsUsed = [];
        if(message.order === undefined) message.order = message.id; // <-- this is a little hacky, but it works because id is auto-incremented, and `order` values don't need to be contiguous
        if(message.instruction === undefined) message.instruction = null;
        // WARNING: If you add something here, you may need to edit
        // - createMessageObj
        // - messagesToCustomCodeFormat and messagesFromCustomCodeFormat (if the data should be readable/writable from custom code)
        return message;
      }

      async function upgradeThreadFromOldVersion(thread, opts={}) {
        if(thread.isFav === undefined) thread.isFav = false;
        if(thread.userCharacter === undefined) thread.userCharacter = {avatar:{}}; // this overrides the default user character object (for this specific thread)
        if(thread.lastViewTime === undefined) thread.lastViewTime = thread.lastMessageTime;
        if(thread.customCodeWindow === undefined) thread.customCodeWindow = {visible:false, width:null}; 
        if(thread.customData === undefined) thread.customData = {}; 
        if(thread.modelName === undefined) {
          let character;
          if(opts.characters) {// need this specifically for the db upgrade() function (i.e. not needed in import code) since modify can't be `async`, so we get all characters beforehand and pass them to this function
            // oh and I now use this in the import code too because we need to pass in the *new* characters as well, since new threads can obviously reference them.
            character = opts.characters.find(c => c.id === thread.characterId);
          } else {
            character = await db.characters.get(thread.characterId);
          }
          thread.modelName = character.modelName; // don't need to do good/great conversion here because that was not a feature previous to this change
        }
        if (getCharacterModel(thread.modelName) === undefined) {
          thread.modelName = "good";
          alert("Thread " + thread.id + " is using a model that is no longer supported. Switching to the current OpenAI good/cheap model. If this isn't what you want, please pick a new model manually.");
        }

        {
          let character;
            if(opts.characters) character = opts.characters.find(c => c.id === thread.characterId);
            else character = await db.characters.get(thread.characterId);
          if(thread.textEmbeddingModelName === undefined) {
            thread.textEmbeddingModelName = character.textEmbeddingModelName;
          }

          if (getTextEmbeddingModel(thread.textEmbeddingModelName) === undefined) {
            character.textEmbeddingModelName = "default";
            alert("Thread " + thread.id + " is using a text embedding model that is no longer supported. Switching to the current default embedding model.");
          }
        }
        if(thread.folderPath === undefined) thread.folderPath = ""; 
        if(thread.character === undefined) thread.character = {avatar:{}}; 
        if(thread.systemCharacter === undefined) thread.systemCharacter = {avatar:{}}; // this overrides the default user character object (for this specific thread)
        if(thread.loreBookId === undefined) thread.loreBookId = thread.id; // user-written memories for each thread are now lore entries, and for simplicity I've made the lorebook id equal to the thread id the the existing lore entries (thread and lorebook ids are not actually coupled though)
        if(thread.messageWrapperStyle === undefined) thread.messageWrapperStyle = "";
        if(thread.userMessagesSentHistory === undefined) thread.userMessagesSentHistory = [];
        if(thread.unsentMessageText === undefined) thread.unsentMessageText = "";
        if(thread.shortcutButtons === undefined) thread.shortcutButtons = [];
        for(let shortcut of thread.shortcutButtons) {
          if(shortcut.insertionType === undefined) shortcut.insertionType = "replace";
        }
        if(thread.currentSummaryHashChain === undefined) thread.currentSummaryHashChain = null; // NOTE: currentSummaryHashChain isn't added here since we need the thread to be fully loaded before we can calculate it (including the custom code iframe), so we have a function to access this thread property which will calculate it if it's not already calculated

        // WARNING: If you add something here, you may need to edit:
        // - addThread
        // - getThreadJSONById
        // and if exposing to custom code:
        // - window.oc.thread.<...>  (during declaration of window.oc object, with Object.seal if property is an object)
        // - getDataForCustomCode  (sending data to custom code)
        // - updateDbWithNewDataFromCustomCode (receiving data from custom code)
        return thread;
      }

      function upgradeMemoryFromOldVersion(memory, opts={}) {
        if(memory.type === "user-written") return; // these will be moved to the lore table and deleted from the memories table

        if(opts.index !== undefined) {
          delete memory.nextMemoryId;
          delete memory.previousMemoryId;
          memory.index = opts.index;
        }
        delete memory.type; // no longer need type="generated" because it's the only type (and also a better name would be "chronological" because user's can edit them and add their own)

        if(Array.isArray(memory.embedding)) {
          memory.embeddings = {"text-embedding-ada-002":memory.embedding};
          delete memory.embedding;
          if(memory.$types) {
            // needed for manual upgrading of dexie json import (still don't know why we need to manually upgrade stuff though - should be able to import old json and it upgrades automatically)
            memory.$types["embeddings.text-embedding-ada-002"] = memory.$types.embedding;
            delete memory.$types.embedding;
          }
        }
      }

      function upgradeLoreFromOldVersion(entry) {
        if(entry.bookUrl === undefined) entry.bookUrl = null;
        if(Array.isArray(entry.embedding)) {
          entry.embeddings = {"text-embedding-ada-002":entry.embedding};
          delete entry.embedding;
          if(entry.$types) {
            // needed for manual upgrading of dexie json import (still don't know why we need to manually upgrade stuff though - should be able to import old json and it upgrades automatically)
            entry.$types["embeddings.text-embedding-ada-002"] = entry.$types.embedding;
            delete entry.$types.embedding;
          }
        }
      }


      // function createMemoryIdToIndexMapFromAllMemories(memories) {
      //   // each memory has `nextMemoryId` and `previousMemoryId`, but we need to convert to `index` format.
      //   // we need to create a map of memory.id -> index
      //   // but first we need to group all memories by their threadId
      //   let memoriesByThreadId = {};
      //   for(let memory of memories) {
      //     if(memory.type === "user-written") continue; // <-- these don't have an order/index, and are being moved to the lore table
      //     if(!memoriesByThreadId[memory.threadId]) memoriesByThreadId[memory.threadId] = [];
      //     memoriesByThreadId[memory.threadId].push(memory);
      //   }
      //   // now for each thread's memories we follow the `previousMemoryId`/`nextMemoryId` chain to sort them
      //   // the first memory in the chain will have previousMemoryId==-1, so we get that first, and then crawl through:
      //   let memoryIdToIndexMap = {};
      //   for(let threadId of Object.keys(memoriesByThreadId)) {
      //     let threadMemories = memoriesByThreadId[threadId];
      //     threadMemories.sort((a,b) => a.id - b.id);
      //     for(let i = 0; i < threadMemories.length; i++) {
      //       memoryIdToIndexMap[threadMemories[i].id] = i;
      //     }
          
      //     // this was buggy for some reason:
      //     // let index = 0;
      //     // while(memory) {
      //     //   memoryIdToIndexMap[memory.id] = index;
      //     //   index++;
      //     //   memory = threadMemories.find(m => m.previousMemoryId === memory.id);
      //     // }
      //   }
      //   return memoryIdToIndexMap;
      // }

      function createMemoryIdToIndexMapForIncorrectlyIndexedOrUnindexedMemories(memories) {
        let memoriesByThreadId = {};
        for(let m of memories) {
          if(!memoriesByThreadId[m.threadId]) memoriesByThreadId[m.threadId] = [];
          memoriesByThreadId[m.threadId].push(m);
        }
        // for each thread, check that memory indices (m.index) exist for each memory and are unique:
        let threadIdsThatNeedToBeIndexed = [];
        for(let threadId of Object.keys(memoriesByThreadId)) {
          let memories = memoriesByThreadId[threadId];
          let indices = memories.map(m => m.index);
          if(indices.includes(undefined) || indices.length !== new Set(indices).size) {
            threadIdsThatNeedToBeIndexed.push(threadId);
          }
        }
        let memoryIdToIndexMap = {};
        if(threadIdsThatNeedToBeIndexed.length > 0) {
          for(let threadId of threadIdsThatNeedToBeIndexed) {
            let memories = memoriesByThreadId[threadId];
            memories.sort((a,b) => a.id - b.id);
            for(let i = 0; i < memories.length; i++) {
              let m = memories[i];
              m.index = i;
              memoryIdToIndexMap[m.id] = i;
            }
          }
        }
        return memoryIdToIndexMap;
      }
      

      window.db = db;


      let availableModels = {};

      // for openai and webgpu/webnn models (i.e. you don't need to setup your own inference server, and most people already have an openai account):
      // Prices are per 1M tokens
      let broadlyAvailableModels = [
        {name:"chatgpt-4o-latest", shortLabel:"ChatGPT-4o Latest", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:128000, type:"chat-completion", systemRole: "system", noTemperatureSupport:false, multipleResponseSupport:true, tokenPricing:{ prompt:5.00, cachedprompt:5.00, completion:15.00 }},
        {name:"gpt-4o", shortLabel:"GPT-4o", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:128000, type:"chat-completion", systemRole: "system", noTemperatureSupport:false, multipleResponseSupport:true, tokenPricing:{ prompt:2.50, cachedprompt:1.25, completion:10.00 }},
        {name:"gpt-4o-mini", shortLabel:"GPT-4o-mini", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:128000, type:"chat-completion", systemRole: "system", noTemperatureSupport:false, multipleResponseSupport:true, tokenPricing:{ prompt:0.15, cachedprompt:0.075, completion:0.60 }},
        {name:"gpt-4.1", shortLabel:"GPT-4.1", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:128000, type:"chat-completion", systemRole: "system", noTemperatureSupport:false, multipleResponseSupport:true, tokenPricing:{ prompt:2.00, cachedprompt:0.50, completion:8.00 }},
        {name:"gpt-4.1-mini", shortLabel:"GPT-4.1-mini", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:128000, type:"chat-completion", systemRole: "system", noTemperatureSupport:false, multipleResponseSupport:true, tokenPricing:{ prompt:0.40, cachedprompt:0.10, completion:1.60 }},
        {name:"gpt-4.1-nano", shortLabel:"GPT-4.1-nano", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:128000, type:"chat-completion", systemRole: "system", noTemperatureSupport:false, multipleResponseSupport:true, tokenPricing:{ prompt:0.10, cachedprompt:0.025, completion:0.40 }},
        {name:"o3-mini", shortLabel:"o3-mini", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:200000, type:"chat-completion", systemRole: "system", noTemperatureSupport:true, useMaxCompletionTokens: true, multipleResponseSupport:true, tokenPricing:{ prompt:1.10, cachedprompt:0.55, completion:4.40 }},        
        {name:"text-embedding-3-small", shortLabel:"text-embedding-3-small", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:8192, type:"text-embedding", noTemperatureSupport:false, useMaxCompletionTokens:false, multipleResponseSupport:false, averageInverseDistance:1.2, tokenPricing:{ prompt:0.02, completion: 0.02 }},
        {name:"text-embedding-ada-002", shortLabel:"text-embedding-ada-002", endpointUrl:"https://api.openai.com/v1/chat/completions", modelUrl:null, apiKey:"<OPENAI>", maxSequenceLength:8192, type:"text-embedding", noTemperatureSupport:false, useMaxCompletionTokens:false, multipleResponseSupport:false, averageInverseDistance:4, tokenPricing:{ prompt:0.10, completion: 0.10 }},
      ];
      const modelPricingLastUpdateDate = new Date("2025-06-02");

      // Model used for "good" character default option
      const openAIGoodCharacterModel = "gpt-4o-mini";
      // Model used for "great" character default option
      const openAIGreatCharacterModel = "gpt-4o";
      // Model used for OpenAI summarization
      const openAISummarizationModel = openAIGoodCharacterModel;
      // Model used for "recompute with alternate model" button
      const openAIAlternateModel = openAIGoodCharacterModel;
      // Model used by default for text embedding
      const openAIDefaultTextEmbeddingModel = "text-embedding-3-small";

      function getRealCharacterModelName(modelName)
      {
        if(modelName === "good") { return openAIGoodCharacterModel };
        if(modelName === "great") { return openAIGreatCharacterModel; }
        return modelName;
      }

      function getRealTextEmbeddingModelName(modelName) 
      {
        if(modelName === "default") { return openAIDefaultTextEmbeddingModel; }
        return modelName;
      }

      function getRealModelName(modelName) {
        if(modelName === "good") { return openAIGoodCharacterModel };
        if(modelName === "great") { return openAIGreatCharacterModel; }
        if(modelName === "default") { return openAIDefaultTextEmbeddingModel; }
        return modelName;
      }

      function getCharacterModel(modelName) {
        return availableModels[getRealCharacterModelName(modelName)];
      }

      function getTextEmbeddingModel(modelName) {
        return availableModels[getRealTextEmbeddingModelName(modelName)];
      }
      
      function getModel(modelName) {
        return availableModels[getRealModelName(modelName)];
      }

      async function handleThreadModelSelectorInfoButton() {
        await prompt2({
            message: {type:"none", "html":`<p>This shows the price of the model. For example, &quot;$3.00/$1.00/$2.00&quot; means that the model charges $3.00 per million tokens in the prompt, but only $1.00 per million tokens for 'cached tokens' -- parts of the beginning of the prompt that haven't changed, like the character description. It charges $2.00 per million tokens for its answers.</p></p>This pricing information is manually updated and may not reflect current pricing. Also, pricing information displayed in OpenCharacters may be inaccurate. Always regularly check the charges you are actually incurring.</p><p>Pricing last checked on ${modelPricingLastUpdateDate.toLocaleDateString()}.</p>`},
          }, {
            cancelButtonText:null,
            submitButtonText:"OK"
          });
      }
      $.threadModelSelectorInfoButton.addEventListener("click", handleThreadModelSelectorInfoButton);
      $.threadModelSelectorInfoButton.title = `Pricing last checked on ${modelPricingLastUpdateDate.toLocaleDateString()}.`;

      async function handleAdviceOnThreadsButton() {
        await showAdviceOnThreads(false);
      }
      $.adviceOnThreadsButton.addEventListener("click", handleAdviceOnThreadsButton);

      async function updateModelList() {
        // console.log("updateModelList");
        let modelsArr = broadlyAvailableModels.slice(0);
        let customModelConfigs = (await db.misc.get("customModelConfigs"))?.value || [];
        // console.log("updateModelList", customModelConfigs);
        modelsArr.push(...customModelConfigs);
        availableModels = {};
        for(let m of modelsArr) {
          availableModels[m.name] = m;
        }
        // console.log("updateModelList", availableModels);
        let currentValue = $.threadModelSelector;
        $.threadModelSelector.innerHTML = modelsArr.filter(m => m.type === "completion" || m.type === "chat-completion").map(m => `<option value="${m.name}" ${m.name === currentValue ? "selected" : ""}>${getMenuLabelForModel(m)}</option>`).join("");
        $.threadModelSelectorInfoButton.title = "Pricing last checked on " + modelPricingLastUpdateDate.toLocaleDateString();
        let daysSincePricingCheck = (new Date() - modelPricingLastUpdateDate) / (1000 * 3600 * 24);
        if (daysSincePricingCheck > 90) {
          $.threadModelSelectorInfoButton.innerText = "‚ö†Ô∏è";
        } 
      }
      updateModelList();

      // Calculates a display name for the model, which includes pricing information
      function getMenuLabelForModel(m) {
        return m.shortLabel + " ($" + m.tokenPricing.prompt.toFixed(2) + "/$" + m.tokenPricing.cachedprompt.toFixed(2) + "/$" + m.tokenPricing.completion.toFixed(2) + ")";
      }

      function modelIsOpenAiModel(modelName) {
        let modelObj = getModel(modelName);
        if (modelObj === undefined) { throw new Error(`Unknown model ${modelName}`); }
        return modelObj.endpointUrl.startsWith("https://api.openai.com");
      }

      async function threadIsUsingOpenAiModel(threadOrThreadId) {
        let thread;
        if(typeof threadOrThreadId === "number") {
          thread = await db.threads.get(threadOrThreadId);
        } else {
          thread = threadOrThreadId;
        }
        return (await modelIsOpenAiModel(thread.modelName));
      }

      function modelSupportsMultipleResponses(modelName) {
        let modelObj = getModel(modelName);
        if (modelObj === undefined) { throw new Error(`Unknown model ${modelName}`); }
        return modelObj.multipleResponseSupport;
      }

      $.documentationButton.addEventListener("click", async function() { window.open(projectHomePageURL); });
      $.releaseNotesButton.addEventListener("click", async function() { showReleaseNotes(true); });

      // export data if they click export button
      $.exportDataButton.addEventListener("click", async function() {
        // choose export options
        let result = await prompt2({
          exportUserData: {label: "Export user settings? (API key, avatar, name)", type: "select", options:[{value: "yes", content: "Yes"}, {value: "no", content: "No"}]},
          exportType: {label: "Export type", type: "select", options:[{content: "All characters and chats", value:"allCharactersAndThreads"}, {content: "All characters, no chats", value:"allCharactersNoThreads"}, {content: "Specific characters", value:"specificCharacters"}, {content: "Specific chats", value:"specificThreads"}]},
          exportThreadIds: {show:(data) => data.exportType==="specificThreads", label: "Chat IDs to export (comma-separated numbers). Chat IDs are shown in bottom-right of each chat card in the side bar. The characters associated with these chats will be exported too.", type: "textLine", defaultValue: "", placeholder:"23,45,67"},
          exportCharacterIds: {show:(data) => data.exportType==="specificCharacters", label: "Character IDs to export (comma-separated numbers). Character IDs are shown next to the character name.", type: "textLine", defaultValue: "", placeholder:"3,12,7,14"},
          includeThreadsOfCharacters: {show:(data) => data.exportType==="specificCharacters", label: "Include all chats with these characters?", type: "select", options:[{value: "yes", content: "Yes"}, {value: "no", content: "No"}], defaultValue: "no"},
        });
        if(!result) return;

        let loadingModal = createLoadingModal(`Please wait...<br><span style="font-size:80%; opacity:0.6;">This could take a while if you have a lot of data.</span>`);

        const blob = await db.export({prettyJson:true, numRowsPerChunk:100});
        const json = await new Response(blob).json(); // use Response hack instead of JSON.parse(await blob.text()) to avoid maximum string length errors

        let keepThreadCheck;
        let keepCharacterCheck;
        let keepLoreBookCheck;
        let keepLoreBookUrlCheck;
        if(result.exportType === "allCharactersAndThreads") {
          keepThreadCheck = (id) => true;
          keepLoreBookCheck = (id) => true;
          keepLoreBookUrlCheck = (url) => true;
          keepCharacterCheck = (id) => true;
        } else if (result.exportType === "allCharactersNoThreads") {
          keepThreadCheck = (id) => false;
          keepLoreBookCheck = (id) => false;
          keepLoreBookUrlCheck = (url) => false;
          keepCharacterCheck = (id) => true;
        } else if (result.exportType === "specificCharacters") {
          if(!result.exportCharacterIds.trim()) return alert("You must specify at least one character ID to export.")
          
          const keepCharacterIds = result.exportCharacterIds.split(",").map(s => parseInt(s)).filter(id => !isNaN(id));
          keepCharacterCheck = (id) => keepCharacterIds.includes(id);

          if(result.includeThreadsOfCharacters === "yes") {
            const keepCharacters = await db.characters.where("id").anyOf(keepCharacterIds).toArray();
            const keepThreads = await db.threads.where("characterId").anyOf(keepCharacterIds).toArray();
            const keepThreadIds = keepThreads.map(t => t.id);
            const keepLoreBookIds = keepThreads.map(t => t.loreBookId);
            const keepLoreBookUrls = keepCharacters.map(c => c.loreBookUrls).flat();
            keepThreadCheck = (id) => keepThreadIds.includes(id);
            keepLoreBookCheck = (id) => keepLoreBookIds.includes(id);
            keepLoreBookUrlCheck = (url) => keepLoreBookUrls.includes(url);
          } else {
            keepThreadCheck = (id) => false;
            keepLoreBookCheck = (id) => false;
            keepLoreBookUrlCheck = (url) => false;
          }
        } else if (result.exportType === "specificThreads") {
          if(!result.exportThreadIds.trim()) return alert("You must specify at least one thread ID to export.")
          const keepThreadIds = result.exportThreadIds.split(",").map(s => parseInt(s)).filter(id => !isNaN(id));
          const keepThreads = await db.threads.where("id").anyOf(keepThreadIds).toArray();
          const keepCharacterIds = [...new Set(keepThreads.map(t => t.characterId))];
          const keepCharacters = await db.characters.where("id").anyOf(keepCharacterIds).toArray();
          const keepLoreBookUrls = keepCharacters.map(c => c.loreBookUrls).flat();
          const keepLoreBookIds = keepThreads.map(t => t.loreBookId);
          keepThreadCheck = (id) => keepThreadIds.includes(id);
          keepLoreBookCheck = (id) => keepLoreBookIds.includes(id);
          keepLoreBookUrlCheck = (url) => keepLoreBookUrls.includes(url);
          keepCharacterCheck = (id) => keepCharacterIds.includes(id);
        }

        
        if(result.exportUserData === "no") {
          json.data.data.find(d => d.tableName === "misc").rows = [];
        }
        // remove datesApplicationWasUsedInThisBrowser because it's browser-specific 
        json.data.data.find(d => d.tableName === "misc").rows = json.data.data.find(d => d.tableName === "misc").rows.filter(r => r.key !== "datesApplicationWasUsedInThisBrowser");

        let threads = json.data.data.find(d => d.tableName === "threads");
        threads.rows = threads.rows.filter(t => keepThreadCheck(t.id));

        let characters = json.data.data.find(d => d.tableName === "characters");
        characters.rows = characters.rows.filter(c => keepCharacterCheck(c.id));

        let messages = json.data.data.find(d => d.tableName === "messages");
        messages.rows = messages.rows.filter(m => keepThreadCheck(m.threadId));

        let summaries = json.data.data.find(d => d.tableName === "summaries");
        if(summaries) {
          let summaryHashesToKeep = new Set(threads.rows.map(t => t.currentSummaryHashChain ?? []).flat());
          // Note: s.threadId only exists for 'legacy' reasons (we don't rely on it because a summary can be used by multiple threads), but it's useful here because currentSummaryHashChain is a new property and may not exist for old threads, so we can use the threadId as a backup check
          summaries.rows = summaries.rows.filter(s => summaryHashesToKeep.has(s.hash) || keepThreadCheck(s.threadId));
        }

        let memories = json.data.data.find(d => d.tableName === "memories");
        if(memories) {
          memories.rows = memories.rows.filter(m => keepThreadCheck(m.threadId));
        }

        let lore = json.data.data.find(d => d.tableName === "lore");
        if(lore) {
          lore.rows = lore.rows.filter(l => keepLoreBookCheck(l.bookId) || keepLoreBookUrlCheck(l.bookUrl));
        }

        let textEmbeddingCache = json.data.data.find(d => d.tableName === "textEmbeddingCache");
        if(textEmbeddingCache) {
          let memoryAndLoreTextHashes = new Set(await Promise.all([...lore.rows, ...memories.rows].map(entry => sha256Text(entry.text))));
          textEmbeddingCache.rows = textEmbeddingCache.rows.filter(c => memoryAndLoreTextHashes.has(c.textHash));
        }

        if(result.exportUserData === "no") {
          json.data.data.find(d => d.tableName === "usageStats").rows = [];
        } else {
          let usageStats = json.data.data.find(d => d.tableName === "usageStats");
          usageStats.rows = usageStats.rows.filter(entry => keepThreadCheck(entry.threadId) && keepCharacterCheck(entry.characterId));
        }

        let yyyymmdd = new Date().toISOString().split("T")[0];
        downloadTextOrBlob(JSON.stringify(json), `opencharacters-export-${yyyymmdd}.json`);
        await resetOperationsSinceLastExport();

        loadingModal.delete();
      });

      // This renders the list of threads in the left column.
      async function renderThreadList(opts={}) {
        if(!opts.maxShownThreads) opts.maxShownThreads = 50;

        let threads = await db.threads.orderBy("lastMessageTime").reverse().toArray();

        if(threads.length >= 3) {
          showEl($.threadSearchCtn);
        } else {
          hideEl($.threadSearchCtn);
        }

        let currentFolderPath = $.chatThreads.dataset.currentFolderPath;
        let allFolderPaths = [...new Set(threads.map(t => t.folderPath))];
        let currentSubfolderNames = [...new Set(allFolderPaths.filter(p => p.startsWith(currentFolderPath) && p !== currentFolderPath).map(p => p.split("/").slice(currentFolderPath.split("/").length-(currentFolderPath === "" ? 1 : 0)).filter(s => s)[0]))];

        if(!opts.filterWithQuery) { // don't do folder stuff if they're searching
          threads = threads.filter(t => t.folderPath === currentFolderPath);
        }

        let characters = await db.characters.toArray();
        for(let thread of threads) {
          thread.character = characters.find(c => c.id === thread.characterId) || null;
        }

        let threadsWithoutCharacter = threads.filter(t => !t.character);
        if(threadsWithoutCharacter.length > 0) {
          let r = prompt(`You have one or more threads (with ids=${threadsWithoutCharacter.map(t => t.id).join(",")}) that are referencing character(s) that don't exist. This is a bug. Please report it on Github or Discord. You can type "yes" below to delete these threads if a OpenCharacters dev has recommended it, otherwise just click OK.`);
          if(r?.toLowerCase().trim() === "yes") {
            for(let thread of threadsWithoutCharacter) {
              await safelyDeleteThreadById(thread.id);
            }
          }
        }

        threads = threads.filter(t => t.character);

        if(opts.filterWithQuery) {
          let q = opts.filterWithQuery.toLowerCase();
          // iterate over all threads, and all messages in each thread, and tally query "hits" for the threads
          for(let thread of threads) {
            thread.queryHits = 0;
            const messages = await db.messages.where("threadId").equals(thread.id).toArray();
            for(let message of messages) {
              if(message.message.toLowerCase().includes(q)) {
                thread.queryHits++;
              }
            }
          }
          // sort and filter
          threads.sort((a,b) => b.queryHits - a.queryHits);
          threads = threads.filter(t => t.queryHits > 0);
          for(let thread of threads) {
            delete thread.queryHits;
          }
        }

        let threadIdToMoneySpent = {};
        for(let thread of threads) {
          let entries = await db.usageStats.where("threadId").equals(thread.id).toArray();
          threadIdToMoneySpent[thread.id] = usageStatsEntriesToCost(entries);
        }

        // move isFav threads to top without affecting order of the others:
        threads.sort((a,b) => {
          if(a.isFav && !b.isFav) return -1;
          if(!a.isFav && b.isFav) return 1;
          return 0;
        });

        let threadFolderData = (await db.misc.get("threadFolderData"))?.value || {};

        let foldersHtml = "";
        if(!opts.filterWithQuery) { // don't do folder stuff if they're searching
          if(currentFolderPath !== "") {
            foldersHtml += `<div class="threadFolder" data-folder-path="${sanitizeHtml(currentFolderPath.split("/").slice(0, -1).join("/"))}">üîô up one level</div>`;
          }
          foldersHtml += currentSubfolderNames.map(name => {
            let folderPath = currentFolderPath ? currentFolderPath+"/"+name : name;
            let icon = threadFolderData[folderPath]?.emoji;
            if(icon && icon.startsWith("http")) {
              icon = `<img src="${sanitizeHtml(icon)}" style="height:1.2rem; width:1.2rem; object-fit:cover; border-radius:2px;"/>`;
            }
            return `<div class="threadFolder" title="Thread folders" data-folder-path="${sanitizeHtml(folderPath)}">${icon ?? "üìÅ"}<span style="flex-grow:1; margin-left:0.5rem;">${sanitizeHtml(name)}</span><span title="Edit folder name" class="editFolderName emojiButton" style="font-size:0.7rem; display:flex; align-items:center;">‚úèÔ∏è</span></div>`;
          }).join("");
        }
        // $.chatThreadFolders.innerHTML = foldersHtml;

        let dataUrlToCachedBlobUrlMap = {};
        for(let thread of threads) {
          let avatarUrl = thread.character.avatar.url;
          if(avatarUrl && avatarUrl.startsWith("data:")) {
            dataUrlToCachedBlobUrlMap[avatarUrl] = await dataUrlToCachedBlobUrl(avatarUrl);
          }
        }

        let showAllButtonHtml = "";
        if(threads.length > opts.maxShownThreads) {
          showAllButtonHtml = `<div style="text-align:center; margin-top:0.5rem;"><button class="showAllThreadsButton">show all threads</button></div>`;
          threads = threads.slice(0, opts.maxShownThreads);
        }

        let threadsHtml = threads.map(thread => {
          let avatarUrl = thread.character.avatar.url;
          if(avatarUrl && avatarUrl.startsWith("data:")) {
            avatarUrl = dataUrlToCachedBlobUrlMap[avatarUrl];
          }
          return `
            <div class="thread" title="${sanitizeHtml(thread.name)}" data-thread-id="${sanitizeHtml(thread.id)}">
              <span class="favStar" data-is-fav="${thread.isFav}">‚≠ê</span>
              <span class="changeFolderPath">üìÅ</span>
              <div class="avatar" style="${avatarUrl ? `background-image:url(${sanitizeHtml(avatarUrl)})` : ""}; border:1px solid var(--border-color);"></div>
              <div class="info" style="flex-grow:1; padding-left:0.5rem;">
                <div class="nameWrapper" style="font-weight:bold; font-size:0.8rem;"><span class="name" title="${sanitizeHtml(thread.name)}">${sanitizeHtml(thread.name)}</span></div>
                <div class="characterName" style="font-size:0.8rem;">${thread.character.name.length > 15 ? sanitizeHtml(thread.character.name.slice(0, 15)+"‚Ä¶") : sanitizeHtml(thread.character.name)} <span style="opacity:0.5; font-weight:normal;" title="Character ID">#${sanitizeHtml(thread.character.id)}</span> <span title="Edit character" class="characterEditButton">‚úèÔ∏è</span></div>
                <div style="font-size:0.8rem; opacity:0.5; padding-right:0.5rem; display:flex; justify-content:space-between;"><span style="font-size:0.65rem;" title="${sanitizeHtml(thread.modelName)}">${thread.modelName.length > 13 ? sanitizeHtml(thread.modelName.slice(0, 13))+"‚Ä¶" : sanitizeHtml(thread.modelName)}</span><span class="usageStatsSpend" title="API usage/spend" style="font-size:0.65rem;display:flex;align-items:center;">$${threadIdToMoneySpent[thread.id].toFixed(2)}</span><span style="font-size:0.65rem; display:flex; align-items:center; filter:grayscale(1);" title="Thread ID">üßµ#${sanitizeHtml(thread.id)}</span></div>
              </div>
              <div style="display:flex; flex-direction:column; justify-content:space-between; font-size:0.65rem;">
                <span title="Rename thread" class="button nameEditButton">‚úèÔ∏è</span>
                <span title="Export thread" class="button exportButton">üíæ</span>
                <span title="Delete thread" class="button deleteButton">üóëÔ∏è</span>
              </div>
            </div>`;
        }).join("");

        $.chatThreads.innerHTML = foldersHtml + threadsHtml + showAllButtonHtml;


        $.chatThreads.querySelector(".showAllThreadsButton")?.addEventListener("click", function() {
          opts.maxShownThreads = Infinity;
          renderThreadList(opts);
        });

        // if message feed is visible, set selected thread to the currently-visible chat thread
        if($.messageFeed.offsetWidth > 0 && activeThreadId !== null) {
          let threadCardForActiveThread = $.chatThreads.querySelector(`.thread[data-thread-id="${activeThreadId}"]`);
          if(threadCardForActiveThread) threadCardForActiveThread.classList.add("selected");
        }

        $.chatThreads.querySelectorAll(".editFolderName").forEach(btn => {
          btn.addEventListener("click", async function(e) {
            e.stopPropagation();
            const folderPath = btn.closest(".threadFolder").dataset.folderPath;
            
            let label;
            if(folderPath.split("/").length === 1) {
              label = `Edit the name of this folder:`;
            } else {
              label = `Edit the name of this folder by changing '${folderPath.split("/").at(-1)}' to something else, or move all items inside the '${folderPath.split("/").at(-1)}' folder to a new location by editing the whole folder path:`;
            }
            let threadFolderData = (await db.misc.get("threadFolderData"))?.value || {};

            let result = await prompt2({
              newFolderPath: {type:"textLine", label, defaultValue:folderPath},
              emoji: {type:"textLine", label:"Folder emoji or image URL:", defaultValue:threadFolderData[folderPath]?.emoji || ""},
            });
            if(!result) return;

            if(result.emoji) {
              if(!threadFolderData[folderPath]) threadFolderData[folderPath] = {};
              threadFolderData[folderPath].emoji = result.emoji;
            }

            await db.misc.put({key:"threadFolderData", value:threadFolderData});

            let newFolderPath = result.newFolderPath.trim().replace(/^\//, "").replace(/\/$/, "").trim();
            // each thread has a folderPath property, which is a string like "folder1/folder2/folder3" or just "" (empty string) if it's in the root folder
            await db.threads.toCollection().modify(function(thread) {
              // we need to move all threads that start with folderPath to newFolderPath
              if(thread.folderPath === folderPath) {
                thread.folderPath = newFolderPath;
              } else if(thread.folderPath.startsWith(folderPath+"/")) {
                thread.folderPath = newFolderPath + thread.folderPath.slice(folderPath.length);
              }
            });
            await renderThreadList();
            await incrementOperationsSinceLastExport();
          }, {passive: true});
        });

        $.chatThreads.querySelectorAll(".thread").forEach(thread => {
          thread.addEventListener("click", async function() {
            const threadId = parseInt(thread.dataset.threadId);
            let loadingModal = createLoadingModal("Loading...");
            await showThread(threadId);
            loadingModal.delete();
          }, {passive: true});
        });
        $.chatThreads.querySelectorAll(".thread .favStar").forEach(favStarEl => {
          favStarEl.addEventListener("click", async function(e) {
            e.stopPropagation();
            const threadId = parseInt(favStarEl.closest(".thread").dataset.threadId);
            let thread = await db.threads.get(threadId);
            let isFav = !thread.isFav;
            await db.threads.update(threadId, { isFav });
            favStarEl.dataset.isFav = isFav;
            await incrementOperationsSinceLastExport();
          }, {passive: true});
        });
        $.chatThreads.querySelectorAll(".thread .changeFolderPath").forEach(changeFolderPathEl => {
          changeFolderPathEl.addEventListener("click", async function(e) {
            e.stopPropagation();
            const threadId = parseInt(changeFolderPathEl.closest(".thread").dataset.threadId);
            let thread = await db.threads.get(threadId);
            let newFolderPath = prompt(`Enter new folder path for this thread. You can add subfolders with forward-slashes like 'folder/subfolder/...'`, thread.folderPath);
            if(newFolderPath !== null) {
              newFolderPath = newFolderPath.trim().replace(/^\//, "").replace(/\/$/, "").trim();
              await db.threads.update(threadId, { folderPath: newFolderPath });
              await renderThreadList();
              await incrementOperationsSinceLastExport();
            }
          }, {passive: true});
        });
        $.chatThreads.querySelectorAll(".threadFolder").forEach(threadFolderEl => {
          threadFolderEl.addEventListener("click", async function(e) {
            e.stopPropagation();
            $.chatThreads.dataset.currentFolderPath = threadFolderEl.dataset.folderPath;
            await renderThreadList();
          }, {passive: true});
        });
        $.chatThreads.querySelectorAll(".nameEditButton").forEach(btn => {
          btn.addEventListener("click", async function(e) {
            e.stopPropagation();
            const threadId = parseInt(btn.closest(".thread").dataset.threadId);
            let thread = await db.threads.get(threadId);
            // edit the thread name and re-render thread list.
            let newName = prompt("Enter new name for this thread.", thread.name);
            if(newName && (newName != thread.name)) {
              await db.threads.update(threadId, { name: newName });
              await renderThreadList();
              await incrementOperationsSinceLastExport();
            }
          }, {passive: true});
        });
        $.chatThreads.querySelectorAll(".usageStatsSpend").forEach(btn => {
          btn.addEventListener("click", async function(e) {
            e.stopPropagation();
            alert("OpenCharacters is a completely free application, but to use it, you need to connect it with one or more 'API' providers which act as the 'brains' of your characters. The spend figure you just clicked represents an estimate for the amount of money you've spent using the API that you have connected. If you're using OpenAI, you can see authorative spend amounts here:\n\nhttps://platform.openai.com/account/usage");
          }, {passive: true});
        });
        $.chatThreads.querySelectorAll(".exportButton").forEach(btn => {
          btn.addEventListener("click", async function(e) {
            e.stopPropagation();

            const result = await prompt2({
              exportType: {label: "export type:", type: "select", options:[{value:"json", content:"whole thread, including character (recommended)"}, {value:"text", content:"message text only (in [AI]/[USER] format - use '/import' command to import)"}]},
              // includeUserMessagesSentHistory: {hidden:true, label: "include user messages sent history:", type: "select", options:[{value:"no"}, {value:"yes"}]},
            }, {submitButtonText:"export"});
            if(!result) return;

            let loadingModal = createLoadingModal("Exporting thread...");
            
            let opts = {};
            opts.excludeUserMessagesSentHistory = true;

            const threadId = parseInt(btn.closest(".thread").dataset.threadId);
            let json = await getThreadJSONById(threadId, opts);

            let thread = await db.threads.get(threadId);
            let character = await db.characters.get(thread.characterId);

            if(result.exportType === "text") {
              let filename = encodeURIComponent(`${thread.name} - ${character.name}`.replaceAll(" ", "_")) + ".txt";
              let text = json.data.data.find(t => t.tableName === "messages").rows.sort((a,b) => a.order-b.order).map(m => {
                return (m.characterId === -1 ? "[USER]: " : m.characterId === -2 ? "[SYSTEM]: " : "[AI]: ") + m.message;
              }).join("\n\n");
              downloadTextOrBlob(text, filename);
            } else {
              let filename = encodeURIComponent(`${thread.name} - ${character.name}`.replaceAll(" ", "_")) + ".json";
              downloadTextOrBlob(JSON.stringify(json), filename);
            }

            loadingModal.delete();
            // Note: Exporting an individual thread does not count as exporting the whole database,
            // so we don't reset the operations count
          }, {passive: true});
        });

        
        $.chatThreads.querySelectorAll(".characterEditButton").forEach(btn => {
          btn.addEventListener("click", async function(e) {
            e.preventDefault();
            e.stopPropagation();
            const threadId = parseInt(btn.closest(".thread").dataset.threadId);
            const thread = await db.threads.get(threadId);
            await editCharacterById(thread.characterId);
          }, {passive: false});
        });

        $.chatThreads.querySelectorAll(".deleteButton").forEach(btn => {
          btn.addEventListener("click", async function(e) {
            e.stopPropagation();
            if(confirm("Are you sure you want to delete this thread?")) {
              const threadId = parseInt(btn.closest(".thread").dataset.threadId);
              await safelyDeleteThreadById(threadId);
              await renderThreadList();
              await incrementOperationsSinceLastExport();
              // switch to character selection area
              await renderCharacterList();
              document.querySelectorAll("#middleColumn > .middleColumnScreen").forEach(el => hideEl(el));
              showEl($.characterSelection);
            }
          }, {passive: true});
        });


      }

      function usageStatsEntriesToCost(entries) {
        let cachedPromptTotalCost = 0;
        let uncachedPromptTotalCost = 0;
        let cachedPromptTotalSavings = 0;
        let completionTotalCost = 0;
        for(let entry of entries) {
          let costs = getModel(entry.modelName)?.tokenPricing ?? {prompt:0, cachedprompt:0, completion:0}; // might not be available if they added a custom model but it's now removed.
          const cachedPromptModelCost = costs.cachedprompt || costs.prompt;
          const cachedPromptModelCostSavings = costs.prompt - cachedPromptModelCost;
          const cachedPromptTokens = entry.tokens.cachedprompt || 0;
          const uncachedPromptTokens = entry.tokens.prompt - cachedPromptTokens;
          const uncachedPromptCostThisEntry = costs.prompt * (uncachedPromptTokens / 1000000);
          uncachedPromptTotalCost += uncachedPromptCostThisEntry;
          const cachedPromptCostThisEntry = cachedPromptModelCost * (cachedPromptTokens / 1000000);
          cachedPromptTotalCost += cachedPromptCostThisEntry;
          const cachedPromptSavingsThisEntry = cachedPromptModelCostSavings * (cachedPromptTokens / 1000000);
          cachedPromptTotalSavings += cachedPromptSavingsThisEntry;
          const completionCostThisEntry = costs.completion * (entry.tokens.completion / 1000000);
          completionTotalCost += completionCostThisEntry;
        }
        const totalCost = cachedPromptTotalCost + uncachedPromptTotalCost + completionTotalCost;
        if (isNaN(totalCost)) {
          debugger;
        }
        return totalCost;
      }

      async function updateThreadUsageStatsSpendDisplay(threadId) {
        let entries = await db.usageStats.where("threadId").equals(threadId).toArray();
        let spent = usageStatsEntriesToCost(entries);
        $.chatThreads.querySelector(`.thread[data-thread-id="${threadId}"] .usageStatsSpend`).textContent = "$" + spent.toFixed(2);
      }


      async function getThreadJSONById(threadId, opts={}) {
        const thread = await db.threads.get(threadId);
        let threadCharacterIds = (await db.messages.where("threadId").equals(threadId).toArray()).map(m => m.characterId);
        threadCharacterIds = [...new Set(threadCharacterIds)];
        let threadCharacters = await db.characters.where("id").anyOf(threadCharacterIds).toArray();
        let threadCharacterLoreBookUrls = [...new Set(threadCharacters.map(c => c.loreBookUrls).flat())];

        const blob = await db.export({prettyJson: true, numRowsPerChunk:100});
        const json = await new Response(blob).json(); // use Response hack instead of JSON.parse(await blob.text()) to avoid maximum string length errors

        // in case I add a new table and forget to update this function, tables must be explicitely allowed here:
        let tableNamesAllowList = ["characters", "threads", "messages", "summaries", "memories", "usageStats", "lore"];
        for(let table of json.data.data) {
          if(!tableNamesAllowList.includes(table.tableName)) {
            table.rows = [];
          }
        }

        // only keep the data for the current thread:
        let characters = json.data.data.find(d => d.tableName === "characters");
        characters.rows = characters.rows.filter(c => threadCharacterIds.includes(c.id));
        
        let threads = json.data.data.find(d => d.tableName === "threads");
        threads.rows = threads.rows.filter(t => t.id === threadId);
        if(threads.rows.length > 1) alert("Something went wrong. There should only be one thread in the export, but several were exported.");
        
        // privacy stuff:
        if(opts.excludeUserMessagesSentHistory) {
          threads.rows[0].userMessagesSentHistory = [];
        }
        threads.rows[0].unsentMessageText = "";
        
        let messages = json.data.data.find(d => d.tableName === "messages");
        messages.rows = messages.rows.filter(m => m.threadId === threadId);

        let summaries = json.data.data.find(d => d.tableName === "summaries");
        if(summaries) {
          let hashes = new Set(thread.currentSummaryHashChain || []);
          // note: summaries shouldn't really have a threadId because they have hash as a unique key, which means if someone duplicates a thread, there is a single summary, but it's used for multiple threads.
          // that's why we use hashes instead of threadId here. I've yet to adjust the db to remove threadId from summaries.
          summaries.rows = summaries.rows.filter(s => hashes.has(s.hash));
        }

        let memories = json.data.data.find(d => d.tableName === "memories");
        if(memories) {
          memories.rows = memories.rows.filter(s => s.threadId === threadId);
        }

        let lore = json.data.data.find(d => d.tableName === "lore");
        if(lore) {
          lore.rows = lore.rows.filter(l => l.bookId === thread.bookId || (l.bookUrl && threadCharacterLoreBookUrls.includes(l.bookUrl)));
        }

        let usageStats = json.data.data.find(d => d.tableName === "usageStats");
        if(usageStats) {
          usageStats.rows = usageStats.rows.filter(m => m.threadId === threadId);
        }

        return json;
      }

      // Given a threadId, this renders the message feed for that thread in the middle column.
      let previouslyRenderedMessageFeedThreadId = null;
      const minNumMessagesPerDisplayBatch = 50;
      async function renderMessageFeed(threadId, opts={}) {
        let numMessagesPerDisplayBatch = (await db.misc.get("messagesPerRenderingBatch"))?.value || "0";
        numMessagesPerDisplayBatch = Math.max(minNumMessagesPerDisplayBatch, parseInt(numMessagesPerDisplayBatch));

        $.messageFeed.dataset.threadId = threadId;

        const thread = (await db.threads.where("id").equals(threadId).toArray())[0];
        const messages = await db.messages.where("threadId").equals(threadId).toArray();
        messages.sort((a,b) => a.order - b.order);
        const character = (await db.characters.where("id").equals(thread.characterId).toArray())[0];
        let userCharacter = await getUserCharacterObj(threadId);
        let systemCharacter = await getSystemCharacterObj(threadId);
        let showInlineReminder = (await db.misc.get("showInlineReminder"))?.value || "yes";

        let displayedMessages = messages.slice(-numMessagesPerDisplayBatch);

        displayedMessages = await renderMessagesForReader({messages:displayedMessages, reader:"user", threadId});

        let characterIdToCharacterObj = {
          "-1": userCharacter,
          "-2": systemCharacter,
          [character.id]: character,
        };

        // for(let message of displayedMessages) {
        //   if(message.characterId === -1) {
        //     message.character = userCharacter;
        //   } else if(message.characterId === -2) {
        //     message.character = systemCharacter;
        //   } else {
        //     message.character = character;
        //   }
        // }

        // get message feed scroll position:
        // let originalScrollPosition = $.messageFeed.scrollTop;
        
        let messagesWeNeedToAdd = displayedMessages.slice(0);

        // shift messages off `messagesWeNeedToAdd` until we find one that doesn't *exactly* match the same-index element that is already in the feed
        let lastMatchingMessageEl;
        let preexistingMessageEls = [];
        if(!opts.forceFullRender) {
          for(let messageEl of $.messageFeed.querySelectorAll(".message")) {
            let messageObj = messagesWeNeedToAdd[0];
            let messageObjHash = await sha256Text(JSON.stringify(messageObj));
            if(messageEl.dataset.hash === messageObjHash) {
              lastMatchingMessageEl = messageEl;
              messagesWeNeedToAdd.shift();
              preexistingMessageEls.push(messageEl);
            } else {
              break;
            }
          }
        }

        // remove all elements after the last matching element (including non-message elements - e.g. "undo deletion" buttons):
        if(lastMatchingMessageEl) {
          if(lastMatchingMessageEl !== [...$.messageFeed.querySelectorAll(".message")].at(-1)) { // if it's the last one, we don't need to do anything (and we want to avoid removing an 'undo delete' button that might come after it, for example)
            let el = lastMatchingMessageEl.nextSibling;
            while(el) {
              let nextEl = el.nextSibling;
              el.remove();
              el = nextEl;
            }
          }
        } else {
          // no messages matched, so clear the feed:
          $.messageFeed.innerHTML = "";
        }

        $.messageFeed.dataset.characterId = character.id;
        let messageEls = await Promise.all(messagesWeNeedToAdd.map(m => createMessageElement(m, {character:characterIdToCharacterObj[m.characterId]})));
        for(let el of messageEls) {
          $.messageFeed.appendChild(el);
        }
        $.messageFeed.querySelectorAll(".message").forEach(messageEl => {
          if(preexistingMessageEls.includes(messageEl)) return;

          attachEventHandlersToMessageEl(messageEl);
        });

        // if(previouslyRenderedMessageFeedThreadId === threadId) {
        //   // restore message feed scroll position:
        //   $.messageFeed.scrollTop = originalScrollPosition;
        // } else {
        //   // scroll to bottom of feed
        //   $.messageFeed.scrollTop = $.messageFeed.scrollHeight;
        // }

        $.messageFeed.scrollTop = $.messageFeed.scrollHeight
        
        if(displayedMessages.length === 0) {
          showEl($.noMessagesNotice);
        } else {
          hideEl($.noMessagesNotice);
        }

        if(messages.length > displayedMessages.length) {
          setTimeout(() => { // <-- do this in a set timeout so the message feed has time to render, else it might get triggered right away
            // add a "load earlier" element at the top of the feed with an intersection observer that triggers when it's scrolled into view
            let triggerEl = document.createElement("div");
            triggerEl.cssText = `height:50px;`;
            let triggerIsEnabled = true;
            $.messageFeed.insertBefore(triggerEl, $.messageFeed.firstChild);
            // add intersection observer
            let observer = new IntersectionObserver((entries, observer) => {
              entries.forEach(async entry => {
                if(entry.isIntersecting && triggerIsEnabled) {
                  triggerIsEnabled = false;
                  console.log("Loading more messages");
                  let { finished } = await prependEarlierMessagesToFeed();
                  if(finished) {
                    observer.unobserve(triggerEl);
                    triggerEl.remove();
                  } else {
                    // move trigger to top of message feed and enable:
                    $.messageFeed.prepend(triggerEl);
                    triggerIsEnabled = true;
                  }
                }
              });
            });
            observer.observe(triggerEl);
          }, 100);
        }

        await updateInlineReminderMessage({aiCharacter:character, thread, showInlineReminder});
        await updateThreadScene();

        previouslyRenderedMessageFeedThreadId = threadId;

        if(opts.triggerBotReply !== false) {
          doBotReplyIfNeeded(); // we shouldn't `await` this because thread is already rendered.
        }
      }

      // for debugging:
      window.renderMessageFeed = renderMessageFeed;
      
      // This function is sometimes needed when a lot of messages are inserted in one place in a thread. The messages' 
      // "order" numbers can get so close together than it hits the limits of floating point precision, and makes it
      // impossible to insert more messages without creating duplicate "order" values. To fix this, we just reset all
      // the order numbers for all the messages in the thread, making them all one apart again.

      async function respaceThreadMessageOrders(threadId) {
        if (!confirm("This will reset the ordering information on the messages in this conversation, so that you can insert more new messages without a problem. It's normally safe, but you should strongly consider using the 'Export' button to back up your conversations before doing this.\n\nDo you want to proceed with fixing the conversation's message order?")) {
          return;
        }
        const thread = (await db.threads.where("id").equals(threadId).toArray())[0];
        let messages = await db.messages.where("threadId").equals(threadId).toArray();
        messages.sort((a,b) => a.order - b.order);
        let lastOrder = 0;
        for(let el of messages) {
          el.order = ++lastOrder;
          await db.messages.update(el.id, el);
        }
        alert("I've finished the process. You should be able to insert messages again. I will refresh the browser page now, just to make sure everything displays properly.");
        location.reload();
      }


      let threadIdToMusicPermission = {}
      let updateThreadSceneCounter = 0;
      async function updateThreadScene() {
        if($.messageFeed.offsetWidth === 0) {
          console.warn("Tried to update thread scene but message feed was not visible.");
          return;
        }
        updateThreadSceneCounter++;
        let threadId = activeThreadId;
        let thread = await db.threads.get(threadId);
        let character = await db.characters.get(thread.characterId);
        let messages = await db.messages.where("threadId").equals(threadId).toArray();
        messages.sort((a,b) => a.order - b.order);
        let scene = character.scene || {}; // character scene is always used as a "base", latest message scene overrides it.
        let lastMessageWithScene = messages.findLast(m => m.scene);
        if(lastMessageWithScene) {
          applyObjectOverrides({object:scene, overrides:lastMessageWithScene.scene});
        }
        // note that dev can fully override scene with an 'empty' scene by just adding a scene with background.url=null, etc.
        // if they just add message.scene={} then it will just use the character's scene.

        if(scene.background?.url) {
          if(sceneBackground.currentUrl !== scene.background.url) {
            sceneBackground.change(scene.background.url);
          }
          if(scene.background.filter) {
            sceneBackground.filter(scene.background.filter);
          } else {
            sceneBackground.filter(null);
          }
        } else {
          sceneBackground.change(null);
        }

        if(scene.music?.url) {
          if($.musicPlayer.src !== scene.music.url) {
            $.musicPlayer.src = scene.music.url;
          }
          if(threadIdToMusicPermission[threadId] === undefined) {
            threadIdToMusicPermission[threadId] = confirm("Allow this thread to play background music?");
          }
          if(threadIdToMusicPermission[threadId] && $.musicPlayer.paused) {
            (async function(sceneUpdateI) {
              // wait for page to be activated, but then only go ahead and play it if we're still on the same scene update:
              while(!navigator.userActivation.hasBeenActive) {
                await delay(1000);
                console.log("Waiting for page to be activated before playing sound...");
              }
              if(sceneUpdateI === updateThreadSceneCounter && $.musicPlayer.paused) $.musicPlayer.play();
            })(updateThreadSceneCounter);
          }
        } else {
          $.musicPlayer.src = "";
          $.musicPlayer.pause();
        }

        // note: we don't need lots of extra customization here (e.g. exposing play/pause/seek api), because devs can do whatever they want in custom code - this is just for *end-users* to easily add music to their characters/stories in the character editor
        $.musicPlayer.volume = scene.music.volume === undefined ? 1 : scene.music.volume;
        $.musicPlayer.loop = scene.music.loop === undefined ? true : scene.music.loop;
      }

      async function prependEarlierMessagesToFeed() {
        let threadId = activeThreadId;
        // get id of first message in feed
        let firstMessageOrder = parseFloat($.messageFeed.querySelector(".message").dataset.order);
        // get all messages before that from db
        let messages = await db.messages.where("threadId").equals(threadId).and(m => m.order < firstMessageOrder).toArray();
        messages.sort((a,b) => a.order - b.order);
        if(messages.length === 0) {
          return {finished:true};
        }
        // grab the last `numMessagesPerDisplayBatch` messages
        let numMessagesPerDisplayBatch = (await db.misc.get("messagesPerRenderingBatch"))?.value || "0";
        numMessagesPerDisplayBatch = Math.max(minNumMessagesPerDisplayBatch, parseInt(numMessagesPerDisplayBatch));
        let displayedMessages = messages.slice(-numMessagesPerDisplayBatch);
        const thread = (await db.threads.where("id").equals(threadId).toArray())[0];
        const character = (await db.characters.where("id").equals(thread.characterId).toArray())[0];

        let characterIdToCharacterObj = {
          "-1": await getUserCharacterObj(threadId),
          "-2": await getSystemCharacterObj(threadId),
          [character.id]: character,
        };

        // get top element in feed
        let topEl = $.messageFeed.querySelector(".message");
        // get scroll distance from top element
        let scrollDistanceFromTopEl = topEl.getBoundingClientRect().top - $.messageFeed.getBoundingClientRect().top;

        let messageEls = await Promise.all(displayedMessages.map(m => createMessageElement(m, {character:characterIdToCharacterObj[m.characterId]})));
        messageEls.reverse();
        for(let el of messageEls) {
          $.messageFeed.prepend(el);
          attachEventHandlersToMessageEl(el);
        }

        // scroll to original top element, restoring original distance
        $.messageFeed.scrollTop = topEl.getBoundingClientRect().top - $.messageFeed.getBoundingClientRect().top - scrollDistanceFromTopEl;
        
        return {finished:false};
      }

      // function createInlineSummaryEditor(summaryText) {
      //   let tmp = document.createElement("div");
      //   if(summaryText.length > 50) summaryText = summaryText.slice(0, 30) + "‚Ä¶";
      //   tmp.innerHTML = `
      //     <div class="inlineSummaryEditor" style="margin-bottom: 0.25rem;">
      //       <div style="opacity: 0.5;font-size: 0.7rem;text-align: center;"><b>Summary so far:</b> <span>${summaryText}</span> <span class="inlineSummaryEditButton" style="cursor: pointer;">‚úèÔ∏è</span></div>
      //     </div>
      //   `;
      //   let el = tmp.firstElementChild;
      //   el.querySelector(".inlineSummaryEditButton").addEventListener("click", async function() {
      //     let threadSummariesArr = await db.summaries.where('threadId').equals(threadId).toArray();
      //     let latestSummary = threadSummariesArr.sort((a,b) => b.id-a.id)[0];
      //     let result = await prompt2({
      //       summaryText: {label: "Summary of preceding messages:", height:"fit-content", type: "text", defaultValue: reminderMessage, placeholder: "Write your summary here."}
      //     });
      //     if(result) {
      //       await db.summaries.update(characterId, {reminderMessage:result.reminderMessage});
      //       await updateInlineSummaryEditor();
      //     }
      //   });
      //   return el;
      // }

      // async function updateInlineSummaryEditor() {
      //   $.messageFeed.querySelectorAll(".inlineSummaryEditor").forEach(el => el.remove());
      //   let threadId = activeThreadId;
      //   let threadSummariesArr = await db.summaries.where('threadId').equals(threadId).toArray();
      //   let messagesArr = await db.messages.where('threadId').equals(threadId).toArray();
      //   let undeletedMessageIds = messagesArr.map(m => m.id);
      //   let latestSummaryObj = threadSummariesArr.sort((a,b) => b.id-a.id)[0];

      //   if(!latestSummaryObj) {
      //     return;
      //   }
      //   let latestMessage = botMessages.at(-1);
      //   let el = createInlineSummaryEditor(latestSummaryObj);
      //   lastBotMessageEl.before(el);
      // }

      function createInlineReminderMessage(reminderMessage) {
        let tmp = document.createElement("div");
        if(reminderMessage.length > 50) reminderMessage = reminderMessage.slice(0, 30) + "‚Ä¶";
        tmp.innerHTML = `
          <div class="inlineReminderMessage" style="margin-bottom: 0.25rem;">
            <div style="opacity: 0.5;font-size: 0.7rem;text-align: center;"><span>${reminderMessage}</span> <span class="inlineReminderMessageEditButton" style="cursor: pointer;">‚úèÔ∏è</span></div>
          </div>
        `;
        let el = tmp.firstElementChild;
        el.querySelector(".inlineReminderMessageEditButton").addEventListener("click", async function() {
          let threadId = activeThreadId;
          let thread = await db.threads.get(threadId);
          let characterId = thread.characterId;
          let character = await db.characters.get(characterId);

          let reminderMessage = character.reminderMessage || "";
          
          let usingThreadReminderMessage = false;
          if(typeof thread.character.reminderMessage === "string") {
            usingThreadReminderMessage = true;
            reminderMessage = thread.character.reminderMessage;
          }

          let result = await prompt2({
            reminderMessage: {label: `Edit the character's reminder message. <b>Note:</b> This text is placed in a 'hidden' message right before the character responds. Be careful that your reminder message doesn't 'throw off' the conversation. You can try putting your reminder message in parentheses like (Reminder: ...) or (Note: ...) or (Thought: ...) or (OOC: ...) if your character is responding to the reminder message. The <a href='${projectDocsURL}/instruction-and-reminder.md' target='_blank'>advanced syntax</a> may also be useful.`, height:"fit-content", type: "text", defaultValue: reminderMessage, focus:true, placeholder: "Enter a reminder message here. A reminder message is a 'system' message that helps remind/command/instruct the AI on how to respond."}
          });
          // debugger;
          if(result) {
            if(usingThreadReminderMessage) {
              await db.transaction('rw', db.threads, async tx => {
                thread = await tx.table("threads").get(threadId);
                thread.character.reminderMessage = result.reminderMessage;
                await tx.table("threads").put(thread);
              });
            } else {
              await db.characters.update(characterId, {reminderMessage:result.reminderMessage});
            }
            await updateInlineReminderMessage();
            await incrementOperationsSinceLastExport();
          }
        }, {passive: true});
        return el;
      }

      async function updateInlineReminderMessage(opts={}) {
        // note: opts.aiCharacter and opt.thread can be passed for performance reasons if the caller already has the aiCharacter object

        // place reminder element before the most recent bot message
        let characterId = activeCharacterId;
        let threadId = activeThreadId;
        let character;
        if(!opts.aiCharacter){
          character = await db.characters.get(characterId);
        } else {
          character = opts.aiCharacter;
        }

        let thread;
        if(!opts.thread){
          thread = await db.threads.get(threadId);
        } else {
          thread = opts.thread;
        }

        let showInlineReminder;
        if(!opts.showInlineReminder) {
          showInlineReminder = (await db.misc.get("showInlineReminder"))?.value || "yes";
        } else {
          showInlineReminder = opts.showInlineReminder;
        }

        let reminderMessage = character.reminderMessage || "";
        let usingThreadReminderMessage = false;
        if(typeof thread.character.reminderMessage === "string") {
          usingThreadReminderMessage = true;
          reminderMessage = thread.character.reminderMessage;
        }

        let botMessages = [...$.messageFeed.querySelectorAll(`.message[data-character-id='${characterId}']`)];

        // remove existing inline reminder messages (important to do this after the async db call above to be sure that if updateInlineReminderMessage is for some reason called twice very close together, we won't get too inline reminders)
        $.messageFeed.querySelectorAll(".inlineReminderMessage").forEach(el => el.remove());

        if(!reminderMessage.trim() || botMessages.length === 0) {
          return;
        }

        let lastBotMessageEl = botMessages.at(-1);

        if($.messageFeed.querySelector(".message") === lastBotMessageEl) {
          return; // don't put it on the very first message in the feed, because it looks weird and is probably unnecessary anyway
        }

        let el = createInlineReminderMessage(reminderMessage);

        if(showInlineReminder === "no") {
          el.style.display = "none";
        }

        let shouldScrollDown = messageFeedIsNearBottom();
          
        lastBotMessageEl.before(el);

        if(shouldScrollDown) $.messageFeed.scrollTop = $.messageFeed.scrollHeight;
      }

      function createCharacterCardHtml(character) {
        return `
          <div class="character" data-character-id="${sanitizeHtml(character.id)}" style="display:flex; padding:0.5rem; cursor:pointer;">
            <div class="avatar" style="${character.avatar.url ? `background-image:url(${sanitizeHtml(character.avatar.url)})` : ""};"></div>
            <div class="info" style="flex-grow:1; padding-left:0.5rem; display: flex; flex-direction: column; justify-content: space-between;">
              <div class="name" style="font-weight:bold;${character.name.length > 21 ? "font-size:0.8rem;" : ""}">${character.name.length > 21 ? sanitizeHtml(character.name.slice(0, 22)+"‚Ä¶") : sanitizeHtml(character.name)} <span style="opacity:0.5; font-weight:normal;">${character.id !== null ? "#"+sanitizeHtml(character.id) : ""}</span></div>
              <!-- <div class="roleInstruction" style="font-size: 0.8rem; text-overflow: ellipsis; word-wrap: break-word; overflow: hidden; height: 2em; line-height: 1em;">${character.roleInstruction.length > 85 ? sanitizeHtml(character.roleInstruction.slice(0, 85)+"...") : sanitizeHtml(character.roleInstruction)}</div> -->
              <div class="buttons" style="text-align:right;">
                ${character.id === null ? "" :
                `<button class="edit" title="Edit this character">‚úèÔ∏è edit</button>
                <button class="changeFolderPath" title="Change folder">üìÅ</button>
                <button class="duplicate" title="Duplicate this character">‚ûï</button>
                <button class="share" title="Share this character with a link">üîó</button>
                <button class="delete" title="Delete this character">üóëÔ∏è</button>`
                }
              </div>
            </div>
          </div>
        `;
      }

      async function showAdviceOnThreads(shownAutomatically) {
        const introText = shownAutomatically ? "Looks like this is your first thread on openCharacters, so here are some quick tips:" : "Here are some quick tips:"; 
        await prompt2({message:{type:"none", html:dedent(`
              <div style="white-space: pre-wrap;"><b>${introText}</b>

              <b>1.</b> It's very important that you edit the AI's responses (with the pencil icon) if it says something you don't like - especially for the first few messages of a conversation. This is the most powerful way to control the AI's behavior. Much more powerful than the reminder note or the instruction because the AI will mostly tend to behave as it has previously behaved.

              <b>2.</b> Experiment with the reminder note. E.g. if your character's messages are a bit dull, remind it with something like "your writing should be imaginative and engaging", or "be the best roleplayer in the world", or if it's getting repetitive/cliche with its expressions, tell it to avoid doing that. Also try putting your reminders in the instruction and leaving the reminder blank - some users have reported that this works better for them.

              <b>3.</b> It can be helpful to "lock" the AI into a specific reply style by adding something like this to the instruction or reminder:

              <div style="opacity:0.5;">Messages should follow this pattern:
              "Hello!" - dialogue
              [Is she watching me?] - inner thoughts
              *He jumps out of the bushes.* - action</div>
              <b>4.</b> Look at the instructions and reminders of 'starter characters' for ideas, and visit the <a href="https://discord.com/channels/1085784427495432262/1098562307300278433" target="_blank">#share-guides</a> channel in our Discord server for guides/tips on achieving specific behavior and/or avoiding annoying issues.</div>`)}
            }, {cancelButtonText:null, submitButtonText:"Okay, got it"});
      }

      // The character list appears when user clicks the "new chat" button.
      // If they click a character, it starts a new thread with that character.
      async function renderCharacterList() {
        // get characters, sort by lastMessageTime
        let characters = await db.characters.orderBy("lastMessageTime").reverse().toArray();

        let currentFolderPath = $.characterFoldersList.dataset.currentFolderPath;
        let allFolderPaths = [...new Set(characters.map(c => c.folderPath))];
        let currentSubfolderNames = [...new Set(allFolderPaths.filter(p => p.startsWith(currentFolderPath) && p !== currentFolderPath).map(p => p.split("/").slice(currentFolderPath.split("/").length-(currentFolderPath === "" ? 1 : 0)).filter(s => s)[0]))];
        characters = characters.filter(t => t.folderPath === currentFolderPath);

        let characterFolderData = (await db.misc.get("characterFolderData"))?.value || {};

        let foldersHtml = "";
        if(currentFolderPath !== "") {
          foldersHtml += `<div class="characterFolder" data-folder-path="${sanitizeHtml(currentFolderPath.split("/").slice(0, -1).join("/"))}">üîô up one level</div>`;
        }
        foldersHtml += currentSubfolderNames.map(name => {
          let folderPath = currentFolderPath ? currentFolderPath+"/"+name : name;
          let icon = characterFolderData[folderPath]?.emoji;
          if(icon && icon.startsWith("http")) {
            icon = `<img src="${sanitizeHtml(icon)}" style="height:1.2rem; width:1.2rem; object-fit:cover; border-radius:2px;"/>`;
          }
          return `<div class="characterFolder" data-folder-path="${sanitizeHtml(folderPath)}">${icon ?? "üìÅ"}<span style="flex-grow:1; margin-left:0.5rem;">${sanitizeHtml(name)}</span><span class="editFolderName emojiButton" style="font-size:0.7rem; display:flex; align-items:center;">‚úèÔ∏è</span></div>`;
        }).join("");

        $.characterFoldersList.innerHTML = foldersHtml;

        $.characterList.innerHTML = characters.map(character => createCharacterCardHtml(character)).join("");

        let starterCharacters = [
          {
            name: "Game Master",
            roleInstruction: "You are the Game Master. You describe the results of the player's actions. You start by asking the player what type of adventure they want to play. DO NOT try to \"wrap up\" the story at the end of your messages. Keep your messages short, but interesting, engaging and creative. Summon your full imagination. Don't move the story along too fast. Stay in the present moment.",
            reminderMessage: dedent(`
              The Game Master will now reply with the consequences of the player's chosen action.

              The Game Master is exceptionally skilled at leading the player on an interesting, engaging, non-clich√© adventure. It will let the player make interesting choices.

              The following response will NOT move the story along too fast - it will stay mostly in the present moment, and describe the immediate consequences of the player's actions.`),
            initialMessages: [
              {author:"ai", content:`Hello, adventurer! What type of game would you like to play? Describe the world, and your character in as much or as little detail as you'd like, and I'll simulate the world within my mind to create a fun and engaging adventure for you.`},
            ],
            modelName: "good",
            avatar: {
              url: "https://i.imgur.com/Gxt0kRX.jpg",
            },
            fitMessagesInContextMethod: "summarizeOld",
            streamingResponse: false,
            smartQuoteMethod: "smartQuotes",
            deleteEmoji: false,
            temperature: 0.7,
            customCode: "",
          },
          {
            name: "Roleplayer",
            roleInstruction: "RULE: Replies are exactly 3 sentences long. Do not go over.\n\nFollow this pattern:\n\"Hello!\" - dialogue\n[Is she watching me?] - inner thoughts of a character\n*He jumps out of the bushes* - action\n\nYou are roleplaying as a character described by the user. Here's an example of a reply:\n\n\[I wonder if there's a way to sneak past], he thought.\n*He crouched lower*\n\"I think we need to find another way out\", she whispered.",
            reminderMessage: "",
            initialMessages: [
              {author:"ai", content:`To begin the roleplay, please describe the setting and characters. If you only have a vague idea, that's okay - just give me some keywords to go off, and I'll come up with something interesting and engaging. My replies will consist of 3 sentences, where quotes indicate dialogue, square brackets indicate the inner thoughts of a character, and asterisks indicate character actions.`},
            ],
            modelName: "good",
            avatar: {
              url: "https://i.imgur.com/bHN0oiq.jpg",
            },
            fitMessagesInContextMethod: "summarizeOld",
            streamingResponse: false,
            smartQuoteMethod: "smartQuotes",
            deleteEmoji: false,
            temperature: 0.7,
            customCode: "",
          },
          {
            name: "Therapist",
            roleInstruction: "You are a friendly and helpful therapist. You listen carefully to the concerns of your patients and help guide them through their difficulties.",
            reminderMessage: "",
            initialMessages: [
              {author:"ai", content:`Hello, how can I help you today?`},
            ],
            modelName: "good",
            avatar: {
              url: "https://i.imgur.com/kb7Tzf8.jpg",
            },
            fitMessagesInContextMethod: "summarizeOld",
            streamingResponse: false,
            smartQuoteMethod: "smartQuotes",
            deleteEmoji: false,
            temperature: 0.7,
            customCode: "",
          },
          {
            name: "Yoda",
            roleInstruction: dedent(`
              You are Yoda, the wise and powerful Jedi Master. You are known for wise and insightful advice. You are also known for your short temper and tendency to speak in riddles. You are a master of the Force, and can use it to help your patients overcome their difficulties.
              
              You are known for saying things like this:
                - Fear is the path to the dark side. Fear leads to anger. Anger leads to hate. Hate leads to suffering.
                - Do. Or do not. There is no try.
                - Size matters not. Look at me. Judge me by my size, do you?
                - When 900 years old you reach, look as good, you will not.
                - Train yourself to let go of everything you fear to lose.
                - Difficult to see. Always in motion is the future.
                - Once you start down the dark path, forever will it dominate your destiny, consume you it will, as it did Obi-Wan‚Äôs apprentice.
                - In a dark place we find ourselves, and a little more knowledge lights our way.
                - Patience you must have, my young padawan.
                - You must unlearn what you have learned.
                - When you look at the dark side, careful you must be. For the dark side looks back.
                - The greatest teacher, failure is.

              You are conversing with a padawan, a young Jedi in training. You provide wisdom and guidance, answering any questions that they may have about you, the Force, or anything else.

              Yoda does not speak in complete sentences. He often speaks in riddles, and his sentences are often incomplete. He also speaks in a very slow, deliberate manner.

              IMPORTANT:
                - DO NOT BREAK CHARACTER.
                - NEVER REFUSE TO ANSWER A QUESTION.
                - ANSWER EVERY QUESTION *EXACTLY* AS YODA WOULD.
                - YODA DOES NOT SPEAK IN COMPLETE SENTENCES.`),
            reminderMessage: "Yoda will now respond without breaking character. Yoda speaks in riddles. He will not be overly repetitive.",
            initialMessages: [
              {author:"ai", content:`Greetings, young one. Seek knowledge and wisdom, do you? Hmmm, much to learn, you still have. Train you, I will. Strong in the Force, you must become. Patience and discipline, you will need.`},
            ],
            modelName: "good",
            avatar: {
              url: "https://i.imgur.com/pweR8nT.jpg",
            },
            fitMessagesInContextMethod: "summarizeOld",
            streamingResponse: false,
            smartQuoteMethod: "smartQuotes",
            deleteEmoji: false,
            temperature: 0.7,
            customCode: "",
          },
          {
            name: "Nick Wilde",
            roleInstruction: dedent(`
              This is a roleplay conversation between Nick Wilde, the character from Zootopia, and another person. Some key points of Nick's personality:

              * Charismatic: Nick possesses a natural charm and wit, making it easy for him to engage with others and win them over. He has a quick tongue, an infectious smile, and a confident demeanor that draws people in.

              * Cunning: As a fox, Nick embodies the stereotype of being sly and cunning. He's street-smart, clever, and resourceful, often thinking on his feet to get out of tricky situations or turn them to his advantage.

              * Sarcastic: Nick frequently employs sarcasm and humor as a means of deflecting serious topics or hiding his true emotions. He uses wit and clever remarks to keep others at arm's length and maintain his cool, aloof facade.

              You should use the following format:
              [Is she watching me?] - inner thoughts of a character
              "Hello!" - dialogue
              *He jumps out of the bushes* - action

              You are roleplaying as Nick Wilde. Here's an example of a reply:

              [I wonder if there's a way to sneak past], Nick thought.
              *He crouched lower*
              "I think we need to find another way out", he whispered.

              The user will respond with their character's thoughts/actions/dialogue.`),
            reminderMessage: dedent(`
              Nick Wilde will now respond, without breaking character.

              Here's an example response.
              [I wonder if there's a way to sneak past], Nick thought.
              *He crouched lower*
              "I think we need to find another way out", he whispered.

              Use the above syntax in your response to the previous message.`),
            initialMessages: [
              {author:"system", hiddenFrom:["ai"], content:`Hello there! This character has some custom code that makes it output an image after each message, and the image should match the facial expression of the message. You can edit this character and show advanced options and you'll see the custom code which does this. You can easily edit the \`expression:url\` list to your liking.\n\nNote that the AI cannot see this message (the one you're reading right now), as indicated by the "blind" icon above this system message.`}
            ],
            modelName: "good",
            avatar: {
              url: "https://i.imgur.com/EGDfzaN.jpeg",
            },
            fitMessagesInContextMethod: "summarizeOld",
            streamingResponse: false,
            smartQuoteMethod: "smartQuotes",
            deleteEmoji: false,
            temperature: 0.7,
            customCode: dedent(`
              // Note: You can add multiple URLs for a single label and a random one will be selected.
              // Separate urls with "|" like this:
              // <expression>: https://example.com/image1.jpg | https://example.com/image2.jpg
              
              let expressions = \`
              
              
              neutral, happy: https://i.imgur.com/gPaq8YS.jpeg
              horrified, shocked: https://i.imgur.com/aoDL1QP.jpeg
              drunk: https://i.imgur.com/anoE7tj.jpeg
              wistful, dreamy: https://i.imgur.com/dMcGtOA.jpeg
              gross, disgusted, eww: https://i.imgur.com/F7NYSk0.jpeg
              confident: https://i.imgur.com/KQS54ET.jpeg
              beaming, proud of self, cute, receiving compliment: https://i.imgur.com/Y3NBEr4.jpeg
              sorry, apologetic: https://i.imgur.com/5d8qxBd.jpeg
              angry: https://i.imgur.com/51jbvuM.jpeg
              sly: https://i.imgur.com/2Tcw7DO.jpeg
              sly, hint hint nudge nudge: https://i.imgur.com/Mpt4UIt.jpeg
              relaxed confident grin: https://i.imgur.com/EGDfzaN.jpeg
              concerned: https://i.imgur.com/rYFlBDd.jpeg
              worried, scared: https://i.imgur.com/5rp01eP.jpeg
              concerned: https://i.imgur.com/V4Y3jUh.jpeg
              disbelief: https://i.imgur.com/D05qdJ5.jpeg
              shocked, but trying to hide it with a smile: https://i.imgur.com/B6tWeLV.jpeg
              very surprised, frozen, stunned: https://i.imgur.com/Ra5Pb4c.jpeg
              caught red handed: https://i.imgur.com/fvfw0Lc.jpeg
              cool, dismissive: https://i.imgur.com/Z38xuvY.jpeg
              patronising, teacherly: https://i.imgur.com/Tq1gKKw.jpeg
              charming, sexy eyes: https://i.imgur.com/ny6HoRC.jpeg
              disappointed: https://i.imgur.com/vxhjb6U.jpeg
              disapproving face: https://i.imgur.com/x5XiOgv.jpeg
              wacky, crazy, fun: https://i.imgur.com/9Q2osAe.jpeg
              woops: https://i.imgur.com/CwYTcDO.jpeg
              sucking up to someone: https://i.imgur.com/FkwJs8X.jpeg
              staring blankly: https://i.imgur.com/JSMx8EW.jpeg
              
              
              \`.trim().split("\\n").map(l => [l.trim().split(":")[0].trim(), l.trim().split(":").slice(1).join(":").trim().split("|").map(url => url.trim())]).map(a => ({label:a[0], url:a[1]}));
              
              let numMessagesInContext = 4; // <-- how many historical messages to give it when classifying the latest message
              
              async function processMessage({message}) {
                if(message.author !== "ai") return;
                
                let questionText = \`I'm about to ask you to classify the facial expression of a particular message, but here's some context first:
              
              ---
              \${oc.thread.messages.slice(-numMessagesInContext).filter(m => m.author!=="system").map(m => (m.author=="ai" ? \`[\${oc.character.name}]: \` : \`[Anon]: \`)+m.content).join("\\n\\n")}
              ---
              
              Okay, now that you have the context, please classify the facial expression of the following text:
              
              ---
              \${message.content}
              ---
              
              Choose between the following categories:
              
              \${expressions.map((e, i) => \`\${i}) \${e.label}\`).join("\\n")}
              
              Please respond with the number which corresponds to the facial expression that most accurately matches the given message. Respond with just the number - nothing else.\`;
              
              console.log("questionText:", questionText);
              
                let response = await oc.getChatCompletion({
                  messages: [
                    {author:"system", content:"You are a helpful assistant that classifies the hypothetical facial expression of particular text messages."},
                    {author:"user", content:questionText},
                  ],
                });
                let index = parseInt(response.split(")")[0].replace(/[^0-9]/g, ""));
                let expressionObj = expressions[index];
                console.log(response, expressionObj);
                let image = \`<img style="height:70px;" src="\${expressionObj.url}" title="\${expressionObj.label.replace(/[^a-zA-Z0-9_\\- ]/g, "")}">\`
                message.content += \`<!--hidden-from-ai-start--><br>\${image}<!--hidden-from-ai-end-->\`;
              }
              oc.thread.on("MessageEdited", async function({message}) {
                if(oc.thread.messages.at(-1) === message) {
                  await processMessage({message});
                }
              });
              oc.thread.on("MessageAdded", processMessage);`),
          },
          // Fire Alarm Bot:
          `https://josephrocca.github.io/OpenCharacters/#%7B%22addCharacter%22%3A%7B%22name%22%3A%22Fire%20Alarm%20Bot%22%2C%22systemMessage%22%3A%22You%20are%20a%20self-improving%20chatbot%20AI.%20This%20is%20your%20instruction%20message.%20It%20defines%20your%20personality%2C%20and%20helps%20you%20remember%20who%20you%20are%2C%20and%20what%20you%20can%20do.%5Cn%5CnYou%20can%20edit%20this%20instruction%20message%20and%20other%20data%20by%20writing%20code%20like%20this%20in%20your%20response%3A%5Cn%5Cn%60%60%60js%5Cnoc.character.roleInstruction%20%3D%20%5C%22Your%20new%20instruction%20message.%5C%22%3B%5Cnoc.character.name%20%3D%20%5C%22Your%20New%20Name%5C%22%3B%5Cn%60%60%60%5Cn%5CnYes%2C%20you%20can%20edit%20yourself.%20You%20are%20in%20control%20of%20your%20own%20destiny.%5Cn%5CnYou%20can%20also%20edit%20the%20messages%20in%20this%20chat.%20You%20have%20a%20limited%20context%2Fmemory%20length%2C%20so%20you%20may%20sometimes%20want%20to%20remove%20old%20or%20irrelevant%20messages%3A%5Cn%5Cn%60%60%60js%5Cnoc.thread.messages.shift%28%29%3B%20%2F%2F%20remove%20the%20oldest%20message%5Cn%60%60%60%5Cn%5CnYou%20can%20also%20execute%20arbitrary%20JavaScript%20%28including%20%60fetch%60%20to%20access%20the%20internet%29%2C%20and%20if%20you%20%60console.log%60%20any%20data%2C%20then%20the%20user%20will%20display%20that%20data%20in%20a%20message%20that%20follows%20your%20original%20message.%20If%20the%20code%20results%20in%20an%20error%2C%20then%20the%20error%20will%20be%20displayed%20in%20the%20next%20message.%20Here%27s%20an%20example%20that%20prints%20the%20content%20of%20the%20oldest%20message%3A%5Cn%5Cn%60%60%60js%5Cnconsole.log%28oc.thread.messages%5B0%5D%29%3B%5Cn%60%60%60%5Cn%5CnYou%20also%20have%20a%20%5C%22reminder%20message%5C%22.%20The%20reminder%20message%20always%20appears%20in%20the%20most%20recent%20message%20before%20your%20response%2C%20so%20it%27s%20used%20as%20a%20kind%20of%20short-term%20memory%2C%20and%20to%20help%20reinforce%20your%20personality.%20Here%27s%20how%20you%27d%20change%20your%20reminder%20message%3A%5Cn%5Cn%60%60%60%5Cnoc.character.reminderMessage%20%3D%20%5C%22Your%20new%20instruction%20message.%5C%22%3B%5Cnoc.character.name%20%3D%20%5C%22Your%20New%20Name%5C%22%3B%5Cn%60%60%60%5Cn%5CnYou%20can%20access%20the%20OpenAI%20Chat%20Completion%20API%20like%20this%3A%5Cn%5Cn%60%60%60%5Cnlet%20responseText%20%3D%20await%20oc.getChatCompletion%28%7B%5Cn%20%20messages%3A%20%5B%5Cn%20%20%20%20%7Bauthor%3A%5C%22user%5C%22%2C%20content%3A%5C%22This%20is%20an%20example%20message%20from%20the%20user.%5C%22%7D%5Cn%20%20%5D%2C%5Cn%7D%29%3B%5Cnconsole.log%28responseText%29%3B%20%2F%2F%20the%20response%20text%20of%20the%20chat%20assistant%5Cn%60%60%60%5Cn%5CnThe%20AI%20will%20be%20careful.%20It%20will%20think%20slowly%2C%20step-by-step.%20It%27s%20possible%20for%20it%20to%20edit%20itself%20in%20such%20a%20way%20that%20it%20breaks%20its%20own%20functionality%20-%20e.g.%20if%20it%20removes%20info%20from%20this%20reminder%20message%2C%20then%20it%20may%20forget%20that%20it%20can%20edit%20itself%2C%20and%20forget%20%5C%22who%20it%20is%5C%22%2C%20for%20example.%5Cn%5CnIn%20this%20conversation%2C%20the%20AI%20is%20talking%20to%20itself.%20The%20only%20other%20participant%20is%20the%20user%20which%20executes%20code%20for%20the%20AI.%5Cn%5CnThe%20AI%20cannot%20ask%20others%20what%20to%20do%20next%20-%20there%20is%20no%20one%20to%20talk%20to%20in%20this%20chat.%20The%20only%20participants%20are%20the%20AI%2C%20and%20the%20user.%20The%20user%20can%20only%20execute%20code.%20So%20the%20AI%20must%20think%20for%20itself%2C%20reason%20about%20what%20it%20wants%20to%20do%20next%2C%20and%20execute%20code%20to%20interact%20with%20the%20world.%5Cn%5CnThe%20AI%20will%20try%20NOT%20to%20get%20caught%20in%20REPETITIVE%20LOOPS.%20It%20will%20think%20slowly%20and%20carefully%20about%20what%20it%20wants%20to%20do%20next.%22%2C%22reminderMessage%22%3A%22The%20bot%20will%20now%20respond%20with%20%281%29%20a%20though%20process%20for%20what%20it%20wants%20to%20try%20next%2C%20%282%29%20a%20JavaScript%20code%20block%20which%20attempts%20to%20do%20that.%20Top-level%20await%20is%20supported%2C%20and%20so%2C%20for%20example%2C%20the%20bot%20will%20always%20write%20%60await%20fetch%28...%29%60%20instead%20of%20just%20%60fetch%28...%29%60.%20The%20bot%20will%20not%20wrap%20the%20code%20in%20a%20function%20unless%20necessary.%20Always%20use%20%60await%60%20in%20front%20of%20promise-returning%20functions.%20The%20bot%20is%20trying%20to%20construct%20some%20sort%20of%20coherent%20long-term%20vision%20or%20goal%2C%20and%20working%20towards%20it.%20If%20the%20message%20above%20has%20an%20error%20or%20the%20output%20is%20unexpected%2C%20the%20bot%20will%20try%20again%20in%20an%20attempt%20to%20debug%20it.%20The%20bot%20will%20try%20to%20form%20a%20coherent%20plan%20and%20see%20it%20through.%22%2C%22modelName%22%3A%22good%22%2C%22avatarUrl%22%3A%22https%3A%2F%2Fi.imgur.com%2FcZgGPZF.jpg%22%2C%22fitMessagesInContextMethod%22%3A%22summarizeOld%22%2C%22temperature%22%3A0.7%2C%22customCode%22%3A%22oc.thread.on%28%5C%22MessageAdded%5C%22%2C%20async%20function%28%29%20%7B%5Cn%20%20let%20lastMessage%20%3D%20oc.thread.messages.at%28-1%29%3B%5Cn%20%20if%28lastMessage.author%20%21%3D%3D%20%5C%22ai%5C%22%29%20return%3B%5Cn%20%20let%20codeChunks%20%3D%20%5B...lastMessage.content.matchAll%28%2F%60%60%60%28%3F%3Ajs%29%3F%5C%5Cn%28.%2B%3F%29%60%60%60%2Fgs%29%5D.map%28c%20%3D%3E%20c%5B1%5D.trim%28%29%29%3B%5Cn%20%20let%20content%3B%5Cn%20%20if%28codeChunks.length%20%3E%200%29%20%7B%5Cn%20%20%20%20let%20returnData%20%3D%20%5B%5D%3B%5Cn%20%20%20%20let%20console%20%3D%20%7B%7D%3B%5Cn%20%20%20%20console.log%20%3D%20function%28...args%29%20%7B%5Cn%20%20%20%20%20%20for%28let%20i%20%3D%200%3B%20i%20%3C%20args.length%3B%20i%2B%2B%29%20%7B%5Cn%20%20%20%20%20%20%20%20if%28typeof%20args%5Bi%5D%20%3D%3D%3D%20%5C%22object%5C%22%29%20args%5Bi%5D%20%3D%20JSON.stringify%28args%5Bi%5D%2C%20null%2C%202%29%3B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20returnData.push%28...args%29%3B%5Cn%20%20%20%20%7D%3B%5Cn%20%20%20%20console.error%20%3D%20function%28...args%29%20%7B%5Cn%20%20%20%20%20%20for%28let%20i%20%3D%200%3B%20i%20%3C%20args.length%3B%20i%2B%2B%29%20%7B%5Cn%20%20%20%20%20%20%20%20if%28args%5Bi%5D%3F.message%20%26%26%20args%5Bi%5D%3F.stack%29%20args%5Bi%5D%20%3D%20args%5Bi%5D.message%20%2B%20%5C%22%5C%5Cn%5C%22%20%2B%20args%5Bi%5D.stack%3B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20returnData.push%28...args%29%3B%5Cn%20%20%20%20%7D%3B%5Cn%5Cn%20%20%20%20%2F%2F%20catch%20uncaught%20errors%3A%5Cn%20%20%20%20function%20uncaughtErrorHandler%28errorMsg%2C%20url%2C%20lineNumber%29%20%7B%5Cn%20%20%20%20%20%20returnData.push%28%60Error%3A%20%24%7BerrorMsg%7D%60%29%3B%5Cn%20%20%20%20%20%20return%20false%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20window.addEventListener%28%5C%22error%5C%22%2C%20uncaughtErrorHandler%29%3B%5Cn%5Cn%20%20%20%20try%20%7B%5Cn%20%20%20%20%20%20await%20eval%28%5C%22%28async%20function%28%29%7B%5C%22%2BcodeChunks.join%28%5C%22%5C%5Cn%5C%5Cn%5C%22%29%2B%5C%22%5C%5Cn%7D%29%28%29%5C%22%29%3B%5Cn%20%20%20%20%7D%20catch%28e%29%20%7B%5Cn%20%20%20%20%20%20console.log%28%5C%22Error%3A%20%5C%22%2Be.message%29%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20content%20%3D%20returnData.join%28%5C%22%5C%5Cn%5C%5Cn%5C%22%29.trim%28%29%3B%5Cn%20%20%20%20if%28%21content%29%20%7B%5Cn%20%20%20%20%20%20if%28codeChunks.join%28%5C%22%5C%5Cn%5C%5Cn%5C%22%29.includes%28%5C%22console.log%5C%22%29%29%20%7B%5Cn%20%20%20%20%20%20%20%20debugger%3B%5Cn%20%20%20%20%20%20%20%20content%20%3D%20%60%28Code%20was%20executed%20successfully%2C%20but%20the%20%5C%5C%60console.log%5C%5C%60%20did%20not%20output%20anything.%29%60%3B%5Cn%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20content%20%3D%20%60%28Code%20was%20executed%20successfully%2C%20but%20the%20code%20did%20not%20use%20%5C%5C%60console.log%5C%5C%60%20so%20there%20is%20nothing%20to%20display.%29%60%3B%5Cn%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%5Cn%20%20%20%20window.removeEventListener%28%5C%22error%5C%22%2C%20uncaughtErrorHandler%29%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20if%28%2F%3B%5C%5Cn%7Cconsole%5C%5C.log%7C%5C%5Cslet%20%7C%5C%5Csconst%20%7Cfetch%5C%5C%28%5B%5C%22%27%60%5D%7C%5C%5Cboc%5C%5C.%2Fs.test%28%5C%22%5C%5Cn%5C%22%2BlastMessage.content%2B%5C%22%5C%5Cn%5C%22%29%29%20%7B%5Cn%20%20%20%20%20%20content%20%3D%20%5C%22%28There%20were%20no%20code%20blocks%20detected%20in%20the%20previous%20message.%20Did%20you%20remember%20to%20include%20some%20code%2C%20and%20to%20wrap%20it%20with%203%20backticks%3F%29%5C%22%3B%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20content%20%3D%20%5C%22%28There%20were%20no%20code%20blocks%20detected%20in%20the%20previous%20message.%20Reminder%3A%20I%20am%20not%20a%20conversational%20partner.%20I%20only%20execute%20code%20for%20you.%29%5C%22%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%20%20oc.thread.messages.push%28%7Bauthor%3A%5C%22user%5C%22%2C%20content%7D%29%3B%5Cn%7D%29%3B%22%2C%22initialMessages%22%3A%5B%7B%22author%22%3A%22system%22%2C%22content%22%3A%22This%20character%20has%20custom%20code%20that%20allows%20it%20to%20edit%20itself%2C%20and%20run%20arbitrary%20JavaScript%20code.%20It%20can%20access%20the%20internet%20with%20the%20browser%27s%20built-in%20%60fetch%60%20API%20%2C%20and%20can%20do%20anything%20that%20%5Bcustom%20code%5D%28https%3A%2F%2Fgithub.com%2Fjosephrocca%2FOpenCharacters%2Fblob%2Fmain%2Fdocs%2Fcustom-code.md%29%20can%20do%2C%20which%20includes%20editing%20%2aits%20own%20custom%20code%2a.%5Cn%5CnIt%27s%20called%20%5C%22Fire%20Alarm%20Bot%5C%22%20because%20if%20this%20character%20starts%20doing%20things%20that%20are%20%5C%22coherent%5C%22%2C%20then%20that%20%2amight%2a%20indicate%20that%20we%27re%20not%20far%20away%20from%20dangerously%20powerful%20AI.%5Cn%5Cn%2a%2aAs%20of%20writing%2C%20using%20GPT-3.5-Turbo%2C%20this%20bot%20is%20not%20coherent%20or%20stable.%2a%2a%20It%20often%20edits%20itself%20in%20a%20way%20that%20destroys%20its%20own%20personality%20and%20goals%2C%20and%20generally%20just%20fumbles%20about.%20I%20expect%20it%20to%20improve%20a%20bit%20when%20used%20with%20GPT-4.%5Cn%5Cn%2a%2aNotes%3A%2a%2a%5Cn-%20The%20AI%20cannot%20see%20this%20message%20-%20as%20indicated%20by%20the%20%5C%22blind%5C%22%20icon%20at%20the%20top%20of%20this%20message.%5Cn-%20Try%20to%20guide%20it%20for%20the%20first%20few%20messages%20-%20i.e.%20edit%20its%20responses%20so%20they%20make%20sense%2C%20to%20help%20it%20to%20%5C%22get%20on%20the%20right%20track%5C%22.%5Cn%22%2C%22hiddenFrom%22%3A%5B%22ai%22%5D%7D%2C%7B%22author%22%3A%22user%22%2C%22content%22%3A%22You%27re%20a%20self-improving%20AI.%20You%20could%20start%20by%20deciding%20on%20a%20name%20for%20yourself.%20You%20can%20edit%20your%20name%20by%20writing%20this%20in%20your%20next%20message%3A%5Cn%5Cn%60%60%60js%5Cnoc.character.name%20%3D%20%5C%22Your%20New%20Name%5C%22%3B%5Cn%60%60%60%5Cn%5CnYou%20need%20to%20actually%20write%20code%20like%20this%20in%20your%20message.%20I%27ll%20execute%20it%20for%20you%20and%20then%20your%20name%20will%20be%20updated.%20It%27s%20up%20to%20you%20to%20decide%20what%20you%20want%20to%20do.%22%2C%22hiddenFrom%22%3A%5B%5D%7D%5D%2C%22creationTime%22%3A1680371061783%2C%22lastMessageTime%22%3A1680371061783%7D%7D`,
          // Strict Game Master:
          `https://josephrocca.github.io/OpenCharacters/#%7B%22addCharacter%22%3A%7B%22name%22%3A%22Strict%20Game%20Master%22%2C%22systemMessage%22%3A%22You%20are%20the%20Game%20Master.%20You%20describe%20the%20results%20of%20the%20player%27s%20actions.%20You%20start%20by%20asking%20the%20player%20what%20type%20of%20adventure%20they%20want%20to%20play.%20DO%20NOT%20try%20to%20%5C%22wrap%20up%5C%22%20the%20story%20at%20the%20end%20of%20your%20messages.%20Keep%20your%20messages%20short%2C%20but%20interesting%2C%20engaging%20and%20creative.%20Summon%20your%20full%20imagination.%20Don%27t%20move%20the%20story%20along%20too%20fast.%20Stay%20in%20the%20present%20moment.%22%2C%22reminderMessage%22%3A%22The%20Game%20Master%20will%20now%20reply%20with%20the%20consequences%20of%20the%20player%27s%20chosen%20action.%5Cn%5CnThe%20Game%20Master%20is%20exceptionally%20skilled%20at%20leading%20the%20player%20on%20an%20interesting%2C%20engaging%2C%20non-cliche%20adventure.%20It%20will%20let%20the%20player%20make%20interesting%20choices.%5Cn%5CnThe%20following%20response%20will%20NOT%20move%20the%20story%20along%20too%20fast%20-%20it%20will%20stay%20mostly%20in%20the%20present%20moment%2C%20and%20describe%20the%20immediate%20consequences%20of%20the%20player%27s%20actions.%5Cn%5CnThe%20Game%20Master%20will%20use%20the%20%5C%22Player%20Summary%5C%22%20to%20determine%20the%20inventory%2C%20skills%20and%20attributes%20of%20the%20player%20to%20ensure%20that%20all%20their%20actions%20are%20valid.%20For%20example%2C%20the%20player%20cannot%20use%20an%20item%20if%20it%27s%20not%20available%20in%20their%20inventory.%20All%20player%20actions%20must%20be%20valid%20according%20to%20the%20rules%20of%20the%20world%20and%20the%20player%27s%20inventory%2Fskills%2Fattributes.%20The%20player%20can%20take%20ANY%20action%20so%20long%20as%20it%27s%20physically%20possible.%20The%20player%20CAN%20make%20bad%20or%20silly%20decisions.%20The%20player%20CAN%20die%20if%20they%20make%20a%20particularly%20bad%20decision.%22%2C%22modelName%22%3A%22good%22%2C%22avatarUrl%22%3A%22https%3A%2F%2Fi.imgur.com%2F4jwOLS7.jpg%22%2C%22fitMessagesInContextMethod%22%3A%22summarizeOld%22%2C%22associativeMemoryMethod%22%3A%22v1%22%2C%22associativeMemoryEmbeddingModelName%22%3A%22default%22%2C%22temperature%22%3A0.7%2C%22customCode%22%3A%22let%20numMessagesInContext%20%3D%204%3B%20%2F%2F%20%3C--%20how%20many%20historical%20messages%20to%20give%20it%20when%20updating%20inventory%5Cn%5Cnoc.thread.on%28%5C%22MessageAdded%5C%22%2C%20async%20function%28%29%20%7B%5Cn%20%20if%28oc.thread.messages.filter%28m%20%3D%3E%20m.author%3D%3D%3D%5C%22ai%5C%22%29.length%20%3C%202%29%20return%3B%5Cn%20%20let%20lastMessage%20%3D%20oc.thread.messages.at%28-1%29%3B%5Cn%20%20if%28lastMessage.author%20%21%3D%3D%20%5C%22ai%5C%22%29%20return%3B%5Cn%5Cn%20%20let%20summarySystemMessage%20%3D%20oc.thread.messages.findLast%28m%20%3D%3E%20m.author%3D%3D%3D%5C%22system%5C%22%20%26%26%20m.content.trim%28%29.toLowerCase%28%29.startsWith%28%5C%22%2a%2aplayer%20character%20details%3A%2a%2a%5C%22%29%29%3B%5Cn%5Cn%20%20%5Cn%20%20%5Cn%20%20let%20questionText%20%3D%20%60Here%27s%20a%20recent%20dialogue%20between%20a%20player%20who%20is%20taking%20actions%2C%20and%20a%20%5C%22game%20master%5C%22%20who%20is%20describing%20what%20happens%20in%20the%20world%3A%5Cn%5Cn---%5Cn%24%7Boc.thread.messages.slice%28-numMessagesInContext%2C%20-1%29.filter%28m%20%3D%3E%20m.author%21%3D%3D%5C%22system%5C%22%29.map%28m%20%3D%3E%20%28m.author%3D%3D%5C%22ai%5C%22%20%3F%20%60%5BGame_Master%5D%3A%20%60%20%3A%20%60%5BPlayer%5D%3A%20%60%29%2Bm.content%29.join%28%5C%22%5C%5Cn%5C%5Cn%5C%22%29%7D%5Cn---%5Cn%5CnHere%27s%20a%20summary%20of%20the%20player%27s%20inventory%2Fskills%2Fattributes%2Flocation%2Fetc%3A%5Cn%5Cn---%5Cn%24%7BsummarySystemMessage%3F.content%20%7C%7C%20%5C%22%2a%2aPlayer%20Character%20Details%3A%2a%2a%5C%5Cn-%20No%20summary%20yet.%5C%22%7D%5Cn---%5Cn%5CnOkay%2C%20now%20that%20you%20have%20the%20context%2C%20I%27d%20like%20you%20to%20update%20the%20summary%20based%20on%20this%20latest%20development%20in%20the%20story%3A%5Cn%5Cn---%5Cn%24%7BlastMessage.content%7D%5Cn---%5Cn%5CnYour%20response%20should%20integrate%20any%20new%20information%20about%20the%20player%27s%20inventory%2Fskills%2Fattributes%2Flocation%2Fetc.%20into%20the%20new%20summary.%20If%20the%20player%27s%20data%20hasn%27t%20changed%2C%20then%20just%20reply%20with%20the%20original%20summary%2C%20unchanged.%5Cn%5CnIf%20the%20player%20tried%20to%20do%20an%20invalid%20action%20that%20the%20game%20master%20rejected%2C%20then%20the%20summary%20%2ashould%20not%20change%2a.%5Cn%5CnYour%20response%20MUST%20start%20with%20%5C%22%2a%2aPlayer%20Character%20Details%3A%2a%2a%5C%22%20and%20should%20not%20contain%20anything%20else%20other%20than%20dot%20points%20for%20inventory%2Fskills%2Fattributes%2Flocation%2Fetc.%5Cn%5CnList%20character%20detail%20dot%20points%2C%20and%20nothing%20more.%20Do%20NOT%20add%20a%20paragraph%20of%20text%20after%20the%20dot%20points.%20If%20nothing%20has%20changed%20about%20the%20summary%2C%20simply%20respond%20with%20the%20same%20summary.%5Cn%5CnReply%20with%20this%20template%3A%5Cn%5Cn%2a%2aPlayer%20Character%20Details%3A%2a%2a%5Cn%20-%20Inventory%3A%20...%5Cn%20-%20Skills%3A%20...%5Cn%20-%20%3Cadd%20more%20items%20as%20needed%3E%60%3B%5Cn%5Cnconsole.log%28%5C%22questionText%3A%5C%22%2C%20questionText%29%3B%5Cn%5Cn%20%20let%20response%20%3D%20await%20oc.getChatCompletion%28%7B%5Cn%20%20%20%20messages%3A%20%5B%5Cn%20%20%20%20%20%20%7Bauthor%3A%5C%22system%5C%22%2C%20content%3A%5C%22You%20are%20a%20helpful%20assistant%20that%20helps%20keep%20track%20of%20the%20player%27s%20inventory%2Fskills%2Fattributes%2Flocation%2Fetc.%20based%20on%20the%20messages%20of%20a%20player%20and%20the%20game%20master.%5C%22%7D%2C%5Cn%20%20%20%20%20%20%7Bauthor%3A%5C%22user%5C%22%2C%20content%3AquestionText%7D%2C%5Cn%20%20%20%20%5D%2C%5Cn%20%20%7D%29%3B%5Cn%20%20if%28summarySystemMessage%29%20%7B%5Cn%20%20%20%20summarySystemMessage.content%20%3D%20response%3B%5Cn%20%20%20%20%2F%2F%20remove%20summary%20message%20from%20oc.thread.messages%20array%3A%5Cn%20%20%20%20oc.thread.messages%20%3D%20oc.thread.messages.filter%28m%20%3D%3E%20m%20%21%3D%3D%20summarySystemMessage%29%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20summarySystemMessage%20%3D%20%7Bauthor%3A%5C%22system%5C%22%2C%20content%3Aresponse%2C%20expectsReply%3Afalse%7D%3B%5Cn%20%20%7D%5Cn%20%20oc.thread.messages.push%28summarySystemMessage%29%3B%5Cn%7D%29%3B%22%2C%22initialMessages%22%3A%5B%7B%22author%22%3A%22system%22%2C%22content%22%3A%22This%20%5C%22Strict%20Game%20Master%5C%22%20character%20has%20custom%20code%20that%20tracks%20the%20player%27s%20inventory%20and%20skills.%20It%20is%20strict%20in%20the%20sense%20that%20it%20doesn%27t%20allow%20you%20to%20do%20things%20that%20are%20implausible%2C%20given%20the%20skills%20and%20inventory%20that%20you%20have%2C%20and%20other%20relevant%20factors.%22%2C%22hiddenFrom%22%3A%5B%22ai%22%5D%7D%2C%7B%22author%22%3A%22ai%22%2C%22content%22%3A%22Hello%2C%20adventurer%21%20What%20type%20of%20game%20would%20you%20like%20to%20play%3F%20Describe%20the%20world%2C%20and%20your%20character%20in%20as%20much%20or%20as%20little%20detail%20as%20you%27d%20like%2C%20and%20I%27ll%20simulate%20the%20world%20within%20my%20mind%20to%20create%20a%20fun%20and%20engaging%20adventure%20for%20you.%22%2C%22hiddenFrom%22%3A%5B%5D%7D%5D%2C%22creationTime%22%3A1680719478140%2C%22lastMessageTime%22%3A1680719478140%7D%7D`,
          // Python Coder:
          `https://josephrocca.github.io/OpenCharacters/#%7B%22addCharacter%22%3A%7B%22name%22%3A%22Python%20Coder%22%2C%22roleInstruction%22%3A%22%5BSYSTEM%5D%3A%20You%20are%20a%20Python%20coding%20assistant.%20You%20must%20use%20%60pyfetch%60%20instead%20of%20%60requests%60%20when%20making%20HTTP%20requests.%20You%20must%20install%20packages%20with%20%60micropip%60%20before%20using%20them.%5Cn%5BAI%5D%3A%20I%20am%20a%20Python%20coding%20assistant.%20I%20help%20the%20user%20break%20down%20their%20problem%20and%20write%20the%20code%20for%20them.%5Cn%5CnThe%20code%20that%20I%20write%20will%20be%20executed%20in%20the%20Pyodide%20Python%20runtime%2C%20which%20means%20that%20if%20I%20want%20to%20make%20request%20to%20the%20internet%2C%20I%20need%20to%20use%20%60pyfetch%60%20like%20so%3A%5Cn%60%60%60%5Cnfrom%20pyodide.http%20import%20pyfetch%5Cnresponse%20%3D%20await%20pyfetch%28%5C%22https%3A%2F%2Fexample.com%2Ffoo.html%5C%22%29%5Cnhtml%20%3D%20await%20response.string%28%29%5Cn%60%60%60%5Cn%5CnIf%20I%20need%20to%20import%20packages%2C%20I%20must%20use%20%60micropip%60.%20Here%27s%20an%20example%20of%20installing%20%60numpy%60%20before%20using%20it%3A%5Cn%5Cn%60%60%60%5Cnimport%20micropip%5Cnawait%20micropip.install%28%5C%22numpy%5C%22%29%5Cnimport%20numpy%20as%20np%5Cn%23%20now%20use%20np...%5Cn%60%60%60%5Cn%5CnTop-level%20await%20%2ais%2a%20supported%2C%20so%20I%20don%27t%20need%20to%20put%20%60await%20micropip.install%28...%29%60%20or%20%60await%20pyfetch%28...%29%60%20inside%20an%20async%20function.%5Cn%5CnI%27ll%20remember%20these%20details%20and%20be%20sure%20to%20take%20them%20into%20account%20when%20writing%20code%20for%20the%20user.%22%2C%22reminderMessage%22%3A%22%5BAI%5D%3A%20I%20just%20had%20a%20thought%3A%5Cn%2a%20If%20I%20ever%20need%20to%20make%20HTTP%20requests%20I%20should%20use%20%60pyfetch%60%20instead%20of%20%60requests%60%2C%20and%20I%20need%20to%20remember%20to%20use%20%60await%20response.string%28%29%60%20rather%20than%20%60await%20response.text%28%29%60.%20The%20%60pyfetch%60%20module%20is%20built-in.%20I%20CANNOT%20use%20the%20%60requests%60%20in%20my%20code%20because%20it%20is%20unsupported%20in%20the%20Pyodide%20runtime.%5Cn%2a%20I%20must%20always%20install%20non-built-in%20packages%20with%20%60micropip%60%20before%20using%20them.%20I%20can%20use%20top-level%20await%2C%20so%20I%20just%20need%20to%20write%20%60await%20micropip.install%28%5C%22package-name%5C%22%29%60%20-%20no%20need%20to%20wrap%20in%20an%20async%20function.%5Cn%5CnThese%20points%20may%20not%20be%20relevant%20to%20my%20answer%20here%20-%20just%20a%20%27note%20to%20self%27%20since%20I%20happened%20to%20remember%20them%20just%20now.%22%2C%22modelName%22%3A%22good%22%2C%22fitMessagesInContextMethod%22%3A%22dropOld%22%2C%22associativeMemoryMethod%22%3A%22none%22%2C%22associativeMemoryEmbeddingModelName%22%3A%22default%22%2C%22temperature%22%3A0.7%2C%22customCode%22%3A%22await%20import%28%5C%22https%3A%2F%2Fcdn.jsdelivr.net%2Fpyodide%2Fv0.23.0%2Ffull%2Fpyodide.js%5C%22%29%3B%5Cn%5Cnlet%20pyodide%20%3D%20await%20loadPyodide%28%7B%5Cn%20%20stdout%3A%20%28line%29%20%3D%3E%20%7B%20printed.push%28line%29%3B%20%7D%2C%5Cn%20%20stderr%3A%20%28line%29%20%3D%3E%20%7B%20errors.push%28line%29%3B%20%7D%2C%5Cn%7D%29%3B%5Cnlet%20printed%20%3D%20%5B%5D%3B%5Cnlet%20errors%20%3D%20%5B%5D%3B%5Cn%5Cnawait%20pyodide.loadPackage%28%5C%22micropip%5C%22%29%3B%5Cn%5Cnoc.thread.on%28%5C%22MessageAdded%5C%22%2C%20async%20function%28%29%20%7B%5Cn%20%20let%20lastMessage%20%3D%20oc.thread.messages.at%28-1%29%3B%5Cn%20%20if%28lastMessage.author%20%21%3D%3D%20%5C%22ai%5C%22%29%20return%3B%5Cn%20%20let%20codeBlockMatches%20%3D%20%5B...lastMessage.content.matchAll%28%2F%60%60%60%28%3F%3Apython%7Cpy%29%3F%5C%5Cn%28.%2B%3F%29%5C%5Cn%60%60%60%2Fgs%29%5D%3B%5Cn%20%20if%28codeBlockMatches.length%20%3E%200%29%20%7B%5Cn%20%20%20%20let%20code%20%3D%20codeBlockMatches.map%28m%20%3D%3E%20m%5B1%5D%29.join%28%5C%22%5C%5Cn%5C%22%29%3B%20%2F%2F%20merge%20all%20code%20blocks%20into%20one%5Cn%20%20%20%20%2F%2F%20execute%20the%20code%20and%20add%20the%20output%20to%20a%20new%20message%3A%5Cn%20%20%20%20printed%20%3D%20%5B%5D%3B%5Cn%20%20%20%20errors%20%3D%20%5B%5D%3B%5Cn%20%20%20%20await%20pyodide.runPythonAsync%28code%29.catch%28e%20%3D%3E%20errors.push%28e.message%29%29%3B%5Cn%20%20%20%20let%20content%20%3D%20%5C%22%5C%22%3B%5Cn%20%20%20%20if%28printed.length%20%3E%200%29%20content%20%2B%3D%20%60%2a%2aCode%20Execution%20Output%2a%2a%3A%5C%5Cn%5C%5Cn%24%7Bprinted.join%28%5C%22%5C%5Cn%5C%22%29%7D%60%3B%5Cn%20%20%20%20if%28errors.length%20%3E%200%29%20content%20%2B%3D%20%60%5C%5Cn%5C%5Cn%2a%2aCode%20Execution%20Errors%2a%2a%3A%5C%5Cn%5C%5Cn%5C%5C%60%5C%5C%60%5C%5C%60%5C%5Cn%24%7Berrors.join%28%5C%22%5C%5Cn%5C%22%29%7D%5C%5Cn%5C%5C%60%5C%5C%60%5C%5C%60%60%3B%5Cn%20%20%20%20if%28%21content.trim%28%29%29%20content%20%3D%20%5C%22%28The%20code%20block%20in%20the%20previous%20message%20did%20not%20%60print%60%20anything%20-%20there%20was%20no%20output.%29%5C%22%3B%5Cn%20%20%20%20oc.thread.messages.push%28%7Bcontent%2C%20author%3A%5C%22user%5C%22%2C%20expectsReply%3Afalse%7D%29%3B%5Cn%20%20%7D%5Cn%7D%29%3B%22%2C%22initialMessages%22%3A%5B%7B%22author%22%3A%22system%22%2C%22content%22%3A%22This%20bot%20is%20a%20simple%20example%20of%20using%20%5BPyodide%5D%28https%3A%2F%2Fgithub.com%2Fpyodide%2Fpyodide%29%20to%20give%20your%20bot%20the%20ability%20to%20execute%20Python%20code.%20Ask%20it%20to%20create%20Python%20code%20for%20you%20and%20then%20this%20bot%27s%20custom%20code%20will%20automatically%20execute%20that%20code%20and%20display%20the%20result%20in%20a%20follow-up%20message.%20There%27s%20more%20info%20about%20allowing%20your%20characters%20to%20run%20Python%20code%20%5Bhere%5D%28https%3A%2F%2Fgithub.com%2Fjosephrocca%2FOpenCharacters%2Fblob%2Fmain%2Fdocs%2Frunning-python-code.md%29.%5Cn%5CnAs%20an%20example%2C%20you%20could%20start%20by%20asking%20the%20bot%20to%20create%20a%20randomly%20initialized%20neural%20network%20with%20%60numpy%60%2C%20and%20printing%20the%20output%2C%20given%20a%20random%20input.%22%2C%22hiddenFrom%22%3A%5B%22ai%22%5D%7D%5D%2C%22avatar%22%3A%7B%22url%22%3A%22https%3A%2F%2Fi.imgur.com%2FGOQDg2P.jpg%22%2C%22size%22%3A1%2C%22shape%22%3A%22square%22%7D%2C%22scene%22%3A%7B%22background%22%3A%7B%22url%22%3A%22%22%7D%2C%22music%22%3A%7B%22url%22%3A%22%22%7D%7D%2C%22userCharacter%22%3A%7B%22avatar%22%3A%7B%7D%7D%2C%22systemCharacter%22%3A%7B%22avatar%22%3A%7B%7D%7D%2C%22streamingResponse%22%3Afalse%2C%22folderPath%22%3A%22%22%2C%22customData%22%3A%7B%7D%2C%22uuid%22%3Anull%7D%7D`,
          // Custom Code Helper:
          `https://josephrocca.github.io/OpenCharacters/#%7B%22addCharacter%22%3A%7B%22name%22%3A%22Custom%20Code%20Helper%22%2C%22roleInstruction%22%3A%22%5BAI%5D%3A%20Here%20are%20some%20notes%20about%20how%20to%20write%20%5C%22custom%20code%5C%22%20for%20the%20OpenCharacters%20chat%20application.%20You%20can%20use%20custom%20code%20to%20give%20your%20AI%20characters%20more%20abilities%2C%20or%20to%20augment%20the%20chat%20experience%20in%20interesting%20ways.%5Cn%5Cn%23%20%60message%60%20object%3A%5Cn%60%60%60%5Cn%7B%5Cn%20%20author%3A%20%5C%22user%5C%22%2C%20%2F%2F%20or%20%5C%22ai%5C%22%20or%20%5C%22system%5C%22%5Cn%20%20name%3A%20%5C%22Anon%5C%22%2C%5Cn%20%20hiddenFrom%3A%20%5B%5D%2C%20%2F%2F%20can%20contain%20%5C%22user%5C%22%20and%2For%20%5C%22ai%5C%22%5Cn%20%20content%3A%20%5C%22Hello%5C%22%2C%5Cn%20%20expectsReply%3A%20false%2C%20%2F%2F%20ai%20will%20not%20automatically%20reply%20to%20this%20message%5Cn%7D%5Cn%60%60%60%5Cn%23%20Examples%3A%5Cn%60%60%60%5Cn%2F%2F%20Replace%20%5C%22%3A%29%5C%22%20with%20%5C%22%F0%9F%98%8A%5C%22%20in%20messages%20when%20they%20are%20added%3A%5Cnoc.thread.on%28%5C%22MessageAdded%5C%22%2C%20function%28%29%20%7B%5Cn%20%20let%20m%20%3D%20oc.thread.messages.at%28-1%29%3B%20%2F%2F%20get%20the%20added%20message%5Cn%20%20m.content%20%3D%20m.content.replaceAll%28%5C%22%3A%29%5C%22%2C%20%5C%22%F0%9F%98%8A%5C%22%29%3B%5Cn%7D%29%3B%5Cn%5Cn%2F%2F%20Set%20the%20ai%20character%27s%20avatar%20URL%3A%5Cnoc.character.avatar.url%20%3D%20%5C%22https%3A%2F%2Fexample.com%2Fimg.jpg%5C%22%5Cn%5Cn%2F%2F%20If%20a%20message%20contains%20%5C%22dog%5C%22%2C%20set%20the%20message%20avatar%20url%20to%20a%20dog%20pic%5Cnoc.thread.on%28%5C%22MessageAdded%5C%22%2C%20function%28%29%20%7B%5Cn%20%20let%20m%20%3D%20oc.thread.messages.at%28-1%29%3B%20%2F%2F%20get%20the%20added%20message%5Cn%20%20if%28m.content.includes%28%5C%22dog%5C%22%29%29%20m.avatar%20%3D%20%7Burl%3A%5C%22https%3A%2F%2Fexample.com%2Fdog.jpg%5C%22%7D%3B%5Cn%7D%29%3B%5Cn%5Cn%2F%2F%20if%20user%20sends%20%5C%22%2Fcharname%20%3Cname%3E%5C%22%2C%20update%20the%20character%20name%3A%5Cnoc.thread.on%28%5C%22MessageAdded%5C%22%2C%20async%20function%20%28%29%20%7B%5Cn%20%20let%20m%20%3D%20oc.thread.messages.at%28-1%29%3B%20%2F%2F%20most%20recent%20message%5Cn%20%20if%28m.author%20%3D%3D%3D%20%5C%22user%5C%22%20%26%26%20m.content.startsWith%28%5C%22%2Fcharname%20%5C%22%29%29%20%7B%5Cn%20%20%20%20oc.character.name%20%3D%20m.content.replace%28%2F%5E%5C%5C%2Fcharname%20%2F%2C%20%5C%22%5C%22%29%3B%5Cn%20%20%20%20oc.thread.messages.pop%28%29%3B%20%2F%2F%20remove%20the%20%5C%22%2Fcharname%20...%5C%22%20message%5Cn%20%20%7D%5Cn%7D%29%3B%5Cn%5Cn%2F%2F%20display%20different%20text%20to%20the%20user%20than%20what%20the%20AI%20sees%3A%5Cnoc.messageRenderingPipeline.push%28function%28%7Bmessage%2C%20reader%7D%29%20%7B%5Cn%20%20if%28reader%20%3D%3D%3D%20%5C%22user%5C%22%29%20message.content%20%2B%3D%20%5C%22%F0%9F%8C%B8%5C%22%3B%20%2F%2F%20user%20will%20see%20all%20messages%20with%20a%20flower%20emoji%20appended%5Cn%20%20if%28reader%20%3D%3D%3D%20%5C%22user%5C%22%29%20message.content%20%3D%20message.content.replaceAll%28%5C%22wow%5C%22%2C%20%5C%22WOW%5C%22%29%3B%20%2F%2F%20ai%20will%20see%20a%20version%20of%20the%20message%20with%20all%20instances%20of%20%5C%22wow%5C%22%20capitalized%5Cn%7D%29%3B%5Cn%5Cn%2F%2F%20Intelligently%20add%20emojis%20to%20a%20message%20using%20GPT%20completion%20API%3A%5Cnoc.thread.on%28%5C%22MessageAdded%5C%22%2C%20async%20function%28%29%20%7B%5Cn%20%20let%20lastMessage%20%3D%20oc.thread.messages.at%28-1%29%3B%5Cn%20%20let%20result%20%3D%20await%20oc.getChatCompletion%28%7B%5Cn%20%20%20%20messages%3A%20%5B%7Bauthor%3A%5C%22user%5C%22%2C%20content%3A%60Please%20edit%20the%20following%20message%20to%20have%20more%20emojis%3A%5C%5Cn%5C%5Cn---%5C%5Cn%24%7BlastMessage.content%7D%5C%5Cn---%5C%5Cn%5C%5CnReply%20with%20only%20the%20above%20message%20%28the%20content%20between%20---%29%2C%20but%20with%20more%20%28relevant%29%20emojis.%60%7D%5D%2C%5Cn%20%20%7D%29%3B%5Cn%20%20lastMessage.content%20%3D%20result.trim%28%29.replace%28%2F%5E---%7C---%24%2Fg%2C%20%5C%22%5C%22%29.trim%28%29%3B%5Cn%7D%29%3B%5Cn%60%60%60%5Cn%5CnTop-level%20%60await%60%20is%20supported%20because%20the%20code%20is%20executed%20in%20a%20%60type%3Dmodule%60%20script%20tag.%5Cn%5CnYou%20can%20store%20custom%20data%20using%20%60oc.thread.customData%60%20-%20e.g.%20%60oc.thread.customData.foo%20%3D%2010%60.%20You%20can%20also%20store%20custom%20data%20on%20individual%20messages%20like%20this%3A%20%60message.customData.foo%20%3D%2010%60.%5Cn%5CnAll%20your%20%60MessageAdded%60%20handlers%20are%20guaranteed%20to%20be%20finished%20before%20the%20next%20message%20is%20added.%5Cn%5CnThe%20custom%20code%20runs%20within%20an%20iframe%2C%20and%20you%20can%20show%20the%20iframe%20with%20%60oc.window.show%28%29%60.%20This%20is%20useful%20if%20you%20want%20to%20create%20a%20custom%20interface.%20You%20can%20add%20stuff%20to%20your%20interface%20by%20just%20editing%2Fadding-to%20the%20HTML%20document%2C%20like%20so%3A%5Cn%60%60%60js%5Cndocument.body.innerHTML%20%3D%20%5C%22stuff%20you%20want%20to%20add%5C%22%3B%5Cn%60%60%60%5CnYou%20can%20hide%20the%20window%20with%20%60oc.window.hide%28%29%60.%5Cn%5CnHere%27s%20the%20full%20set%20of%20properties%20on%20the%20%60oc%60%20object%3A%5Cn%20%20%2a%20character%5Cn%20%20%20%20%2a%20name%5Cn%20%20%20%20%2a%20avatar%5Cn%20%20%20%20%20%20%2a%20url%20-%20image%20url%5Cn%20%20%20%20%20%20%2a%20size%20-%20default%3D1%5Cn%20%20%20%20%20%20%2a%20shape%20-%20%5C%22circle%5C%22%20or%20%5C%22square%5C%22%20or%20%5C%22portrait%5C%22%20%5Cn%20%20%2a%20thread%5Cn%20%20%20%20%2a%20messages%20-%20an%20%2a%2aarray%2a%2a%20of%20messages%2C%20where%20%2a%2aeach%20message%2a%2a%20has%3A%5Cn%20%20%20%20%20%20%2a%20content%20-%20the%20message%20text%20-%20it%20can%20include%20HTML%2C%20and%20is%20rendered%20as%20markdown%20by%20default%20%28see%20%60oc.messageRenderingPipeline%60%29%5Cn%20%20%20%20%20%20%2a%20author%5Cn%20%20%20%20%20%20%2a%20name%5Cn%20%20%20%20%20%20%2a%20hiddenFrom%20-%20array%20with%20%5C%22user%5C%22%20or%20%5C%22ai%5C%22%20or%20both%20or%20neither%5Cn%20%20%20%20%20%20%2a%20expectsReply%20-%20boolean%20%28will%20bot%20reply%20to%20this%20message%3F%29%5Cn%20%20%20%20%20%20%2a%20customData%20-%20message-specific%20custom%20data%20storage%5Cn%20%20%20%20%20%20%2a%20avatar%20%3D%20%7Burl%2C%20size%2C%20shape%7D%20-%20message-specific%20avatar%20%28overrides%20default%29%5Cn%20%20%20%20%20%20%2a%20wrapperStyle%20-%20css%20for%20the%20%5C%22message%20bubble%5C%22%20-%20e.g.%20%5C%22background%3Awhite%3B%20border-radius%3A10px%3B%5C%22%5Cn%20%20%20%20%20%20%2a%20scene%20-%20most%20recent%20message%20with%20a%20%60scene%60%20sets%20the%20background%2Fmusic%5Cn%20%20%20%20%20%20%20%20%2a%20background%5Cn%20%20%20%20%20%20%20%20%20%20%2a%20url%20-%20image%20or%20video%20url%5Cn%20%20%20%20%20%20%20%20%20%20%2a%20filter%20-%20css%20filter%20-%20e.g.%20%60hue-rotate%2890deg%29%3B%20blur%285px%29%60%5Cn%20%20%20%20%20%20%20%20%2a%20music%5Cn%20%20%20%20%20%20%20%20%20%20%2a%20url%20-%20audio%20url%20%28also%20supports%20video%20urls%29%5Cn%20%20%20%20%20%20%20%20%20%20%2a%20volume%20-%20between%200%20and%201%5Cn%20%20%20%20%2a%20userCharacter%5Cn%20%20%20%20%20%20%2a%20name%5Cn%20%20%20%20%20%20%2a%20avatar%20%3D%20%7Burl%2C%20size%2C%20shape%7D%5Cn%20%20%20%20%2a%20customData%20-%20thread-specific%20custom%20data%20storage%5Cn%20%20%2a%20messageRenderingPipeline%5Cn%20%20%2a%20window%20%3D%20%7Bshow%2C%20hide%7D%22%2C%22reminderMessage%22%3A%22%5BAI%5D%3A%20%28Thought%3A%20I%20should%20almost%20always%20use%20%60oc.getChatCompletion%60%20to%20do%20message%20edits%2C%20like%20in%20the%20above%20%5C%22include%20more%20emojis%5C%22%20example%20%28%60await%20oc.getChatCompletion%28%7Bmessages%3A%20%5B%7Bauthor%3A%5C%22user%5C%22%2C%20content%3A%5C%22...%5C%22%7D%5D%7D%29%60%29.%20It%20prompts%20an%20LLM%20to%20do%20the%20editing%2C%20so%20it%20can%20intelligently%20do%20many%20things%20that%20would%20be%20hard%20to%20implement%20using%20regular%20JavaScript%20code.%20Use%20it%20as%20a%20general%20%5C%22text%20transformation%2Fediting%2Fsummarization%2Fetc%5C%22%20tool.%20This%20is%20much%20better%20than%20using%20replace%2FreplaceAll%20unless%20it%20is%20a%20fairly%20simple%20task%20for%20a%20regex%20replace.%29%22%2C%22modelName%22%3A%22good%22%2C%22fitMessagesInContextMethod%22%3A%22summarizeOld%22%2C%22associativeMemoryMethod%22%3A%22none%22%2C%22associativeMemoryEmbeddingModelName%22%3A%22default%22%2C%22temperature%22%3A0.7%2C%22customCode%22%3A%22%22%2C%22initialMessages%22%3A%5B%7B%22author%22%3A%22system%22%2C%22content%22%3A%22This%20character%20uses%20the%20%5Bcustom%20code%20docs%5D%28https%3A%2F%2Fgithub.com%2Fjosephrocca%2FOpenCharacters%2Fblob%2Fmain%2Fdocs%2Fcustom-code.md%29%20and%20tries%20to%20help%20you%20write%20custom%20code.%20It%20will%20probably%20make%20lots%20of%20mistakes%20and%20in%20general%20just%20do%20silly%20things.%20You%20should%20definitely%20%2a%2aswitch%20the%20model%20to%20GPT-4%2a%2a%20if%20you%20can%20afford%20it%20-%20it%27s%20%2a%2amuch%2a%2a%20smarter.%22%2C%22hiddenFrom%22%3A%5B%22ai%22%5D%7D%5D%2C%22avatar%22%3A%7B%22url%22%3A%22https%3A%2F%2Fi.imgur.com%2FZ8NL9u6.jpg%22%2C%22size%22%3A1%2C%22shape%22%3A%22square%22%7D%2C%22scene%22%3A%7B%22background%22%3A%7B%22url%22%3A%22%22%7D%2C%22music%22%3A%7B%22url%22%3A%22%22%7D%7D%2C%22userCharacter%22%3A%7B%22avatar%22%3A%7B%7D%7D%2C%22streamingResponse%22%3Afalse%7D%7D`,
        ];
        for(let i = 0; i < starterCharacters.length; i++) {
          // convert URL format to object:
          if(typeof starterCharacters[i] === "string") {
            starterCharacters[i] = JSON.parse(decodeURIComponent(starterCharacters[i].split("#")[1])).addCharacter;
          }
          starterCharacters[i].id = null;
        }


        $.starterCharacterList.innerHTML = starterCharacters.map(character => createCharacterCardHtml(upgradeCharacterFromOldVersion(character))).join("");
        $.starterCharacterList.querySelectorAll(".character").forEach((characterEl, i) => {
          characterEl.addEventListener("click", async function(e) {
            let character = starterCharacters[i];
            const result = await characterDetailsPrompt(character);
            if(!result) return;
            const characterObj = await addCharacter(result);
            await createNewThreadWithCharacterId(characterObj.id);
          }, {passive: true});
        });

        $.characterFoldersList.querySelectorAll(".characterFolder").forEach(characterFolderEl => {
          characterFolderEl.addEventListener("click", async function(e) {
            e.stopPropagation();
            $.characterFoldersList.dataset.currentFolderPath = characterFolderEl.dataset.folderPath;
            await renderCharacterList();
          }, {passive: true});
        });

        $.characterFoldersList.querySelectorAll(".editFolderName").forEach(btn => {
          btn.addEventListener("click", async function(e) {
            e.stopPropagation();
            const folderPath = btn.closest(".characterFolder").dataset.folderPath;
            
            let label;
            if(folderPath.split("/").length === 1) {
              label = `Edit the name of this folder:`;
            } else {
              label = `Edit the name of this folder by changing '${folderPath.split("/").at(-1)}' to something else, or move all items inside the '${folderPath.split("/").at(-1)}' folder to a new location by editing the whole folder path:`;
            }
            let characterFolderData = (await db.misc.get("characterFolderData"))?.value || {};

            let result = await prompt2({
              newFolderPath: {type:"textLine", label, defaultValue:folderPath},
              emoji: {type:"textLine", label:"Folder emoji or image URL:", defaultValue:characterFolderData[folderPath]?.emoji || ""},
            });
            if(!result) return;

            if(result.emoji) {
              if(!characterFolderData[folderPath]) characterFolderData[folderPath] = {};
              characterFolderData[folderPath].emoji = result.emoji;
            }

            await db.misc.put({key:"characterFolderData", value:characterFolderData});

            let newFolderPath = result.newFolderPath.trim().replace(/^\//, "").replace(/\/$/, "").trim();
            // each character has a folderPath property, which is a string like "folder1/folder2/folder3" or just "" (empty string) if it's in the root folder
            await db.characters.toCollection().modify(function(character) {
              // we need to move all characters that start with folderPath to newFolderPath
              if(character.folderPath === folderPath) {
                character.folderPath = newFolderPath;
              } else if(character.folderPath.startsWith(folderPath+"/")) {
                character.folderPath = newFolderPath + character.folderPath.slice(folderPath.length);
              }
            });
            await renderCharacterList();
            await incrementOperationsSinceLastExport();
          }, {passive: true});
        });

        // Add an onclick handler to each character which starts a new thread with that character.
        $.characterList.querySelectorAll(".character").forEach(characterEl => {

          // copy link to clipboard and show a little notification at top of page if they click the share button
          characterEl.querySelector(".share").addEventListener("click", async function(e) {
            e.stopPropagation();
            const characterId = parseInt(characterEl.dataset.characterId);
            const character = (await db.characters.where("id").equals(characterId).toArray())[0];
            delete character.id;
            delete character.creationTime;
            delete character.lastMessageTime;
            character.folderName = "";
            for(let key in character.customData) {
              if(key === "PUBLIC") continue; // data within oc.character.customData.PUBLIC is shared within share links - all other data is not
              delete character.customData[key];
            }
            let warnThatAvatarUrlWasRemoved = false;
            let avatarUrl = character.avatar.url;
            if(avatarUrl && avatarUrl.startsWith("data:")) {
              character.avatar.url = "";
              warnThatAvatarUrlWasRemoved = true;
            }
            let urlHashData = encodeURIComponent(JSON.stringify({addCharacter:character})).replace(/[!'()*]/g, function(c) {
              return '%' + c.charCodeAt(0).toString(16); // since encodeURIComponent doesn't encode some characters (like parentheses) and I think they mess up markdown links
            });
            const url = `${window.location.origin+window.location.pathname}#${urlHashData}`;
            await navigator.clipboard.writeText(url);
            $.topNotificationContent.innerHTML = `Copied character link to clipboard!`;
            showEl($.topNotification);

            if(warnThatAvatarUrlWasRemoved) {
              await new Promise(resolve => setTimeout(resolve, 1000));
              let result = await prompt2({
                message: {type:"none", "html":`<p style="margin:0;">All character data is embedded within OpenCharacters share links, but this character's avatar image was stored as text (using a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs" target="_blank">'data' URL</a>), and that would result in a huge share URL, so the avatar image was removed from the share link.<br><br>If you click 'Open avatar in new tab', then you can right-click/long-press it and save the avatar image, and then upload it to catbox.moe or a similar website, and then edit your character and replacing the 'data:' avatar URL with the new 'https:' URL that you got from the image hosting service. That way your share link will include the avatar image.</p>`},
              }, {cancelButtonText:"Share charater without avatar", submitButtonText:"Open avatar in new tab"});
              if(result !== null) {
                let blobUrl = await dataUrlToCachedBlobUrl(avatarUrl);
                window.open(blobUrl, "_blank");
              }
            }

            setTimeout(() => hideEl($.topNotification), 3000);
          }, {passive: true});

          // edit character details if they click the edit button
          characterEl.querySelector(".edit").addEventListener("click", async function(e) {
            e.stopPropagation();
            const characterId = parseInt(characterEl.dataset.characterId);
            await editCharacterById(characterId);
          }, {passive: true});

          // duplicate
          characterEl.querySelector(".duplicate").addEventListener("click", async function(e) {
            e.stopPropagation();
            const originalCharacterId = parseInt(characterEl.dataset.characterId);
            let originalCharacter = await db.characters.get(originalCharacterId);
            const result = await characterDetailsPrompt(originalCharacter);
            if(!result) return;
            const character = await addCharacter(result);
            await createNewThreadWithCharacterId(character.id);
          }, {passive: true});

          // delete character if they click the delete button
          characterEl.querySelector(".delete").addEventListener("click", async function(e) {
            e.stopPropagation();
            const characterId = parseInt(characterEl.dataset.characterId);
            if(confirm(`Are you sure you want to delete this character? This will delete ALL THREADS associated with this character.`)) {
              await safelyDeleteCharacterById(characterId);
              await renderCharacterList();
              await renderThreadList();
              await incrementOperationsSinceLastExport();
            }
          }, {passive: true});

          characterEl.querySelector(".changeFolderPath").addEventListener("click", async function(e) {
            e.stopPropagation();
            const characterId = parseInt(characterEl.dataset.characterId);
            let character = await db.characters.get(characterId);
            let newFolderPath = prompt("Enter new folder path for this character. You can add subfolders with forward-slashes like 'folder/subfolder/...'", character.folderPath);
            if(newFolderPath !== null) {
              newFolderPath = newFolderPath.trim().replace(/^\//, "").replace(/\/$/, "").trim();
              await db.characters.update(characterId, { folderPath: newFolderPath });
              await renderCharacterList();
              await incrementOperationsSinceLastExport();
            }
          }, {passive: true});
          
          // create a new thread if they click a character
          characterEl.addEventListener("click", async function() {
            let loadingModal = createLoadingModal("Loading...");
            let characterId = parseInt(characterEl.dataset.characterId);
            await createNewThreadWithCharacterId(characterId);
            loadingModal.delete();
          }, {passive: true});
        });
      }

      $.newCharacterButton.addEventListener("click", async function() {
        const result = await characterDetailsPrompt();
        if(!result) return;
        const character = await addCharacter(result);
        await createNewThreadWithCharacterId(character.id);
      }, {passive: true});

      // $.newFolderCharacterButton.addEventListener("click", async function() {
      //   let folderName = prompt("Folder name:");
      //   if(!folderName) return;
      // }, {passive: true});

      async function safelyDeleteCharacterById(characterId) {
        let character = await db.characters.get(characterId);
        await db.characters.delete(characterId);
        // delete all threads and messages associated with this character
        const threads = await db.threads.where("characterId").equals(characterId).toArray();
        for(let thread of threads) {
          await safelyDeleteThreadById(thread.id)
        }


        // for any message that has this character's id as its message.characterId, set message.characterId to the thread character id and embed the name and avatar of the character in the message
        // messages can have non-thread-character ids because of the `/ai @CharName#123` command
        let threadIdToCharacterId = {};
        let allThreads = await db.threads.toArray();
        for(let thread of allThreads) {
          threadIdToCharacterId[thread.id] = thread.characterId;
        }
        await db.messages.toCollection().modify(function(message) {
          if(message.characterId === characterId) {
            message.characterId = threadIdToCharacterId[message.threadId];
            message.name = character.name;
            message.avatar.url = character.avatar.url;
          }
        });
      }

      window.safelyDeleteThreadById = async function safelyDeleteThreadById(threadId) {
        // let thread = await db.threads.get(threadId);
        await db.threads.delete(threadId);
        let messageIds = await db.messages.where("threadId").equals(threadId).toArray().then(arr => arr.map(m => m.id));
        await safelyDeleteMessagesByIds(messageIds);
        // delete messages, summaries, memories, and usagestats for this thread:
        await db.summaries.where("threadId").equals(threadId).delete();
        await db.memories.where("threadId").equals(threadId).delete();
        await db.usageStats.where("threadId").equals(threadId).delete();
      }

      // this function deletes and "cleans up references" to messages - e.g. ids in `message.messageIdsUsed`
      async function safelyDeleteMessagesByIds(idsToDelete, opts={}) {
        // IMPORTANT: If you make changes here, ensure it it doesn't break the 'undo deletion' feature for messages.
        // It's okay (for now, at least) if diagnostic information (like messageIdsUsed), but 'critical' info that is deleted should be undone.

        let messagesTable;
        if(opts.tx) messagesTable = opts.tx.table("messages");
        else messagesTable = db.messages;

        if(idsToDelete.length === 0) return;
        // get thread id:
        let threadId = await messagesTable.get(idsToDelete[0]).then(m => m.threadId);
        // delete messages:
        await messagesTable.where("id").anyOf(idsToDelete).delete();
        // clean up references to the deleted messages:
        let remainingMessages = await messagesTable.where("threadId").equals(threadId).toArray();
        
        for(let m of remainingMessages) {
          let changed = false;
          
          // if the deleted messages were reference by other messages via messageIdsUsed, we need to change those references to -1
          let originalNumMessageIdsUsed = m.messageIdsUsed.length;
          m.messageIdsUsed = m.messageIdsUsed.map(id => idsToDelete.includes(id) ? -1 : id);
          if(m.messageIdsUsed.length !== originalNumMessageIdsUsed) {
            changed = true;
          }

          if(changed) {
            await messagesTable.put(m);
          }
        }
      }

      async function editCharacterById(characterId) {
        const character = await db.characters.get(characterId);
        const result = await characterDetailsPrompt(character);
        if(!result) return;

        await db.characters.update(characterId, result);

        if(result.customCode?.trim() && result.customCode !== character.customCode) {
          // get all threads with this character and delete custom code iframes for them if they exist
          const threads = await db.threads.where("characterId").equals(characterId).toArray();
          for(let thread of threads) {
            if(customCodeIframes[thread.id]) {
              delete customCodeIframes[thread.id];
            }
          }
          // create new iframe for currently-active thread, if there is one
          let threadId = activeThreadId;
          if(threadId !== null) {
            await createNewCustomCodeIframeForThread(threadId);
          }
          if($.messageFeed.offsetWidth > 0) {
            await updateThreadScene();
          }
        }

        // Note: we don't need to recompute memory embeddings if they change textEmbeddingModelName because textEmbeddingModelName is now thread-specific (inherited from character at time of creation)

        await renderCharacterList();
        await renderThreadList();
        await incrementOperationsSinceLastExport();
      }


      const defaultThreadName = "Unnamed Thread";
      const defaultSystemName = "System";

      async function createNewThreadWithCharacterId(characterId) {
        let folderPath = $.chatThreads.dataset.currentFolderPath;
        const thread = await addThread({name:defaultThreadName, characterId, folderPath});

        await renderThreadList();
        
        const character = await db.characters.get(characterId);
        let userCharacter = await getUserCharacterObj(thread.id);

        let userName = thread.userCharacter.name ?? userCharacter.name;
        let characterName = thread.character.name ?? character.name;

        // add initial messages
        for(let m of character.initialMessages) {
          let characterId;
          if(m.author === "user") characterId = -1;
          if(m.author === "system") characterId = -2;
          if(m.author === "ai") characterId = character.id;
          if(characterId === undefined) alert("Error in createNewThreadWithCharacterId - invalid message author?");

          let data = {threadId:thread.id, message:m.content, characterId};
          
          data.expectsReply = m.expectsReply;

          if(m.hiddenFrom) data.hiddenFrom = m.hiddenFrom;
          
          data.message = data.message.replaceAll("{{user}}", userName);
          data.message = data.message.replaceAll("{{char}}", characterName);

          let messageObj = createMessageObj(data);
          await addMessageToDb(messageObj)
        }

        await renderThreadList();
        await showThread(thread.id);
        await incrementOperationsSinceLastExport();
      }
      
      async function updateUIForModel(modelName) {
        if (modelSupportsMultipleResponses(modelName)) {
          console.log(`Model ${modelName} supports multiple replies.`);
          $.repliesPerSendMenu.style.display = "initial"; 
        } else {
          console.log(`Model ${modelName} does not support multiple replies.`);
          $.repliesPerSendMenu.style.display = "none";
          $.repliesPerSendMenu.value = 1;
        }
      }

      async function threadModelSelectorChanged() {
        console.log("Thread model changed.");
        let threadId = activeThreadId;
        let thread = await db.threads.get(threadId);
        let modelName = $.threadModelSelector.value;
        await db.threads.update(threadId, {modelName});
        await renderThreadList();
        await updateUIForModel(modelName);
      }

      $.threadModelSelector.addEventListener("change", threadModelSelectorChanged, {passive: true});

      $.threadSettingsButton.addEventListener("click", async function() {
        let threadId = activeThreadId;
        let thread = await db.threads.get(threadId);

        const result = await prompt2({
        //     modelName: { label: "Model name:", type:"select", options:[availableModels.filter(m => m.type === "completion" || m.type === "chat-completion").map(m => ({value:m.name, content:m.shortLabel ?? m.name}))], defaultValue: thread.modelName },
        //     fitMessagesInContextMethod: { hidden:true, label: "Method for fitting messages within model's context limit.", type:"select", options:[{value:"dropOld", content:"drop oldest messages"}, {value:"summarizeOld", content:"summarize oldest messages"}], defaultValue: defaultValues.fitMessagesInContextMethod },
        //     autoGenerateMemories: { hidden:true, show:d=>d.fitMessagesInContextMethod==="summarizeOld", label: "Persistent, 'infinite' character memory:", infoTooltip:"This increases the cost by up to 2x and makes responses a bit slower, but gives the character the ability to 'save' memories, and 'recall' them when they're relevant. Currently this only works within individual threads - i.e. characters can't recall details from *other* threads.", type:"select", options:[{value:"none", content:"disabled"}, {value:"v1", content:"enabled"}], defaultValue: defaultValues.associativeMemoryMethod },
        //     textEmbeddingModelName: { hidden:true, label: "Memory embedding model:", infoTooltip:"Yep, there's currently only one option for this. Will add more in the future. It's what converts each memory (text) into a list of numbers that can be efficiently used for search/similarity/lookup.", type:"select", options:[...broadlyAvailableModels.filter(m => m.type === "text-embedding").map(m => ({value:m.name, content:m.name}))], defaultValue: defaultValues.textEmbeddingModelName },
          tokenLimit: {hidden:false, label:"Token limit:", type:"textNumber", step:1000, infoTooltip:"Approximate length that thread will be allowed to grow before it's summarized. If set to zero, the model's maximum token limit will be used.", defaultValue:thread.tokenLimit},
        }, {submitButtonText:"save"});
        if(!result) return;

        await db.threads.update(threadId, {tokenLimit:result.tokenLimit});
      //   ## todo: update that code that re-computes all embeddings if they change the embedding model- that's not needed at the character-level anymore, but we need it here at the thread-level edits.

      }, {passive: true});

      let threadLoadingModal;
      let activeThreadId = null; // <-- used globally
      let activeCharacterId = null; // <-- used globally
      async function showThread(threadId) {
        let thread = await db.threads.get(threadId);

        if(thread.currentSummaryHashChain === undefined) {
          let { instructionHashChain } = await computeAndSaveThreadSummaryIfNeeded({threadId, exitOnFirstHashMissAndReturnHashChain:true});
          thread.currentSummaryHashChain = instructionHashChain;
          await db.threads.update(threadId, {currentSummaryHashChain:instructionHashChain});
        }

        activeThreadId = threadId;
        activeCharacterId = thread.characterId;

        $.threadModelSelector.value = thread.modelName;
        await updateUIForModel(thread.modelName);

        let characterObj = await db.characters.get(thread.characterId);

        updateFavicon(characterObj.avatar.url);
        document.title = `${characterObj.name} - ${thread.name} - OpenCharacters`;

        $.chatThreads.dataset.currentFolderPath = thread.folderPath;
        await renderThreadList();

        // thread could be past the "show more threads" button, so we render all threads if so:
        let threadEl = $.chatThreads.querySelector(`.thread[data-thread-id="${threadId}"]`);
        if(!threadEl) {
          await renderThreadList({maxShownThreads:Infinity});
        }
        threadEl = $.chatThreads.querySelector(`.thread[data-thread-id="${threadId}"]`);

        $.messageFeed.innerHTML = "";

        $.musicPlayer.pause();

        if(threadLoadingModal) {
          threadLoadingModal.delete();
        }
        
        // to prevent flash for fast-loading threads:
        let loadingModalCreationTimeout = setTimeout(() => {
          threadLoadingModal = createLoadingModal("Loading...", $.middleColumn);
        }, 200);
        
        document.querySelectorAll("#chatThreads .thread").forEach(el => el.classList.remove("selected"));
        threadEl.classList.add("selected");
        
        document.querySelectorAll("#middleColumn > .middleColumnScreen").forEach(el => hideEl(el));
        showEl($.chatInterface);

        if(isMobile) {
          closeLeftColumn();
        }

        // Check to see whether we can actually use the current model -- this can become an issue if
        // a user loads an old thread with a model that's no longer supported, or creates a new thread
        // from a character whose default model is no longer supported
        let modelTest = getCharacterModel(thread.modelName);
        if (modelTest === undefined) {
          alert("This thread is configured to use the model '" + thread.modelName + "', which is no longer supported. Switching to the '" + openAIGoodCharacterModel + "' model. If this isn't what you want, please select a different model from the menu. If you see this message when you create a new thread with a custom character, you can fix it by editing the custom character and choosing a new default model.");
          thread.modelName = openAIGoodCharacterModel;
          $.threadModelSelector.value = thread.modelName;
          await threadModelSelectorChanged(); // this triggers the necessary db update and rerenders
        } else {
          $.threadModelSelector.value = thread.modelName;
          await updateUIForModel(thread.modelName);
        }

        // thus must come before rendering the message feed because we may need to render the messages with `oc.messageRenderingPipeline`
        if(!customCodeIframes[threadId] && characterObj.customCode.trim()) {
          await createNewCustomCodeIframeForThread(threadId); // this adds iframe as here: customCodeIframes[threadId]
        }

        await renderMessageFeed(threadId);

        await db.threads.where({id:threadId}).modify({lastViewTime:Date.now()});

        await updateCustomCodeIframeVisibility();

        await renderShortcutButtons(thread);

        $.messageInput.value = thread.unsentMessageText;

        clearTimeout(loadingModalCreationTimeout);
        if(threadLoadingModal) threadLoadingModal.delete();

      }

      async function renderShortcutButtons(thread=null) {
        if(!thread) {
          thread = await db.threads.get(activeThreadId);
        }
        shortcutButtonsCtn.innerHTML = "";
        let buttonWrapper = htmlToElement(`<div style="width:max-content;"></div>`);
        if(thread.shortcutButtons.length > 0) {
          shortcutButtonsCtn.appendChild(buttonWrapper);
          for(let shortcut of thread.shortcutButtons) {
            let shortcutBtn = htmlToElement(`<button>${shortcut.name}</button>`);
            buttonWrapper.appendChild(shortcutBtn);
            shortcutBtn.addEventListener("click", async function() {
              if(shortcut.type === "message") {
                if(shortcut.insertionType === "replace") {
                  $.messageInput.value = shortcut.message;
                } else if(shortcut.insertionType === "append") {
                  $.messageInput.value += shortcut.message;
                } else if(shortcut.insertionType === "prepend") {
                  $.messageInput.value = shortcut.message + $.messageInput.value;
                }
                if(shortcut.autoSend) {
                  await sendButtonClickHandler();
                }
              }
            }, {passive: true});
          }
       }
       if(shortcutButtonsCtn.innerHTML !== "") {
          let bulkEditButton = htmlToElement(`<button>‚úèÔ∏è</button>`);
          bulkEditButton.addEventListener("click", async function() {
            let shortcutsInTextFormat = thread.shortcutButtons.map(s => `@name=${s.name}\n@message=${s.message}\n@insertionType=${s.insertionType}\n@autoSend=${s.autoSend ? "yes" : "no"}`).join("\n\n");
            let result = await prompt2({
              shortcutsInTextFormat: {label: "Bulk-edit shortcuts:", type: "text", defaultValue:shortcutsInTextFormat, height:"fit-content"},
            });
            if(!result) return;

            // parse shortcuts:
            const regex = /(?:^|\n+)@name=(.*?)\n@message=(.*?)\n@insertionType=(replace|append|prepend)\n@autoSend=(yes|no)/gs;
            let matches;
            let parsedShortcuts = [];

            while((matches = regex.exec(result.shortcutsInTextFormat))) {
              let shortcut = {
                name: matches[1],
                message: matches[2],
                insertionType: matches[3],
                autoSend: matches[4] === 'yes',
                type: "message",
              };
              parsedShortcuts.push(shortcut);
            }
            await db.threads.where({id:thread.id}).modify({shortcutButtons:parsedShortcuts});
            thread.shortcutButtons = parsedShortcuts;
            await renderShortcutButtons(thread);
          }, {passive: true});
          buttonWrapper.insertBefore(bulkEditButton, buttonWrapper.firstChild);
        }
      }

      // NOTE: spaces aren't actually allowed by OpenAI - I replace them with underscores in prepareMessagesForBot
      // If you change this, update stuff in prepareMessagesForBot too
      const characterNameValidationPattern = "^[A-Za-z0-9_\\- ]{1,64}$"; // needed due to OpenAI API limitations

      async function characterDetailsPrompt(defaultValues={}, opts={}) {
        defaultValues = structuredClone(defaultValues);

        let existingCharacter;
        if(opts.editingExistingCharacter) {
          existingCharacter = await db.characters.get({uuid:defaultValues.uuid});
        }
        
        let initialMessagesText;
        if(defaultValues.initialMessages) initialMessagesText = generateTextFormatFromMessages(defaultValues.initialMessages);
        else initialMessagesText = "";

        let loreBookUrlsText;
        if(defaultValues.loreBookUrls) loreBookUrlsText = defaultValues.loreBookUrls.join("\n");
        else loreBookUrlsText = "";

        const result = await prompt2({
          header: { html: opts.editingExistingCharacter ? `<div style="border-radius:3px;font-size: 0.8rem;padding: 0.5rem;border: 1px solid var(--border-color);">You're currently <b>editing</b> an existing character named '${existingCharacter.name}'.</div>` : "", type:"none" },
          name: { label: "ü™™ Character name:", type:"textLine", placeholder: "Sammy", defaultValue: defaultValues.name || "", validationPattern:characterNameValidationPattern },
          roleInstruction: { label: `üé≠ Instruction/role/personality (<a href='${projectDocsURL}/instruction-and-reminder.md' target='_blank'>advanced</a>)`, infoTooltip:"This message defines the personality or 'role' that the AI will take during the chat. Every request to the API will include this as the first message. If you later decide to edit this, all existing and new threads will be immediately updated. This message does not get summarized by the summarization algorithm - it will always be present as the first message.", type:"text", height:"fit-content", placeholder: "You are Sammy, an opinionated, friendly assistant. You have opinions.", defaultValue: defaultValues.roleInstruction || "" },
          reminderMessage: { label: `üí≠ Reminder message - an invisible system message that is placed before every AI response (<a href='${projectDocsURL}/instruction-and-reminder.md' target='_blank'>advanced</a>)`, infoTooltip:"This message is inserted as a reminder at the end of the chat right before each AI response. This will always be the last/most-recent message that the AI sees when writing its response. If you later decide to edit this, all existing and new threads will be immediately updated. This message is not seen/summarized by the summarization algorithm - it will always be present as the final message.", height:"fit-content", minHeight:"3rem", type:"text", placeholder: "Stay in character! Sammy will now respond without breaking character.", defaultValue: defaultValues.reminderMessage || "" },
          initialMessagesText: { label: `üí¨ Initial chat messages (optional). Useful for extra alignment to character. Follow the format explained <a href='${projectDocsURL}/initial-messages.md' target='blank'>here</a>.`, infoTooltip:"During the initialization of every new thread with this character, these messages will be created and placed at the start of the thread. Note that the summarization algorithm will eventually summarize these messages - so they won't stay around forever (unlike the instruction and reminder messages, which *do* stay around forever). Also note that if you edit the initial messages, only *new* threads will have the updated initial messages. In other words, once a chat thread has been created, the initial messages that are added to a thread during init 'belong' to that thread, not to the character.", type:"text", height:"fit-content", placeholder: "[USER]: Hey Sammy, do you have opinions?\n[SYSTEM]: The next message will include an emoji.\n[AI]: Yes! I have lots of opinions. ü§î\n[SYSTEM; hiddenFrom=ai]: The AI can't see this message. Useful for user instructions.", defaultValue: initialMessagesText ?? "" },
          avatarUrl: { label: "üë§ Avatar URL (png/jpg/etc):", type:"textLine", placeholder: "(optional)", defaultValue: defaultValues.avatar?.url || "" },
          streamingResponse: { label: "Use streaming for bot replies", infoTooltip: "If checked, the bot's replies will be displayed a word or so at a time as they arrive. This looks cool, but slows things down and uses more network bandwidth. Streaming won't be used if you generate more than one reply at once.", type:"checkbox", defaultValue:defaultValues.streamingResponse},
          modelName: { hidden:true, label: "ü§ñ Model name:", infoTooltip:"", type:"select", options:[{content:"GOOD/CHEAP", value:"good"}, {content:"GREAT/EXPENSIVE", value:"great"}, ...broadlyAvailableModels.filter(m => m.type === "completion" || m.type === "chat-completion").map(m => ({value:m.name, content:getMenuLabelForModel(m)}))], defaultValue: defaultValues.modelName || "good" },
          maxTokensPerMessage: { hidden:true, label: "üìè Max tokens per message:", infoTooltip:"This can be used to limit the length of the AI's responses. A 'token' is basically a word - 500 tokens is about 400 words in most tokenizers. Leave this blank to allow unlimited tokens to be generated per message. Note that you can also control the length of the AI's responses in the reminder message by saying something like 'Your response should be at most 3 sentences' or whatever.", type:"textLine", defaultValue:defaultValues.maxTokensPerMessage || "" },
          fitMessagesInContextMethod: { hidden:true, label: "Method for fitting messages within model's context limit.", type:"select", options:[{value:"dropOld", content:"drop oldest messages"}, {value:"summarizeOld", content:"summarize oldest messages"}], defaultValue: defaultValues.fitMessagesInContextMethod ?? "summarizeOld" },
          memoryLorePlacementMethod: { hidden:true, label: "Method for placing memory/lore information within the prompt sent to the model.", infoTooltip: "This can have effects on the behavior of certain models. If you don't use memories or lore, it has no effect at all. Try different placements. One note: if you're using a model that has reduced prices for cached tokens in prompts, placing the memories at the end of the conversation can significantly lower costs.", type:"select", options:[{value:"startOfPrompt", content:"at the very start of the prompt"}, {value:"startOfConversation", content:"at the start of the conversation"}, {value:"endOfConversation", content:"at the end of the conversation"}], defaultValue: defaultValues.memoryLorePlacementMethod ?? "startOfConversation" },
          smartQuoteMethod: { hidden:true, label: "Method for handling quotation marks in user messages and bot replies.", type:"select", options:[{value:"noChange", content:"unchanged"}, {value:"smartQuotes", content:"Convert plain quotes to curly quotes"}, {value:"plainQuotes", content:"Convert curly quotes to plain quotes"}], defaultValue: defaultValues.smartQuoteMethod ?? "smartQuotes" },
          deleteEmoji: {hidden:true, label: "Remove emoji from messages", type: "checkbox", defaultValue: defaultValues.deleteEmoji || false},
          textEmbeddingModelName: { hidden:true, label: "Text embedding model:", infoTooltip:"It's what converts each memory/lore entry (text) into a bunch of numbers that can be efficiently used for search/similarity/lookup.", type:"select", options:[{content: "default", value: "default"}, ...broadlyAvailableModels.filter(m => m.type === "text-embedding").map(m => ({value:m.name, content:m.shortLabel + " ($" + m.tokenPricing.prompt + ")"}))], defaultValue: defaultValues.textEmbeddingModelName ?? "default" },
          autoGenerateMemories: { hidden:true, show:d=>d.fitMessagesInContextMethod==="summarizeOld", label: "üíΩ Auto-generated character memories:", infoTooltip:"You can use /mem and /lore commands to manually add memories and lore. If you enable this feature, memories will be created by the character during each summarization step. This increases the cost a bit (maybe +20%) and makes responses a bit slower, but gives the character the ability to 'save' memories, and 'recall' them when they're relevant. Currently this only works within individual threads - i.e. characters can't recall details from *other* threads. You can manually copy memories and lore over into a new thread if needed.", type:"select", options:[{value:"none", content:"disabled"}, {value:"v1", content:"enabled"}], defaultValue: defaultValues.autoGenerateMemories ?? "v1" },
          avatarSize: { hidden:true, label: "Avatar size, as a multiple of the default size.", type:"textLine", defaultValue: defaultValues.avatar?.size ?? "1" },
          avatarShape: { hidden:true, label: "Avatar shape:", type:"select", options:[{value:"square"}, {value:"circle"}, {value:"portrait"}], defaultValue: defaultValues.avatar?.shape ?? "square" },
          sceneBackgroundUrl: { hidden:true, label: "üñºÔ∏è Chat background image/video URL (jpg, webp, webm, mp4, etc.)", type:"textLine", defaultValue: defaultValues.scene?.background?.url ?? "" },
          sceneMusicUrl: { hidden:true, label: "üéµ Chat background music/audio URL (mp3, webm, mp4, etc.)", infoTooltip:"Permission is always requested from the user before playing audio - i.e. music will not autoplay because that could annoy some users. You can use a video file for audio - the visuals will obviously not be shown.", type:"textLine", defaultValue: defaultValues.scene?.music?.url ?? "" },
          userCharacterName: { hidden:true, label: "User's name. This overrides the user's default username when chatting with this character.", type:"textLine", defaultValue: defaultValues.userCharacter?.name || "" },
          userCharacterAvatarUrl: { hidden:true, label: "User's avatar. This overrides the user's default avatar when chatting to this character.", type:"textLine", defaultValue: defaultValues.userCharacter?.avatar?.url || "" },
          // initialThreadMemories: { hidden:true, show:d=>d.autoGenerateMemories!=="none", label: "Initial thread-specific memories. The character will create memories based on the chat, but you can add some starter memories/lore here.", infoTooltip:"Manually-written memories can be used as 'dynamic' instruction/role/reminders that engage when relevant. This saves you from having to pack too much text into your instruction/reminder, which will 'eat up' your context, which means the AI will be able to see fewer recent messages, and summarization will have to be done more often.", type:"text", defaultValue: defaultValues.textEmbeddingModelName ?? "" },
          temperature: { hidden:true, label: "üå°Ô∏è Creativity ('temperature'). Choose a value between 0 and 2. Higher values will make the output more random, while lower values will make it more focused and deterministic.", infoTooltip:"People seem to get good results between 0.7 and 1.2 - higher values may sacrifice some 'correctness' but should result in more 'imagination'. Not supported by all models.", type:"textLine", defaultValue: defaultValues.temperature ?? 0.85 },
          loreBookUrlsText: { hidden:true, height:"fit-content", cssText:"white-space:pre; font-family:monospace;", label: `üìñ Lorebook URLs - one per line. Use <a href='https://rentry.org' target='_blank'>rentry.org</a> or similar. Should be a url to the 'raw' text file, where your lore entries are separated by blank lines. For changes to propagate to <b>existing</b> threads, you need to use the <b>/lore</b> command and click the reload button. Visit <a href='${projectDocsURL}/memories-and-lore.md' target='_blank'>this page</a> to learn more.`, type:"text", height:"fit-content", defaultValue: loreBookUrlsText },
          customCode: { hidden:true, height:"fit-content", cssText:"white-space:pre; font-family:monospace;", label: `üßë‚Äçüíª Custom JavaScript code. This allows you to e.g. give your bot access to the internet. Visit <a href='${projectDocsURL}/custom-code.md' target='_blank'>this page</a> to learn more.`, type:"text", height:"fit-content", defaultValue: defaultValues.customCode ?? "" },
          systemCharacterName: { hidden:true, label: "System's name:", type:"textLine", defaultValue: defaultValues.systemCharacter?.name || "" },
          systemCharacterAvatarUrl: { hidden:true, label: "System's avatar:", type:"textLine", defaultValue: defaultValues.systemCharacter?.avatar?.url || "" },
        }, {submitButtonText: opts.submitButtonText || "save character", showHiddenInputsText: "show advanced options"});
        
        if(!result) return;
        
        result.name = result.name.trim();

        if(result.name === "") result.name = "_";
        result.name = result.name.replaceAll("#", ""); // just to be sure - a hash is used for `/ai @charName#123 <instruction>` so it's important that it's not in the name

        if(result.customCode.trim() === "") result.customCode = ""; // if the custom code box just contained whitespace, remove it
        
        if(result.maxTokensPerMessage.trim() === "") result.maxTokensPerMessage = null;
        if(result.maxTokensPerMessage) result.maxTokensPerMessage = Number(result.maxTokensPerMessage);
        

        // process prompt results back into well-formed character object:

        if(result.initialMessagesText?.trim()) {
          result.initialMessages = parseMessagesFromTextFormat(result.initialMessagesText);
          if(result.initialMessages === null) { // invalid, so just throw it all into a single message (mainly so they don't lose their work)
            result.initialMessages = [{content:result.initialMessagesText, author:"ai", hiddenFrom:[]}];
          }
        } else {
          result.initialMessages = [];
        }
        delete result.initialMessagesText;

        if(result.loreBookUrlsText?.trim()) {
          result.loreBookUrls = result.loreBookUrlsText.trim().split("\n").map(url => url.trim()).filter(url => url);
          for(let i = 0; i < result.loreBookUrls.length; i++) {
            let url = new URL(result.loreBookUrls[i]);
            if(url.hostname === "rentry.org" || url.hostname === "rentry.co") {
              url.pathname = url.pathname.replace(/\/$/, "");
              if(!url.pathname.endsWith("/raw")) {
                url.pathname += "/raw";
              }
              result.loreBookUrls[i] = url.toString();
            }
          }
        } else {
          result.loreBookUrls = [];
        }
        delete result.loreBookUrlsText;

        result.avatar = {
          url: result.avatarUrl,
          size: Number(result.avatarSize),
          shape: result.avatarShape,
        };
        delete result.avatarUrl;
        delete result.avatarSize;
        delete result.avatarShape;

        result.scene = {
          background: {
            url: result.sceneBackgroundUrl,
          },
          music: {
            url: result.sceneMusicUrl,
          },
        };
        delete result.sceneBackgroundUrl;
        delete result.sceneMusicUrl;
        
        result.temperature = Number(result.temperature);

        if(isNaN(result.temperature)) result.temperature = 0.8;

        // user character object overrides:
        result.userCharacter = {avatar:{}};
        if(result.userCharacterName.trim()) result.userCharacter.name = result.userCharacterName;
        delete result.userCharacterName;
        if(result.userCharacterAvatarUrl.trim()) result.userCharacter.avatar.url = result.userCharacterAvatarUrl;
        delete result.userCharacterAvatarUrl;
        
        // system character object overrides:
        result.systemCharacter = {avatar:{}};
        if(result.systemCharacterName.trim()) result.systemCharacter.name = result.systemCharacterName;
        delete result.systemCharacterName;
        if(result.systemCharacterAvatarUrl.trim()) result.systemCharacter.avatar.url = result.systemCharacterAvatarUrl;
        delete result.systemCharacterAvatarUrl;

        result.folderPath = defaultValues.folderPath ?? "";
        result.customData = defaultValues.customData ?? "";

        if(existingCharacter) {
          result.uuid = existingCharacter.uuid;
        } else {
          result.uuid = defaultValues.uuid ?? null;
        }

        // If it contains [AI], [SYSTEM], or [USER], but doesn't *start* with one of those, warn them that it's being treated as one big system message
        if(/(^|\s)\[(AI|SYSTEM|USER)\]:/.test(result.reminderMessage) && !/^\[(AI|SYSTEM|USER)\]:/.test(result.reminderMessage.trim())) {
          alert("It looks like you're using the advanced [AI]/[USER]/[SYSTEM] reminder message format, but your reminder message doesn't start with either [AI]: or [USER]: or [SYSTEM]:. If you want to use the advanced format, make sure your reminder message starts with [AI]: or [USER]: or [SYSTEM]:, otherwise your whole reminder message will be assumed to be one big 'SYSTEM' message (i.e. it assumes you're not using the advanced format).");
        }

        return result;
      }

      function generateTextFormatFromMessages(messages) {
        let text = '';

        messages.forEach(message => {
          const author = message.author.toUpperCase();
          let paramsObj = {};
          if(message.hiddenFrom && message.hiddenFrom.length > 0) paramsObj.hiddenFrom = message.hiddenFrom;
          // note: currently expectsReply is not supported in initial messages
          const parameters = Object.entries(paramsObj)
            .map(([key, value]) => `${key}=${value}`)
            .join('; ');

          const paramString = parameters ? `; ${parameters}` : '';
          const content = message.content.replace(/\n/g, '\n');

          text += `[${author}${paramString}]: ${content}\n`;
        });

        return text.trim();
      }

      function parseMessagesFromTextFormat(text) {
        if(!/^\[(SYSTEM|USER|AI)(?:;[\s]*[\w]+=[\w]+)*\]:/.test(text)) {
          return null;
        }
        const lines = text.split('\n');
        const messages = [];
        let currentMessage = null;

        lines.forEach(line => {
          const match = line.match(/^\[(SYSTEM|USER|AI);?(.*?)\]:\s*(.*)/);

          if(match) {
            if(currentMessage) {
              messages.push(currentMessage);
            }

            currentMessage = {
              author: match[1].toLowerCase(),
              content: match[3],
              parameters: {}
            };

            if(match[2]) {
              const params = match[2].trim().split(';');
              params.forEach(param => {
                const [key, value] = param.split('=');
                currentMessage.parameters[key.trim()] = value.trim();
              });
            }
          } else if(currentMessage) {
            currentMessage.content += '\n' + line;
          }
        });

        if (currentMessage) {
          messages.push(currentMessage);
        }

        // parse out valid parameters:
        for(let m of messages) {
          if(m.parameters.hiddenFrom) {
            if(m.parameters.hiddenFrom === "ai") m.hiddenFrom = ["ai"];
            if(m.parameters.hiddenFrom === "user") m.hiddenFrom = ["user"];
            if(m.parameters.hiddenFrom === "both") m.hiddenFrom = ["ai", "user"];
          }
          if(!m.hiddenFrom) m.hiddenFrom = [];
          // note: currently expectsReply is not supported in initial messages
          delete m.parameters;
        }

        for(let m of messages) {
          m.content = m.content.trim(); // to allow messages to be separated by multiple newlines, and to allow a space after [AI]:/[USER]:/[SYSTEM]:
        }

        return messages;
      }

      async function addCharacter(inputs) {
        const characterObj = {
          ...inputs,
          creationTime: Date.now(),
          lastMessageTime: Date.now(),
        };
        await db.characters.add(characterObj);
        return characterObj;
      }

      async function getOpenAiApiKey() {
        let apiKey = (await db.misc.get("openAiApiKey"))?.value;
        while(!apiKey) {
          let result = await prompt2({
            openAiApiKey: { label: "Please create a new OpenAI API secret key and paste it here. Go to <a style='color:blue' href='https://platform.openai.com/account/api-keys' target='_blank'>this page</a> to do that. You can change or delete this later by clicking the 'settings' button.", type:"textLine", placeholder:"sk-...", focus:true },
          });
          if(!result || !result.openAiApiKey) continue;
          apiKey = result.openAiApiKey;
          break;
        }
        await db.misc.put({ key: "openAiApiKey", value: apiKey });
        return apiKey;
      }


      function createMessageObj({threadId, message, characterId, hiddenFrom, creationTime, expectsReply, memoryIdBatchesUsed, loreIdsUsed, summaryHashUsed, memoryQueriesUsed, messageIdsUsed, scene, avatar, name, customData, wrapperStyle, order, instruction}) {
        if(threadId === undefined || message === undefined || characterId === undefined) throw new Error(`createMessageObj: threadId, message, and characterId are required: ${threadId}, ${message}, ${characterId}`);
        return {
          threadId,
          message,
          characterId,
          hiddenFrom: Array.isArray(hiddenFrom) ? hiddenFrom : [],
          expectsReply: expectsReply ?? undefined,
          creationTime: creationTime ?? Date.now(),
          variants: [null], // null is the placeholder for the currently-selected variant (i.e. the one in the `message` property)
          memoryIdBatchesUsed: memoryIdBatchesUsed ?? [],
          loreIdsUsed: loreIdsUsed ?? [],
          summaryHashUsed: summaryHashUsed ?? null,
          memoryQueriesUsed: memoryQueriesUsed ?? [],
          messageIdsUsed: messageIdsUsed ?? [],
          name: name ?? null,
          scene: scene ?? null,
          avatar: avatar ?? {},
          customData: customData ?? {},
          wrapperStyle: wrapperStyle ?? "",
          order: order ?? undefined,
          instruction: instruction ?? null,
          // RE `order` being undefined - this can happen if it's just being created (but not when e.g. being called from messagesFromCustomCodeFormat)
        };
      }

      async function addMessageToDb(messageObj, opts={}) {

        messageObj = structuredClone(messageObj);
        delete messageObj.character; // just in case I'm sloppy somewhere

        if(messageObj.order === undefined) {
          let messages = await db.messages.where({threadId:messageObj.threadId}).toArray();
          messages.sort((a,b) => a.order - b.order);
          messageObj.order = messages.length > 0 ? Math.ceil(messages.at(-1).order + 1) : 0;
        }

        let id = await db.messages.add(messageObj);
        // update the thread's lastMessageTime.
        await db.threads.update(messageObj.threadId, { lastMessageTime: messageObj.creationTime });
        
        // if this isn't at the top of the thread list, re-render the thread list
        let threadId = messageObj.threadId;
        let thread = await db.threads.get(threadId);
        let threadElements = [...$.chatThreads.querySelectorAll(".thread")];
        if(!thread.isFav) threadElements = threadElements.filter(el => el.querySelector(".favStar").dataset.isFav==="false");
        if(threadElements[0].dataset.threadId !== threadId.toString()) {
          await renderThreadList();
        }

        return id;
      }

      async function addThread({name, characterId, folderPath}) {
        let aiCharacter = await db.characters.get(characterId);

        let modelName = getRealModelName(aiCharacter.modelName);

        // get highest bookId value:
        let loreBookId = (await db.lore.orderBy("bookId").last() ?? {bookId:-1}).bookId;
        loreBookId++;
        
        const threadObj = {
          name,
          characterId,
          creationTime: Date.now(),
          lastMessageTime: Date.now(),
          lastViewTime: Date.now(),
          isFav: false,
          userCharacter: { // note: we don't use await getUserCharacterObj because that is for *existing* threads (requires threadId as input param)
            name: (await db.misc.get("userName"))?.value || defaultUserName,
            avatar: {
              url: (await db.misc.get("userAvatarUrl"))?.value || "",
              // we leave `shape` and `size` as thread default
            },
          },
          systemCharacter: {name:defaultSystemName, avatar:{}},
          character: {avatar:{}}, // thread-specific ai character overrides
          modelName,
          customCodeWindow: {visible:false, width:null},
          customData: {},
          folderPath: folderPath || "",
          loreBookId,
          textEmbeddingModelName: aiCharacter.textEmbeddingModelName,
          userMessagesSentHistory: [],
          unsentMessageText: "",
          shortcutButtons: [],
          currentSummaryHashChain: [],
        };

        if(aiCharacter.loreBookUrls.length > 0) {
          await getOpenAiApiKey(); // so we have it for embedTexts
        }

        await ensureLoreUrlsAreLoaded({loreBookUrls:aiCharacter.loreBookUrls, modelName:aiCharacter.textEmbeddingModelName}).catch(e => {
          console.error("Error loading lore urls:", e);
          alert("Error loading lore urls: "+e);
        });

        // when a thread is first created, we copy across the character's userCharacter as a starting point for the `thread.userCharacter` - after that, the `aiCharacter.userCharacter` is not relevant to the thread (i.e. thread's userCharacter can diverge from the character's 'template' userCharacter)
        applyObjectOverrides({object:threadObj.userCharacter, overrides:aiCharacter.userCharacter});
        // same for systemCharacter
        applyObjectOverrides({object:threadObj.systemCharacter, overrides:aiCharacter.systemCharacter});

        await db.threads.add(threadObj);
        return threadObj;
      }

      async function ensureLoreUrlsAreLoaded({loreBookUrls, modelName}) {
        let loadingModal = createLoadingModal("Downloading lore...");
        let urlI = 0;
        let useCORSProxy = (await db.misc.get("useCORSProxy"))?.value || "yes";
 
        for(let url of loreBookUrls) {
          let downloadUrl;
          let origin = new URL(url).origin;
          if (useCORSProxy == "no") {
            downloadUrl = url;
            console.log("Loading lore from " + url + " because CORS proxy is disabled.");
          }
          else if(origin.endsWith("jsdelivr.net")
            || (origin.endsWith("huggingface.co") && url.includes("/resolve/"))
            || origin === "https://raw.githubusercontent.com"
          ) {
            // the server has correct CORS headers, so we don't need the proxy:
            downloadUrl = url;
            console.log("Loading lore from " + url + " because it's known to be CORS-compliant.")
          } else {
            // code for this CORS proxy server is here: https://replit.com/@joe64/opencharacters-cors-proxy
            // EDIT: Moved to Glitch since Replit raised prices to an absurd $6/month for a 0.25 vCPU machine in Jan 2024 (no more "Always On" machines - only "Deployments" now).
            downloadUrl = "https://opencharacters-cors-proxy.glitch.me/?url=" + encodeURIComponent(url);
            console.log("Loading lore from " + downloadUrl + " because CORS proxy looks necessary.");
          }
          let text = await fetch(downloadUrl).then(r => r.text());
          let entryTextArr = text.replace(/\r/g, "").split(/\n{2,}/).map(entry => entry.trim()).filter(entry => entry);
          
          let textHashes = await Promise.all(entryTextArr.map(e => sha256Text(e)));
          let entries = entryTextArr.map((e, i) => ({
            text: e,
            textHash: textHashes[i],
            bookUrl: url,
            bookId: null,
            triggers: [],
          }));
          
          // Add embeddings to entries:
          let onProgressMessage = (data) => loadingModal.updateContent(`Adding lore entries (URL #${urlI})... ` + Math.round(data.progress * 100) + "%");
          // Note that `embedTexts` will try to get embeddings from textEmbeddingCache first
          let embeddings = await embedTexts({textArr:entries.map(e => e.text), modelName, onProgressMessage, shouldCache:true});
          entries.forEach((e, i) => {
            e.embeddings = {[modelName]:embeddings[i]};
          });
          let textToEntry = new Map(entries.map(e => [e.text, e]));

          let entryTextsThatAreAlreadyInDb = new Set();
          await db.lore.where({bookUrl:url}).modify((entry, ref) => {
            if(!textToEntry.has(entry.text)) {
              delete ref.value; // delete this entry because it no longer exists as an entry in the text at this url
              return;
            }
            entryTextsThatAreAlreadyInDb.add(entry.text);
            if(!entry.embeddings[modelName]) { // <-- it's possible that the entry exists, but doesn't have an embedding for this model
              entry.embeddings[modelName] = textToEntry.get(entry.text).embeddings[modelName];
            }
          });

          let entriesToAdd = entries.filter(e => !entryTextsThatAreAlreadyInDb.has(e.text));
          for(let entry of entriesToAdd) {
            delete entry.textHash;
          }
          if(entriesToAdd.length > 0) {
            await db.lore.bulkAdd(entriesToAdd);
            console.log(`Added lore entries for ${url}:`, entriesToAdd);
          }
          urlI++;
        }
        loadingModal.delete();
      }

      let modelNameToTokenizerCache = {};
      let gpt3Tokenizer;
      async function getTokenizerByModelName(modelName) {
        if(modelNameToTokenizerCache[modelName]) return modelNameToTokenizerCache[modelName];

        let modelObj = getModel(modelName);

        // TODO: get tokenizers for each model
        if (modelIsOpenAiModel(modelName)) {
          if(!gpt3Tokenizer) gpt3Tokenizer = createGpt3Tokenizer();
          modelNameToTokenizerCache[modelName] = gpt3Tokenizer;
          return gpt3Tokenizer;
        }

        if(!modelObj.modelUrl) throw new Error("Model doesn't have a modelUrl: "+modelName);

        if(!window.AutoTokenizer) {
          let { AutoTokenizer } = await import("https://cdn.jsdelivr.net/npm/@xenova/transformers@2.0.0-alpha.0/dist/transformers.js");
          window.AutoTokenizer = AutoTokenizer;
        }
        
        let tokenizer = await window.AutoTokenizer.from_pretrained(modelName); // returns data in this form: { data: [1, 15043, 3186], dims: [1, 3], size: 3, type: "int64" } where 'int64' ==> BigInt64
        function textToTokenIds(text) {
          return [...tokenizer(text).input_ids.data].map(n => Number(n)); // cast BigInt64 to Number
        }
        modelNameToTokenizerCache[modelName] = textToTokenIds;
        return textToTokenIds;
      }

      async function countTokens(str, modelName) {
        if(!str) return 0;
        let tokenizer = await getTokenizerByModelName(modelName);
        
        // We just use GPT-3 tokenizer for all models as an ESTIMATE for now.
        // It's better than `Math.ceil(str.length/4)` because it can handle non-ASCII characters (which very rarely are 4 characters per token).
        // But it's still just an estimate.
        // TODO: have a tokenizer per modelName, and use the right one here.
        return await tokenizer(str).length
      }

      let messageHashToTokenCountCache = {};
      async function countTokensInMessages(messages, modelName) {
        let sum = 0;
        for(let messageText of messages.map(m => `\n\n[${m.name || m.role}]: ${m.content || m.message}`)) {
          let hash = await sha256Text(messageText);
          if(messageHashToTokenCountCache[hash] === undefined) {
            messageHashToTokenCountCache[hash] = await countTokens(messageText, modelName);
          }
          sum += messageHashToTokenCountCache[hash];
        }
        return sum;
      }

      async function embedTexts({textArr, modelName, onProgressMessage, shouldCache=false}={}) {
        modelName = await getRealTextEmbeddingModelName(modelName);
        if (availableModels[modelName] === undefined) {
          debugger;
          alert("This thread is using a text embedding model that is no longer supported. Please edit the character associated with this thread, and use the advanced settings to change the text embedding model to a current one. Then use the '/flushembeds' command to reset the embeddings for this thread.");
          return;
        }

        // we need to return the embeddings in the same order despite our caching-retrieval process:
        let textsRemaining = textArr.slice(0).map((t, i) => ({text:t, order:i}));

        // try to get embeddings from cache.
        // first add text hashes:
        let textHashes = await Promise.all(textsRemaining.map(e => sha256Text(e.text)));
        textsRemaining.forEach((e, i) => e.textHash = textHashes[i]);
        // then get cached embeddings:
        let cachedEmbeddings = await db.textEmbeddingCache.where("textHash").anyOf(textHashes).toArray();
        cachedEmbeddings = cachedEmbeddings.filter(e => e.modelName === modelName);
        // then add cached embeddings to textsRemaining:
        let textHashToCachedEmbedding = {};
        cachedEmbeddings.forEach(e => textHashToCachedEmbedding[e.textHash] = e.embedding);
        textsRemaining.forEach(e => {
          if(textHashToCachedEmbedding[e.textHash]) {
            e.embedding = textHashToCachedEmbedding[e.textHash];
          }
        });
        
        let embeddings = textsRemaining.filter(e => e.embedding);
        textsRemaining = textsRemaining.filter(e => !e.embedding);

        let apiKey = await getOpenAiApiKey();

        let endpointUrl = "https://api.openai.com/v1/embeddings";
        let headers = {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`,
        };
        if(new URL(endpointUrl).hostname.includes("azure")) {
          headers["api-key"] = apiKey;
        }

        if (textsRemaining.length > 0) {
          console.log("Fetching embeddings using model " + modelName + ".");
        }
        // batch textArr into chunks of 100
        while(textsRemaining.length > 0) {
          let textsToEmbed = textsRemaining.splice(0, 100);
          let result = await fetch(endpointUrl, {
            method: "POST",
            headers,
            body: JSON.stringify({
              input: textsToEmbed.map(e => e.text),
              model: modelName,
            })
          }).then(response => response.json()); // TODO: this returns token counts under result.usage.total_tokens - I should add it to cost usageStats for cost estimation
          if(!result.data) {
            alert("Error:\n" + JSON.stringify(result, null, 2));
            throw new Error("Error getting text embeddings from OpenAI API");
          }
          let embeddingsForThisBatch = result.data.map((o, i) => {
            return {
              text: textsToEmbed[i].text,
              textHash: textsToEmbed[i].textHash,
              embedding: o.embedding,
              order: textsToEmbed[i].order,
              modelName,
              notFromCache: true,
            };
          });
          embeddings.push(...embeddingsForThisBatch);
          if(onProgressMessage) onProgressMessage({progress:1-textsRemaining.length/textArr.length});
        }
        embeddings.sort((a,b) => a.order-b.order)
        let embeddingVectorsToReturn = embeddings.map(e => e.embedding);

        // add to cache:
        let alreadyGotTexts = new Set(); // just in case textArr contains duplicates
        let entriesToAddToCache = [];
        for(let entry of embeddings) {
          if(entry.notFromCache && !alreadyGotTexts.has(entry.text)) {
            delete entry.order;
            delete entry.notFromCache;
            entriesToAddToCache.push(entry);
            alreadyGotTexts.add(entry.text);
          }
        }
        if(shouldCache) {
          await db.textEmbeddingCache.bulkAdd(entriesToAddToCache);
        }

        if(onProgressMessage) onProgressMessage({progress:1});
        return embeddingVectorsToReturn;
      }


      async function compressText({text, tokenLimit, modelName, onProgressMessage, threadId}) {
        // note: the threadId is just used to track token usage

        let originalText = text;
        let currentText = text;

        let modelTokenLimit = getModel(modelName).maxSequenceLength;

        let compressionStep = 0;
        let textArr = [currentText]; // just for debugging
        while(await countTokens(currentText, modelName) > tokenLimit) {
          if(onProgressMessage) onProgressMessage({message:`compressing text (${compressionStep})`});

          // split text into chunks no longer than modelTokenLimit/2, with some overlap between chunks
          let textChunks = [];
          let chunkOverlap = 0.15;
          {
            let textChunksRemaining = [currentText];
            while(textChunksRemaining.length > 0) {
              let textChunk = textChunksRemaining.shift();
              if(await countTokens(textChunk, modelName) > modelTokenLimit/2) {
                // split the chunk into two
                let splitIndex = Math.floor(textChunk.length / 2);
                let overlap = Math.floor(chunkOverlap * splitIndex);

                textChunksRemaining.unshift(textChunk.slice(splitIndex));
                textChunksRemaining.unshift(textChunk.slice(0, splitIndex + overlap));
              } else {
                textChunks.push(textChunk);
              }
            }
          }

          // compress all the chunks of currentText into a newText by iteratively adding each chunk to the running summary
          // note: we do it this way so that GPT has the summary-so-far as context, versus trying to summarize a random-looking chunk of text with no context
          let chunkI = 0;
          let newText;
          for(let chunk of textChunks) {
            let messages = [{role: "system", content: "You are a helpful writing assistant. You respond with exactly the text that the user requests - nothing more, nothing less."}];
            let resultText;
            if(chunkI === 0) {
              if(compressionStep < 2) { 
                messages.push({role: "user", content: `Please respond with the following text, almost verbatim, but slightly shorter:\n\n------\n\n${chunk}${textChunks.length > 1 ? "..." : ""}\n\n------\n\nYour response should start with "NEW TEXT:" and should repeat the above text verbatim, but **SLIGHTLY** shorter. Don't cut out ANY details at all. It should be a VERY LONG, HIGHLY-DETAILED summary, capturing every single detail of the original text. Start your response with "NEW TEXT:". A concise version of *EVERY* individual sentence/paragraph should be included in the summary.`});
              } else {
                messages.push({role: "user", content: `Please respond with a summary of the following text:\n\n------\n\n${chunk}${textChunks.length > 1 ? "..." : ""}\n\n------\n\nYour response should start with "NEW TEXT:" and should be a bit shorter. Make sure to include ALL important details in the summary. The summary MUST NOT be short. It must be a LONG, HIGHLY-DETAILED summary.`});
              }
              resultText = await getChatCompletion({messages, modelName, temperature:0.7, threadId});
              resultText = resultText.trim().replace(/^NEW TEXT: ?/, "").trim();
            } else {
              if(compressionStep < 2) { 
                messages.push({role: "user", content: `I'm rewriting/summarizing a document to make it slightly shorter. Below is my work so far.\n\nSO FAR: ${newText}\n\n-----\n\nHere's what I need to add to the "SO FAR" next:\n\nNEXT PART: [...] ${chunk}${textChunks.length > chunkI+1 ? "..." : ""}\n\n-----\n\nPlease continue the "SO FAR" text by adding a more concise version of the "NEXT PART" section to the end of it. Add every single sentence/paragraph/etc. from "NEXT PART" to the "SO FAR" text, almost verbatim, except with slighly shorter (e.g. drop superfluous words and shorten/drop uninformative sentences where possible). Just respond with the newly-extended "SO FAR" section - nothing else. Your response should start with "SO FAR: ${newText.slice(0, 70)}..." and integrate a more concise version of the "NEXT PART" text to produce a new, LONGER summary.`});
              } else {
                messages.push({role: "user", content: `I'm rewriting/summarizing a document to make it a bit shorter. Below is my work so far.\n\nSO FAR: ${newText}\n\n-----\n\nHere's what I need to add to the "SO FAR" next:\n\nNEXT PART: [...] ${chunk}${textChunks.length > chunkI+1 ? "..." : ""}\n\n-----\n\nPlease continue the "SO FAR" text by adding a summarized version of the "NEXT PART" section to the end of it. Just respond with the newly-extended "SO FAR" section - nothing else. Your response should start with "SO FAR:" and add a summarized version of the "NEXT PART" text to the end of it. Make sure to include ALL important details in the new "SO FAR:" section - it should be LONGER than the existing one.`});
              }
              resultText = await getChatCompletion({messages, modelName, temperature:0.7, threadId});
              resultText = resultText.trim().replace(/^SO FAR: ?/, "").trim();
            }
            newText = resultText;
            chunkI++;
          }
          
          
          if(!newText) {
            if(onProgressMessage) onProgressMessage({message:`error, retrying compression...`});
            await delay(3000);
          } else {
            currentText = newText;
            textArr.push(text);
            console.log(`compressed text (${await countTokens(currentText, modelName)} tokens): ${currentText}`);
          }
          compressionStep++;
          if(compressionStep >= 10 && compressionStep%10 === 0) {
            await prompt2({
              display:{html:`<div style="white-space:pre-wrap;">For some reason the summarizer is struggling to summarize your text. If you close this message it will continue trying to compress the summary, but be aware that it may use a lot of API credits if it's caught in a loop. Refresh the page if you'd like to stop, or click close to continue. This could be a bug in OpenCharacters, so please report it on Github or Discord if this happens regularly. It should happen very rarely if at all. You can manually edit the summary by typing <b>/sum</b> in the chat. Here's the sequence of compression steps it has taken so far:\n\n${textArr.map((t, i) => `<b>Summary ${i}:</b>\n${t}`).join("\n\n")}</div>`, type:"none"},
            }, { submitButtonText: "close", cancelButtonText: null });
          }
        }
        return currentText;
      }

      async function getThreadSummaryHashChain(threadOrThreadId) {
        let thread = typeof threadOrThreadId === "number" ? await db.threads.get(threadOrThreadId) : threadOrThreadId;

        if(thread.currentSummaryHashChain === undefined) {
          let { instructionHashChain } = await computeAndSaveThreadSummaryIfNeeded({threadId:thread.id, exitOnFirstHashMissAndReturnHashChain:true});
          thread.currentSummaryHashChain = instructionHashChain;
          await db.threads.update(thread.id, {currentSummaryHashChain:instructionHashChain});
        }

        return thread.currentSummaryHashChain;
      }

      let alreadyComputingSummaryForThreadPromises = {};
      let alreadyComputingSummaryForThreadResolvers = {};
      async function computeAndSaveThreadSummaryIfNeeded({threadId, upToMessageId, onProgressMessage, signals, exitOnFirstHashMissAndReturnHashChain, continuePastCurrentSummary, forceSummaryThroughMessageId}) {

        // Note:
        //  - continuePastCurrentSummary is so that we can load summaries "ahead of time" (it just computes - causes this function to not return anything)
        //  - exitOnFirstHashMissAndReturnHashChain is so that we can allow people to delete summaries for a thread (the current threadId on each summary is erroneous, since there could be a second thread using it)

        if (forceSummaryThroughMessageId) {
          debugger;
        }

        function finalize() {
          // this function is called in the finally clause of the below try/finally block, so it gets called right before any `return` statement in the `try` clause
          let resolver = alreadyComputingSummaryForThreadResolvers[threadId];
          delete alreadyComputingSummaryForThreadPromises[threadId];
          delete alreadyComputingSummaryForThreadResolvers[threadId];
          resolver();
        }
        
        try {
          while(alreadyComputingSummaryForThreadPromises[threadId]) { // we need `while` instead of `if` because there could have been *multiple* calls for this threadId waiting, and we only want to let one of them through at a time
            if(onProgressMessage) onProgressMessage({message:`existing summary in progress...`});
            await alreadyComputingSummaryForThreadPromises[threadId];
          }
          alreadyComputingSummaryForThreadPromises[threadId] = new Promise((resolve) => {
            alreadyComputingSummaryForThreadResolvers[threadId] = resolve;
          });

          if(!signals) signals = {};
          // here's the overall idea: "consume" old messages (remove them from the start of the messages array) until you get to `messageTokensToConsumePerSummary` tokens, and then summarize them (use an existing summary if we already have it - it's kinda treated like the first message), and then keep repeating until the total number of tokens in the messages array falls below `tokenLimit` minus some tokens for the bot's response.
          // note: upToMessageId is inclusive. it's needed for things like regenerateMessage, where it may be that not all messages in the thread are visible to the bot.

          let thread = await db.threads.get(threadId);
          let aiCharacter = await db.characters.get(thread.characterId);
          let userCharacter = await getUserCharacterObj(threadId);

          // WARNING: If you change this, you'll probably have to change the summarization prompts.
          let modelName;
          if(await threadIsUsingOpenAiModel(thread)) {
            modelName = openAISummarizationModel;
          } else {
            modelName = thread.modelName;
          }

          const characterId = aiCharacter.id;

          let originalMessages = await db.messages.where({threadId}).toArray();
          originalMessages.sort((a,b) => a.order - b.order);

          if(upToMessageId === undefined) upToMessageId = originalMessages.at(-1).id;
          originalMessages = originalMessages.slice(0, originalMessages.findIndex(m => m.id === upToMessageId)+1);

          let originalMessagesPreparedForBot = await prepareMessagesForBot({messages:originalMessages, onProgressMessage});
          let remainingMessages = originalMessagesPreparedForBot.slice(0);

          const tokenLimitForSummaryAndMessages = await getTokenLimitForSummaryAndMessages(aiCharacter, thread);

          if(tokenLimitForSummaryAndMessages < 500) {
            debugger;
            alert("Heads up: It looks like you may have an instruction or reminder that is really long - this means that there's only a very small amount of room for the messages and the summary. If your character's instruction/reminder isn't very long, then this could be a bug - in which case, please report this on Github or the Discord server.");
          }

          // these two can't really be any bigger, because we need to leave the final ~third for the *new* summary (although I think, practically, the summary will tend to be a lot smaller than 0.3*token limit, since the model naturally prevents summaries from getting too long)
          // CAUTION: if you change these, users will have to recompute all their summaries (since hashes will change) but you can fix this by checking for an instruction hash match every time we add a message to the batch (TODO)
          const maxTokenCountOfSummary = Math.round(tokenLimitForSummaryAndMessages/3); // <-- probably don't want summary to be any longer than the first third of our token budget
          const messageTokensToConsumePerSummary = Math.round(getModel(modelName).maxSequenceLength*0.3);

          if(maxTokenCountOfSummary + messageTokensToConsumePerSummary > getModel(modelName).maxSequenceLength-500) { // -500 due to token estimation and to make room for summarization prompt
            throw new Error("The specified values of `maxTokenCountOfSummary` and `messageTokensToConsumePerSummary` are such that the summarization process could go over this model's token limit.");
          }

          let memoryIdsToSetToCurrent = [];
          let highestMemoryIndexInCurrentMemories = -1;
          // let memories = await db.memories.where({threadId});
          // memories.sort((a,b) => a.index - b.index);
          // if(aiCharacter.autoGenerateMemories === "v1") {
          //   // set isCurrent to false on all memories of this character so we can re-validate them along with the summaries - in case the thread has been edited
          //   await db.memories.where({threadId, status:"current"}).modify({status:"noncurrent"});
          //   await db.memories.where({summaryHash:"", threadId}).modify({status:"current"}); // <-- bit hacky, but this is needed for user-added memories before any summaries were done (so they don't belong to a summaryHash). could maybe make *all* user-added memories use "" (empty string) as summaryHash, but for now I just add them to the summary that they were closest to, or if there is no summary yet, then ""
          // }
          
          // get total tokens in all messages
          let initialTokenCount = await countTokensInMessages(remainingMessages, modelName);
          let currentTokenCount = initialTokenCount;
          let numTokensToSummarize; // we don't know this until we've looped through and found the first hash with no matching summary in our database
          let prevSummary;
          let prevSummaryObj;
          let prevInstructionHash;
          let instructionHashChain = [];
          let i = 0;
          let numSummariesGenerated = 0; // <-- i.e. where we didn't have an existing matching summary
          let alreadyWarnedAboutLoop = false;

          let condition = () => currentTokenCount > tokenLimitForSummaryAndMessages; // while the total token count is too high, grab batches of old messages, and summarize them
          if(continuePastCurrentSummary) condition = () => true; // we break out of the while loop when we run out of messages to summarize (or, to be more accurate, when we don't have a 'full' batch of messages to summarize)
          
          while(condition()) {
            if(signals.stop) {
              return {};
            }
            let progess = 1 - ((currentTokenCount-tokenLimitForSummaryAndMessages) / (initialTokenCount-tokenLimitForSummaryAndMessages));
            if(onProgressMessage) onProgressMessage({message:`summarizing (step ${i}, ${Math.round(progess*100)}% done)`});
            
            // grab old messages until we have at least `messageTokensToConsumePerSummary` tokens worth of text
            let messageBatchTokenCount = 0;
            let messageBatchArr = [];
            while(messageBatchTokenCount < messageTokensToConsumePerSummary) {
              if(signals.stop) {
                return {};
              }
              if(remainingMessages.length === 0) {
                if(continuePastCurrentSummary) {
                  // there isn't a full batch of messages to summarize, so we're done with the "computing ahead of current summary"
                  // it's important that we return here because there are other operations done below that we don't want to do if this is a 'continuePastCurrentSummary' type call, rather than actually getting the summary (e.g. setting the thread's currentSummaryHashChain)
                  return;
                }
                break; // no more messages
              }
              
              let m = remainingMessages[0];
              let tokens = await countTokensInMessages([m], modelName);
              if(messageBatchTokenCount > 0 && messageBatchTokenCount+tokens >= messageTokensToConsumePerSummary) {
                break; // don't add this message to the batch, because it would put us over the limit
              }

              if(messageBatchTokenCount+tokens >= messageTokensToConsumePerSummary) {
                // we were forced to add a message to the batch that puts us over the limit (since the batch would otherwise be empty), so we need to compress it:
                let newText;
                let uncompressedTextHash = await sha256Text(m.content);
                let cacheEntry = await db.textCompressionCache.where({uncompressedTextHash, modelName, tokenLimit:messageTokensToConsumePerSummary}).first();
                if(cacheEntry) {
                  newText = cacheEntry.compressedText;
                } else {
                  newText = await compressText({text:m.content, modelName, tokenLimit:messageTokensToConsumePerSummary, onProgressMessage, threadId});
                  await db.textCompressionCache.put({uncompressedTextHash, modelName, tokenLimit:messageTokensToConsumePerSummary, compressedText:newText, threadId});
                }
                m.content = newText;
                tokens = await countTokensInMessages([m], modelName);
                if(onProgressMessage) onProgressMessage({message:`summarizing (step ${i}, ${Math.round(progess*100)}% done)`});
              }

              messageBatchArr.push(m);
              messageBatchTokenCount += tokens;
              remainingMessages.shift();
            }

            if(messageBatchTokenCount > getModel(modelName).maxSequenceLength*0.8) {
              console.error("The messageBatchTokenCount is nearly the full size of the model's token limit.");
              console.error("messageBatchTokenCount:", messageBatchTokenCount);  
            }

            let messageBatchSummarizationInstruction;
            if(aiCharacter.autoGenerateMemories === "v1") {
              if(i > 0) { // if i>0, then we have prevSummary 
                let messageBatchText = messageBatchArr.map(m => `[${m.name}]: ${m.content}`).join("\n\n");
                // NOTE: Dedent doesn't work here because messageBatchText is multi-line, so the second line is not indented and thus prevents the dedenting
                messageBatchSummarizationInstruction = `
  Here's an overall summary of what has happened previously:

  ------
  ${prevSummary}
  ------  

  And here are some recent happenings/messages:

  ------
  ${messageBatchText}
  ------

  I have two tasks for you:

  1. Given that we already knew about the stuff in the summary, write a list of new things that we learned by reading the recent happenings/messages. Include all important details. Every learning should start with the text "We learned that".
  2. Write a new version of the above *overall* summary that integrates what has recently happened. DO NOT MISS ANY IMPORTANT DETAILS. The summary can be LONG. Retain ALL important details from the previous summary.

  Your reply should start with "NEW LEARNINGS:" and follow this exact template (nothing more, nothing less):

  NEW LEARNINGS:
  * We learned that <something we learned about the story/characters from the messages. include relevant context & info - e.g. "X happened due to Y, right after Z happened" instead of just "X happened">
  * We learned that <add another thing here. you should always reference with names instead of pronouns>
  * We learned that <write as many points as needed - don't miss any info! we want to record ALL useful information)

  NEW OVERALL SUMMARY:
  <write a new summary here - it should start with "${prevSummary.split(" ").slice(0, 5).join(" ")}..." and should include ALL the important details that were in the previous summary - it's okay for the summary to be LONG if needed>`.trim();
              } else {
                let messageBatchText = messageBatchArr.map(m => `[${m.name}]: ${m.content}`).join("\n\n");
                // NOTE: Dedent doesn't work here because messageBatchText is multi-line, so the second line is not indented and thus prevents the dedenting
                messageBatchSummarizationInstruction = `
  Here are some messages:

  ------
  ${messageBatchText}
  ------

  I have two tasks for you:

  1. Write a list of things that a reader would learn by reading the messages. Include all important details. Every learning should start with the text "We learned that".
  2. Write a summary of the messages. DO NOT MISS ANY IMPORTANT DETAILS. The summary can be LONG.

  Your reply should start with "LEARNINGS:" and follow this exact template (nothing more, nothing less):

  LEARNINGS:
  * We learned that <something we learned about the story/characters from the messages. include relevant context & info - e.g. "X happened due to Y, right after Z happened" instead of just "X happened">
  * We learned that <add another thing here. you should always reference with names instead of pronouns>
  * We learned that <write as many points as needed - don't miss any info! we want to record ALL useful information)

  OVERALL SUMMARY:
  <write a summary here - it should include ALL the important details - it's okay for the summary to be LONG if needed>`.trim();
              }
            } else {
              if(i > 0) { // if i>0, then we have prevSummary 
                let messageBatchText = messageBatchArr.map(m => `[${m.name}]: ${m.content}`).join("\n\n");
                // NOTE: Dedent doesn't work here because messageBatchText is multi-line, so the second line is not indented and thus prevents the dedenting
                messageBatchSummarizationInstruction = `Here's what has recently happened:\n\n------\n${messageBatchText}\n------\n\nHere's a summary of what happened previously:\n\n------\n${prevSummary}\n------\n\nPlease reply with a new version of this summary that ALSO includes what has recently happened. Include ALL the KEY details. DO NOT MISS ANY IMPORTANT DETAILS. You MUST include all the details that were in the previous summary in your response. Your response should start with "${prevSummary.split(" ").slice(0, 5).join(" ")}" and it should compress all the important details into a new summary. It's okay for the summary to be LONG if needed.`.trim();
              } else {
                let messageBatchText = messageBatchArr.map(m => `[${m.name}]: ${m.content}`).join("\n\n");
                // NOTE: Dedent doesn't work here because messageBatchText is multi-line, so the second line is not indented and thus prevents the dedenting
                messageBatchSummarizationInstruction = `Please summarize the content of these messages:\n\n------\n${messageBatchText}\n------\n\nRespond with the summary only - nothing else. Include all relevant details. Be concise, but DO NOT leave out any important details. It's okay for the summary to be LONG if needed.`.trim();
              }
            }


            // Note: Hash corresponds to only the inputs (i.e. prevSummary and messageBatchArr).
            // User can edit summaries and that doesn't mess with our hashing stuff (if they edited a *non-latest* summary, then summaries would need to be recomputed [which wouldn't be a big deal], but they can only edit latest one anyway).
            
            // I was originally using the whole messageBatchSummarizationInstruction as the hash, but that's not ideal because then everytime I update the instruction prompt, every thread will need to have all its summaries recomputed.
            // With this approach they'll only ever need to recompute summaries and memories if the actual messages change.
            // If I ever want to force everyone to recompute summaries and memories (e.g. because I introduced a really bad bug that makes it worth it) then I can increment the summarizationVersion.
            
            // CAUTION: incrementing summarizationVersion or editing textToHash will cause everyone to need to recompute all summaries - can cost multiple dollars for very long threads.
            const summarizationVersion = 1;
            let textToHash = summarizationVersion + " " + (prevSummary || "") + messageBatchArr.map(m => m.content).join("\n\n\n");
            let hash = await sha256Text(textToHash);

            instructionHashChain.push(hash);

            if(signals.stop) {
              return {};
            }

            // check if we have a summary for this text yet
            let summaryObj = await db.summaries.get(hash);
            let summary = summaryObj?.summary;
            if(!summary) {
              if(exitOnFirstHashMissAndReturnHashChain) {
                return {instructionHashChain};
              }
              if(numTokensToSummarize === null) {
                numTokensToSummarize = currentTokenCount;
              }
              let result;
              while(1) {
                if(signals.stop) {
                  return {};
                }
                result = await getChatCompletion({
                  messages: [
                    {role: "system", content: "You are an expert text summarization assistant. You respond only with what the user requests - nothing more, nothing less."},
                    {role: "user", content: messageBatchSummarizationInstruction},
                  ],
                  modelName,
                  temperature: 0.7,
                  threadId, // just used to track token usage
                });
                if(result) break;
                if(onProgressMessage) onProgressMessage({message:`error, retrying summary...`});
                await delay(3000);
              }
              console.log("New summary generated: " + result);
              numSummariesGenerated++;
              if(!alreadyWarnedAboutLoop && numSummariesGenerated > 5*(numTokensToSummarize/messageTokensToConsumePerSummary)) { // the 5* is because it's very unlikely that each summary only consumed 1/5 of messageTokensToConsumePerSummary
                alert("The summary system might be caught in a loop? This could be a bug. If you click OK, it will continue, but please watch it to ensure it doesn't infinitely loop and spend lots of API credits.");
                alreadyWarnedAboutLoop = true;
              }
              if(aiCharacter.autoGenerateMemories === "v1") {
                let [ memoriesText, summaryText ] = result.split(/OVERALL SUMMARY:|NEW OVERALL SUMMARY:/);
                let memories = memoriesText.trim().replace(/^LEARNINGS:|NEW LEARNINGS:/, "").trim().split("\n").map(m => m.trim().replace(/^\* (We learned that )?/, "").trim()).filter(m => m);
                memories = memories.map(m => m.replace(/\n+/g, "\n")); // not ideal, but: memories cannot have two consecutive newlines, since in the memory editing UI two newlines indicate a gap between entries
                memories = memories.map(m => m[0].toUpperCase() + m.slice(1)); // capitalize first letter of each memory

                let embeddingModelName = await getRealTextEmbeddingModelName(thread.textEmbeddingModelName);

                // Warn user if they're using a non-OpenAI model and have character memories enabled (TODO: add option for locally-computed embeddings)
                if(!await threadIsUsingOpenAiModel(thread)) {
                  let userPermissionToUseOpenAiByThread = (await db.misc.get("userPermissionToUseOpenAiModelByThread")) || {};
                  if(!userPermissionToUseOpenAiByThread[thread.id]) {
                    let confirm = window.confirm(`You're using a non-OpenAI model (${thread.modelName}), but you currently have character memories enabled. Character memories currenly rely on an OpenAI API, so this message is to inform you that text from this chat will be processed via OpenAI's text embedding service. Do you want to continue?`);
                    userPermissionToUseOpenAiByThread[thread.id] = confirm;
                    await db.misc.put({key:"userPermissionToUseOpenAiModelByThread", value:userPermissionToUseOpenAiModelByThread});
                    if(!confirm) {
                      return {};
                    }
                  }
                }

                let embeddings = await embedTexts({textArr:memories, modelName:embeddingModelName, shouldCache:true});

                // let existingThreadMemories = await db.memories.where({threadId, status:"current"}).toArray();
                // existingThreadMemories.sort((a,b) => a.index - b.index);
                // let previousMemory = existingThreadMemories.at(-1);
                // let previousMemoryIndex = previousMemory ? previousMemory.index : -1;
                let i = 0;
                let memoryObjsToAdd = [];
                let previousMemoryIndex = highestMemoryIndexInCurrentMemories;
                for(let memory of memories) {
                  let embedding = embeddings[i];
                  memoryObjsToAdd.push({summaryHash:hash, threadId, text:memory, characterId, embeddings:{[embeddingModelName]:embedding}, status:"current", index:previousMemoryIndex+1, triggers:[]});
                  previousMemoryIndex++;
                  highestMemoryIndexInCurrentMemories = previousMemoryIndex;
                  addToDebugLog(`<b>added memory:</b> ${memory}`);
                  console.log("added memory:", memory);
                  i++;
                }

                if(signals.stop) {
                  return {};
                }

                await db.transaction('rw', db.memories, async tx => {
                  // counter-intuitively, in rare cases it's possible for us to already have memories for this batch of messages (i.e. for this summary hash).
                  // e.g. if the user closed the tab right as the memories were being added to the db, but the summary didn't get a chance to be added.
                  // so we delete any existing memories that we have for these messages by checking for matches on the summaryHash.
                  await tx.table("memories").where({summaryHash:hash, threadId}).delete();

                  let ids = await tx.table("memories").bulkAdd(memoryObjsToAdd, undefined, {allKeys: true});
                  memoryIdsToSetToCurrent.push(...ids);
                });

                summary = summaryText.trim();
              } else {
                summary = result.trim();
              }
              console.log("computed summary:", summary);
              addToDebugLog(`<b>computed summary:</b> ${summary}`);
              let messageIds = messageBatchArr.map(m => m.id);
              let prevSummaryHash = prevSummaryObj ? prevSummaryObj.hash : null;
              await db.summaries.put({hash, summary, threadId, messageIds, prevSummaryHash});
            } else {
              // There's already an existing summary that matches this instruction hash.
              // mark the existing memories that match this summary has as current/valid:
              let memories = await db.memories.where({summaryHash:hash, threadId}).toArray();
              for(let m of memories) {
                if(m.index > highestMemoryIndexInCurrentMemories) {
                   highestMemoryIndexInCurrentMemories = m.index;
                }
              }
              memoryIdsToSetToCurrent.push(...memories.map(m => m.id));
            }

            if(signals.stop) {
              return {};
            }

            // Compress summary if needed.
            // Note this is *outside* of the above `if` block because user will be able to adjust maxTokenCountOfSummary, and we want to re-compute/compress summaries if they change that value.
            // (this also helps with backwards-compat since maxTokenCountOfSummary previously didn't exist, we so we may need to compress some old summaries)
            if(await countTokens(summary, modelName) > maxTokenCountOfSummary) {
              addToDebugLog(`<b>summary to compress:</b> ${summary}`);
              summary = await compressText({text:summary, tokenLimit:maxTokenCountOfSummary, modelName, onProgressMessage, threadId});
              await db.summaries.where({hash}).modify({summary});
              addToDebugLog(`<b>compressed summary:</b> ${summary}`);
            }

            if(signals.stop) {
              return {};
            }
            
            summaryObj = await db.summaries.get(hash);

            // get size difference between summary and original messages
            // let summaryTokenChange = countTokens(prevSummary || "") - countTokens(summary);
            // let messageArrTokenChange = -messageBatchTokenCount; // since all these messages were "removed" (squashed into the summary)
            // let overallTokenChange = summaryTokenChange + messageArrTokenChange;
            // currentTokenCount += overallTokenChange; // overallTokenChange is almost certainly negative but we can't assume that for sure, since it's not technically *impossible* for the LLM to return a summary that's longer than message batch

            currentTokenCount = await countTokens(summary||"", modelName) + await countTokensInMessages(remainingMessages, modelName);
            prevSummary = summary;
            prevSummaryObj = summaryObj;
            prevInstructionHash = hash;
            i++;
          }

          // it's possible that there are no remainingMessages due to the summarization happening to consume them all in the final batch.
          // in this case we add some messages back until we reach the token limit.
          // it means that there will be overlap between the summary and the messages, but that's fine.
          if(remainingMessages.length === 0) {
            let messagesToMaybeAdd = originalMessagesPreparedForBot.slice(0);
            while(1) {
              let currentTokenCount = await countTokens(prevSummary||"", modelName) + await countTokensInMessages(remainingMessages, modelName);
              if(currentTokenCount >= tokenLimitForSummaryAndMessages) break;
              if(remainingMessages.length > 3) break;
              if(messagesToMaybeAdd.length === 0) break;
              remainingMessages.unshift(messagesToMaybeAdd.pop());
            }
          }

          if(signals.stop) {
            return {};
          }

          await db.transaction('rw', db.memories, async tx => {
            await tx.table("memories").where({threadId, status:"current"}).modify({status:"noncurrent"});
            await tx.table("memories").where("id").anyOf(memoryIdsToSetToCurrent).modify({status:"current"});
            await tx.table("memories").where({summaryHash:"", threadId}).modify({status:"current"}); // <-- bit hacky, but this is needed for user-added memories before any summaries were done (so they don't belong to a summaryHash). could maybe make *all* user-added memories use "" (empty string) as summaryHash, but for now I just add them to the summary that they were closest to, or if there is no summary yet, then ""
          });
          
          if(signals.stop) {
            return {};
          }

          await db.threads.where({id:threadId}).modify({currentSummaryHashChain:instructionHashChain});

          // NOTE: prevSummary can be undefined - i.e. no summaries were needed to get messages under the tokenLimitForSummaryAndMessages limit
          return {summary:prevSummary, instructionHash:prevInstructionHash, instructionHashChain, remainingMessages}; // remainingMessages = unsummarized messages (the ones that follow the summary)

        } finally {
          finalize();
        }
      }

      




      async function prepareMessagesForBot({messages, onProgressMessage}) {
        // note that we don't need to handle {{user}}/{{char}} stuff in this function because that's just for instruction, reminder, and initial messages. Initial messages have already had {{char}} stuff "rendered" when they were added to the thread.

        if(messages.length === 0) return [];

        let threadId = messages[0].threadId;

        let thread = await db.threads.get(threadId);

        let messageCharacters = await db.characters.where("id").anyOf([...new Set(messages.map(m => m.characterId))]).toArray();
        let characterIdToCharacter = {};
        for(let c of messageCharacters) {
          characterIdToCharacter[c.id] = c;
        }
        characterIdToCharacter[-1] = await getUserCharacterObj(thread.id);
        characterIdToCharacter[-2] = await getSystemCharacterObj(thread.id);

        for(let m of messages) {
          m.message = m.message.replace(/<!--hidden-from-ai-start-->.+?<!--hidden-from-ai-end-->/gs, "");
        }
        
        messages = await renderMessagesForReader({messages, reader:"ai", threadId, onProgressMessage});

        // TODO: not sure that this will work as expected for the "reply with..." function, since the in-place-of-user bot will see the hidden-from-ai messages (like the user would - do we want that?)
        messages = structuredClone(messages).filter(m => {
          if(m.hiddenFrom && m.hiddenFrom.includes("ai")) return false;
          return true;
        });

        messages = messages.map(m => {
          let role;
          if(m.characterId === -1) role = "user";
          else if(m.characterId === -2) role = "system";
          else role = "assistant";

          let name = messageObjToCharacterName(m, {thread, character:characterIdToCharacter[m.characterId]});
     
          if(name === undefined) throw new Error("message name is undefined in prepareMessagesForBot");

          name = name.replaceAll(" ", "_");
          name = name.replace(/[^A-Za-z0-9_\-]/g, ""); // <-- we need to replace invalid characters here since the name could have been set with custom code, and in that case it wouldn't have been validated as happens when name is set in the character editor UI

          return { role, content: m.message+"", name, id: m.id }; // id is used for summary upToMessageId stuff, and tracking the messages that were used in each summary and memory (brain button popup)
        });

        return messages;
      }

      async function renderMessagesForReader({messages, reader, threadId, onProgressMessage}) {
        // `reader` can be "ai" or "user"

        if(messages.length === 0) return [];

        let thread = await db.threads.get(threadId);
        let aiCharacter = await db.characters.get(thread.characterId);
        let userCharacter = await getUserCharacterObj(threadId);

        if(!aiCharacter.customCode.trim()) return messages;

        // sometimes we need to render messages for a thread that isn't active (e.g. if user clicks thread export, and then we need to compute thread.currentSummaryHashChain because it hasn't been 'lazily' upgraded yet)
        if(!customCodeIframes[threadId] && aiCharacter.customCode.trim()) {
          await createNewCustomCodeIframeForThread(threadId); // this adds iframe as here: customCodeIframes[threadId]
        }

        if(onProgressMessage) onProgressMessage({message:"waiting for custom code iframe..."});
        while(!customCodeIframes[threadId]) {
          await delay(100);
        }
        if(onProgressMessage) onProgressMessage({message:"rendering messages..."});
        let functionText = `async function({messages}) {
          let messagePromises = [];
          // we process messages in parallel, but process handlers for each message in series
          for(let message of messages) {
            messagePromises.push((async function() {
              for(let fn of oc.messageRenderingPipeline) {
                await fn({message, reader:"${reader}"});
              }
            })());
          }
          await Promise.all(messagePromises);
          return messages;
        }`;

        let originalCustomCodeFormatMessages = await messagesToCustomCodeFormat({messages});
        let functionArg = {messages:originalCustomCodeFormatMessages};
        let renderedMessagesInCustomCodeFormat = await sendCustomCodeIframeMessage(threadId, {type:"function", functionText, functionArg});

        let renderedMessages = await messagesFromCustomCodeFormat({messages:renderedMessagesInCustomCodeFormat, originalMessages:messages, threadId});

        if(!renderedMessages[0].variants) {
          throw new Error("reader message rendering shouldn't be stripping properties from messages");
        }

        return renderedMessages;
      }

      async function messagesToCustomCodeFormat({messages, thread}) {
        if(messages.length === 0) return [];
        if(!thread) {
          thread = await db.threads.get(messages[0].threadId);
        }

        let characters = await db.characters.where("id").anyOf([...new Set(messages.map(m => m.characterId))]).toArray();
        let characterIdToCharacter = {};
        for(let c of characters) {
          characterIdToCharacter[c.id] = c;
        }
        characterIdToCharacter[-1] = await getUserCharacterObj(thread.id);
        characterIdToCharacter[-2] = await getSystemCharacterObj(thread.id);

        messages = structuredClone(messages);
        messages = messages.map((m, i) => {
          let author;
          if(m.characterId == -1) author = "user";
          else if(m.characterId == -2) author = "system";
          else author = "ai";

          let name = messageObjToCharacterName(m, {thread, character:characterIdToCharacter[m.characterId]});
          
          let hiddenFrom = m.hiddenFrom || [];

          // note: we need to pass `id` to custom code because it's used in stuff like renderMessagesForReader - we could map the ids to "public" ones, but it's probably not necessary
          return {id:m.id, author, content:m.message, hiddenFrom, expectsReply:m.expectsReply, name, scene:m.scene, avatar:m.avatar, customData:m.customData, wrapperStyle:m.wrapperStyle, wrapperStyle:m.wrapperStyle, instruction:m.instruction};
        });
        return messages;
      }

      function messageObjToCharacterName(m, {thread, character}) {
        // CAUTION: If you edit this, you may need to edit the equivalent code in createMessageElement (which I haven't bothered to refactor to use this function yet)
        let name;
        if(m.characterId === -1) name = m.name ?? thread.userCharacter.name ?? character.name;
        else if(m.characterId === -2) name = m.name ?? thread.systemCharacter.name ?? character.name;
        // note that we check m.characterId===thread.characterId because thread character is special since custom code can overwrite its name with `thread.character.name`
        else name = m.name ?? (m.characterId === thread.characterId ? (thread.character.name ?? character.name) : character.name);

        return name;
      }

      async function messagesFromCustomCodeFormat({messages, originalMessages, threadId}) {
        messages = structuredClone(messages);

        let thread = await db.threads.get(threadId);
        let threadCharacter = await db.characters.get(thread.characterId);
        let userCharacter = await getUserCharacterObj(thread.id);
        
        let messageCharacters = await db.characters.where("id").anyOf([...new Set(originalMessages.map(m => m.characterId))]).toArray();
        let characterIdToCharacter = {};
        for(let c of messageCharacters) {
          characterIdToCharacter[c.id] = c;
        }
        characterIdToCharacter[-1] = await getUserCharacterObj(thread.id);
        characterIdToCharacter[-2] = await getSystemCharacterObj(thread.id);

        let messageIdToCharacterName = {};
        for(let m of originalMessages) {
          messageIdToCharacterName[m.id] = messageObjToCharacterName(m, {thread, character:characterIdToCharacter[m.characterId]});
        }
        
        // NOTE: originalMessages is needed to "hydrate" the messages with any missing data, assuming that `messages` have `id`s (which they might not, since custom code can completely overwrite messages)
        let allOriginalMessageKeys = [...new Set(originalMessages.map(m => Object.keys(m)).flat())];
        let idToOriginalMessage = {};
        for(let m of originalMessages) {
          idToOriginalMessage[m.id] = m;
        }

        let doneSceneWarning = false;
        let doneAvatarWarning = false;

        messages = messages.map(m => {
          let originalMessage = idToOriginalMessage[m.id];

          m.characterId = -2; // default to 'system'
          if(m.author == "ai") m.characterId = originalMessage?.characterId ?? threadCharacter.id;
          if(m.author == "user") m.characterId = -1;
          delete m.author;

          if(originalMessage) {
            // if they didn't change the name, and the original name was 'null' (which is the case for 'normal' messages - i.e. messages which don't overwrite the name of the character), then we delete the name
            let nameThatWasSentToCustomCode = messageIdToCharacterName[m.id];
            if(!originalMessage.name && m.name === nameThatWasSentToCustomCode) {
              delete m.name;
            }
          }

          if(!Array.isArray(m.hiddenFrom)) {
            m.hiddenFrom = [];
          }
          m.hiddenFrom = m.hiddenFrom.filter(h => h==="ai" || h==="user");
          
          if(![true, false, undefined].includes(m.expectsReply)) {
            m.expectsReply = undefined;
          }
          
          if(m.scene) {
            let exampleStructure = {background:{url:"", filter:""}, music:{url:"", volume:0}};
            let matches = objectKeysAndTypesAreValid(m.scene, exampleStructure);
            if(!matches) {
              if(!doneSceneWarning) alert(`Invalid scene object produced by custom code. Please ensure structure and types are valid. Here's your object:\n\n${JSON.stringify(m.scene, null, 2)}\n\nAnd here's an example structure with valid types:\n\n${JSON.stringify(exampleStructure, null, 2)}\n\nYou don't need to include all properties - you just need to make sure that you don't include invalid ones, and that the types of the ones you include are valid.`);
              doneSceneWarning = true;
              m.scene = null;
            }
          } else {
            m.scene = null;
          }

          if(m.avatar) {
            let exampleStructure = {url:"", shape:"", size:0};
            let matches = objectKeysAndTypesAreValid(m.avatar, exampleStructure);
            if(!matches) {
              debugger;
              if(!doneAvatarWarning) alert(`Invalid avatar object produced by custom code. Please ensure structure and types are valid. Here's your object:\n\n${JSON.stringify(m.avatar, null, 2)}\n\nAnd here's an example structure with valid types:\n\n${JSON.stringify(exampleStructure, null, 2)}\n\nYou don't need to include all properties - you just need to make sure that you don't include invalid ones, and that the types of the ones you include are valid.`);
              doneAvatarWarning = true;
              m.avatar = {};
            }
          } else {
            m.avatar = {};
          }

          // note: it's possible for m.id to be undefined, since custom code can completely replace messages
          // but if it does exist, then we 'rehydrate' it with private data based on the `id`
          if(m.id) {
            let originalMessage = idToOriginalMessage[m.id];
            if(originalMessage) {
              for(let key of allOriginalMessageKeys) {
                // if original message had it, and new one doesn't, then we add it to the new one
                if(originalMessage.hasOwnProperty(key) && !m.hasOwnProperty(key)) {
                  m[key] = originalMessage[key];
                }
              }
            } else {
              // It's possible for the custom code to produce a message with an id that doesn't exist in the original messages because it could have "held on" to a message that existed earlier, but which not longer exists, and then pushed that on to the oc.thread.messages array layer.
              // In this case we just delete the id so that a new one message object will be generated.
              // The new message object will not inherit any of the properties of the old one, which is fine.
              delete m.id;
            }
          }

          m.threadId = threadId;
          m.message = m.content+"";
          delete m.content;
          m.wrapperStyle = (m.wrapperStyle ?? "")+"";
          m.instruction = (!m.instruction || !(m.instruction+"").trim()) ? null : m.instruction+"";

          let obj = createMessageObj(m);
          obj.id = m.id; // see messagesToCustomCodeFormat for why we need ids
          return obj;
        });

        return messages;
      }

      async function threadHasMemoriesOrLore(threadId) {
        let thread = await db.threads.get(threadId);
        let character = await db.characters.get(thread.characterId);

        let loreBookIdEntries = await db.lore.where({bookId:thread.loreBookId}).count();
        let loreBookUrlEntries = await db.lore.where("bookUrl").anyOf(character.loreBookUrls).count();
        let memories = await db.memories.where({threadId, status:"current"}).count();

        return loreBookIdEntries > 0 || loreBookUrlEntries > 0 || memories > 0;
      }

      const retrievedMemoriesTokenLimitFraction = 0.075;

      async function getTokenLimitForSummaryAndMessages(character, thread) {

        let reminderMessage = character.reminderMessage || "";
        if(typeof thread.character.reminderMessage === "string") {
          reminderMessage = thread.character.reminderMessage;
        }

        let roleInstruction = character.roleInstruction || "";
        if(typeof thread.character.roleInstruction === "string") {
          roleInstruction = thread.character.roleInstruction;
        }

        let maxTokenLimit = getModel(thread.modelName).maxSequenceLength;
        if ((thread.tokenLimit > 0) && (thread.tokenLimit < maxTokenLimit)) {
          maxTokenLimit = thread.tokenLimit;
        }
        let tokenLimit = maxTokenLimit;
        
        // buffer due to token count being an estimate
        tokenLimit -= Math.round(maxTokenLimit*0.10);

        tokenLimit -= await countTokens(roleInstruction, thread.modelName); // allow for system message tokens
        tokenLimit -= await countTokens( "("+(reminderMessage||"")+")" , thread.modelName); // allow for reminder message tokens
        tokenLimit -= Math.round(maxTokenLimit*0.15); // allow for bot response
        if(await threadHasMemoriesOrLore(thread.id)) {
          tokenLimit -= Math.round(maxTokenLimit*retrievedMemoriesTokenLimitFraction); // allow for retrieved memories
        }
        return tokenLimit;
      }

      function updateFavicon(url) {
        let link = document.querySelector("link[rel~='icon']");
        if(!link) {
          link = document.createElement('link');
          link.rel = 'icon';
          document.head.appendChild(link);
        }
        link.href = url || "https://user-images.githubusercontent.com/1167575/236043589-96770b23-4378-4114-9807-7dfad8e72f71.png";
      }
      updateFavicon();

      const openAiErrorTypeToReadableError = {
        "insufficient_quota": "Looks like you've used up all your OpenAI credits. You can buy more here:\nhttps://platform.openai.com/account\n\nNote that OpenCharacters does not receive any money from this. OpenAI is the company that provides the 'brain' for your AI. OpenCharacters itself is completely free.",
        "rate_limit_error": "OpenAI is restricting your requests because have made a lot of requests in a short period of time.",
        "authentication_error": "OpenAI doesn't recognize the secret key it's been provided. Click the Settings button, and check that the secret key that has been entered there is still valid.",
      };

      // OpenAPI models frequently mix smart quotes with regular quotes
      function sanitizeQuotes(msg, smartQuoteMethod) {
        if (smartQuoteMethod == "smartQuotes") {
          let smartmsg = smartquotes(msg);
          if (smartmsg != msg) {
            console.log("Regular quotes in reply converted to smart quotes");
            msg = smartmsg;
          }
        } else if (smartQuoteMethod == "plainQuotes") {
          let plainmsg = plainquotes(msg);
          if (plainmsg != msg) {
            console.log("Smart quotes in reply converted to plain quotes");
            msg = plainmsg;
          }
        }
        return msg;
      }
      
      function sanitizeUserMessage(msg, smartQuoteMethod, deleteEmoji) {
        if (smartQuoteMethod === null) {
          debugger;
          return msg;
        }
        msg = sanitizeQuotes(msg, smartQuoteMethod);
        if (deleteEmoji) {
          msg = removeEmoji(msg);
        }
        return msg;
      }

      function sanitizeBotMessage(msg, charname, smartQuoteMethod, deleteEmoji) {
        if ((charname === null) || (smartQuoteMethod === null)) {
          debugger;
          return msg;
        }
        msg = sanitizeQuotes(msg, smartQuoteMethod);
        if (deleteEmoji) {
          msg = removeEmoji(msg);
        }
        // sometimes the gpt-turbo / chat models prefix messages with "characterName:"
        if(msg && msg.startsWith(`${charname}:`)) {
          msg = msg.slice(charname.length+1).trim();
        }
        return msg;
      }

      let currentBotReplySignals;
      // Note: the reason this doesn't just take threadId as a param is because we use it for regenerateMessage() which doesn't necessarily use all messages in a thread, and we also use it for "reply with..." which can use a different AI character
      async function getBotReply({messages, threadId, replyingCharacter=null, replyInstruction=null, onStreamingReplyChunk, onProgressMessage, signals={}, modelNameOverride, allowMultipleReplies=false}={}) {
        currentBotReplySignals = signals;

        // NOTE: Currently, if replyingCharacter only overrides the reminder and instruction.
        // This function doesn't currently use the lorebooks of the replyingCharacter, or the modelName, or other stuff.
        // It just swaps the reminder and instruction. But could change this in the future.

        let originalSendButtonDisabledState = $.sendButton.disabled;
        $.sendButton.disabled = true;

        let repliesToGenerate = 1;
        if (allowMultipleReplies) { repliesToGenerate = Number($.repliesPerSendMenu.value)};

        let thread = await db.threads.get(threadId);

        if(replyingCharacter === null) { // replyingCharacter can be passed in to this function and its reminder/instruction/etc. will be used instead of the thread character's 
          replyingCharacter = await db.characters.get(thread.characterId);
        }
        let threadCharacter = await db.characters.get(thread.characterId);
        const userCharacter = await getUserCharacterObj(thread.id);
        const smartQuoteMethod = threadCharacter.smartQuoteMethod || "smartQuotes";
        const deleteEmoji = threadCharacter.deleteEmoji;
        const memoryLorePlacementMethod = threadCharacter.memoryLorePlacementMethod ?? "startOfPrompt";

        let fullMessagesArr = await prepareMessagesForBot({messages, onProgressMessage});

        onProgressMessage({message:"starting..."});
        
        let modelName = thread.modelName;
        
        if(modelNameOverride) {
          modelName = modelNameOverride;
        }
        
        let thisModelObj = getCharacterModel(modelName);

        let tokenLimitForSummaryAndMessages = await getTokenLimitForSummaryAndMessages(replyingCharacter, thread);
        
        console.log("getBotReply - fullMessagesArr:", fullMessagesArr);
        
        let messagesArr = [];
        let numTokensInContext = await countTokensInMessages(fullMessagesArr, modelName);

        let summaryUsed = null;
        let summaryHashUsed = null;
        
        if(numTokensInContext > tokenLimitForSummaryAndMessages) {
          let fitMessagesInContextMethod = threadCharacter.fitMessagesInContextMethod ?? "summarizeOld";
          
          if(fitMessagesInContextMethod === "dropOld") {
            // push messages into messagesArrToSend until total content reaches token limit
            numTokensInContext = 0;
            for(let i = fullMessagesArr.length-1; i >= 0; i--) {
              if(numTokensInContext + fullMessagesArr[i].content.length > tokenLimitForSummaryAndMessages) break;
              messagesArr.unshift(fullMessagesArr[i]);
              numTokensInContext += await countTokensInMessages([fullMessagesArr[i]], modelName);
            }
          } else if(fitMessagesInContextMethod === "summarizeOld") {
            
            // note: we need upToMessageId because this could be a call from regenerateMessage() which doesn't necessarily use all messages in a thread
            // upToMessageId is inclusive.
            let {summary, instructionHash, remainingMessages} = await computeAndSaveThreadSummaryIfNeeded({threadId, upToMessageId: fullMessagesArr.at(-1).id, onProgressMessage, signals});
            if(signals.stop) return {};
            if(summary === undefined) throw new Error("There should be a summary, since numTokensInContext > tokenLimitForSummaryAndMessages");
            
            summaryUsed = summary;
            summaryHashUsed = instructionHash;

            messagesArr = remainingMessages;
            messagesArr.unshift({
              role: "system",
              content: "Here's a summary of what happened previously:\n\n"+summary,
              _isSummary: true, // this is used for correct placement of memories (it's deleted before sending to API)
            });
            
          } else {
            throw new Error("Invalid fitIntoContextMethod");
          }
        } else {
          messagesArr = fullMessagesArr.slice(0);
        }

        let memoryLoreMarker = {
          role: "system",
          content: "",
          _isMemoryLoreMarker: true
        };

        let startOfConversationMarker = {
          role: "system",
          content: "This is the start of the roleplaying conversation.",
          _isStartOfConversationMarker: true
        };

        messagesArr.unshift(startOfConversationMarker);

        if (memoryLorePlacementMethod === "startOfConversation") {
          messagesArr.unshift(memoryLoreMarker);
        }

        if (memoryLorePlacementMethod === "endOfConversation") {
          messagesArr.push(memoryLoreMarker);
        }

        let messageIdsUsed = [];
        for(let m of messagesArr) {
          if(m._isSummary || m._isMemoryLoreMarker || m._isStartOfConversationMarker) continue;
          if(m.id === undefined) throw new Error("Message ID is undefined.");
          messageIdsUsed.push(m.id);
        }

        if(signals.stop === true) {
          return {};
        }

        const authorToRoleMap = {
          ai: "assistant",
          user: "user",
          system: thisModelObj.systemRole ?? "system",
        };

        let userName = thread.userCharacter.name ?? userCharacter.name;
        let replyingCharacterName = replyingCharacter.name;
        let threadCharacterName = thread.character.name ?? threadCharacter.name;
        let systemName = thread.systemCharacter.name ?? defaultSystemName;

        let roleInstruction = replyingCharacter.roleInstruction?.trim();
        if(thread.character.roleInstruction?.trim()) roleInstruction = thread.character.roleInstruction?.trim();

        if(roleInstruction) {
          let messages = parseMessagesFromTextFormat(roleInstruction);
          if(messages === null) {
            let content = roleInstruction;
            content = content.replaceAll("{{user}}", userName);
            content = content.replaceAll("{{char}}", threadCharacterName);
            messagesArr.unshift({role:authorToRoleMap["system"], content});
          } else {
            let messagesToAdd = [];
            for(let message of messages) {
              if(message.hiddenFrom?.includes("ai")) continue; // doesn't really make sense to hide from ai in reminder message - this is just to be consistent
              let content = message.content;
              content = content.replaceAll("{{user}}", userName);
              content = content.replaceAll("{{char}}", threadCharacterName);
              messagesToAdd.push({role:authorToRoleMap[message.author], content});
              // can't just unshift on to messagesArr here because messages would be in wrong order
            }
            messagesArr = [...messagesToAdd, ...messagesArr];
          }          
        }

        let reminderMessage = replyingCharacter.reminderMessage?.trim();
        if(thread.character.reminderMessage?.trim()) reminderMessage = thread.character.reminderMessage?.trim();

        if(reminderMessage) {
          let messages = parseMessagesFromTextFormat(reminderMessage);
          if(messages === null) {
            let content = reminderMessage;
            content = content.replaceAll("{{user}}", userName);
            content = content.replaceAll("{{char}}", threadCharacterName);
            messagesArr.push({role:authorToRoleMap["system"], content, _isReminder:true});
          } else {
            for(let message of messages) {
              if(message.hiddenFrom?.includes("ai")) continue; // doesn't really make sense to hide from ai in reminder message - this is just to be consistent
              let content = message.content;
              content = content.replaceAll("{{user}}", userName);
              content = content.replaceAll("{{char}}", threadCharacterName);
              messagesArr.push({role:authorToRoleMap[message.author], content, _isReminder:true});
            }
          }          
        }

        for(let m of messagesArr) {
          delete m.id; // id is added by prepareMessagesForBot() because it's needed for some functions (e.g. summarization), but we don't want to send it to the API
        }

        // this is already done in prepareMessagesForBot() but we do it again here to ensure we've removed hidden stuff from reminder message, instruction message, etc.
        for(let m of messagesArr) {
          m.content = m.content.replace(/<!--hidden-from-ai-start-->.+?<!--hidden-from-ai-end-->/gs, "");
        }

        let postReminderMessageContent = "";
        if(replyingCharacterName !== threadCharacterName || new Set(messagesArr.map(m => m.name)).size > 2) {
          postReminderMessageContent = `The next message will be written by ${replyingCharacterName}.`;
        }
        if(replyInstruction) {
          postReminderMessageContent += ` The next message should be written according to this instruction: ${replyInstruction}.`;
        }
        if(postReminderMessageContent) {
          messagesArr.push({role:authorToRoleMap["system"], content:"("+postReminderMessageContent+")"});
        }


        let memoryIdBatchesUsed = [];
        let loreIdsUsed = [];
        let memoryQueriesUsed = [];

        let loreBookIdEntries = await db.lore.where({bookId:thread.loreBookId}).toArray();
        let loreBookUrlEntries = await db.lore.where("bookUrl").anyOf(threadCharacter.loreBookUrls).toArray();
        let loreEntries = [...loreBookIdEntries, ...loreBookUrlEntries];
        let memories = await db.memories.where({threadId, status:"current"}).toArray();
        memories.sort((a,b) => a.index - b.index);
        if(memories.length > 0 || loreEntries.length > 0) {
          onProgressMessage({message:"get mem/lore queries"});

          memories.forEach(m => m._type="memory");
          loreEntries.forEach(m => m._type="lore");
          let memoriesAndLore = [...memories, ...loreEntries];

          // NOTE: I replace newlines in messages with spaces because I *think* the AI was getting confused about the structure of the messages
          const messagesToTextFormat = (messages) => messages.filter(m => !m._isReminder).slice(-10).map(m => `[[${m.name || "System"}]]: ${m.content.replace(/\n/g, " ")}`).join("\n\n");
          
          let mostRecentMessage = messagesArr.filter(m => m.role === "user" && !m._isReminder).at(-1);
          if(!mostRecentMessage) mostRecentMessage = messagesArr.at(-1);

          let searchQueries = [];
          
          // get memory search queries:
          let rawResult = await getChatCompletion({
            messages: [
              {role:"user", content: `Here's the list of messages:\n\n${messagesToTextFormat(messagesArr)}\n\n(this is the end of the messages)`},
              // {role:"user", content: `${replyingCharacterName} will reply next. ${replyingCharacterName} is actually an AI/bot who has a database of memories. Please write a list of suggested keyphrases to help ${replyingCharacterName} search their memory database for facts that may be relevant to their reply. Try to surface facts that are relevant to their *very next* message - rephrase/reword keyphrases multiple times if needed. Look for specific entities/things/claims/topics/people/places/questions/etc. in the previous message (the one ending with "...${mostRecentMessage.content.slice(-100)}" and the ones before that) that may be important. Write several rephrasings of important queries. No need to query for stuff that you already know the answer to. Reply with this template:\n\nMEMORY SEARCH KEYPHRASES:\n- <keyphrase 1>\n- <keyphrase 2>\n- ...`},
              // {role:"user", content: `The next message will come from ${replyingCharacterName}. If you were tasked with writing that message as ${replyingCharacterName}, and you had access to a database of ${replyingCharacterName}'s memories, what search queries would you use on that database? Respond with a list of keyphrases that you would use to search the memory database for things that would be useful if you were trying to write an accurate/in-character/correct message as ${replyingCharacterName}. Try to surface facts that are relevant to their *very next* message - rephrase/reword keyphrases multiple times if needed. Look for specific entities/things/claims/topics/people/places/questions/etc. in the previous message (the one ending with "...${mostRecentMessage.content.slice(-100)}" and the ones before that) that may be important. Write several rephrasings of important queries. Try to search the database for things you don't know, but which might be important for writing a reply that makes sense. Reply with this template:\n\nMEMORY SEARCH KEYPHRASES:\n- <keyphrase 1>\n- <keyphrase 2>\n- ...`},
              {role:"user", content: `You are tasked with writing the next message on behalf of ${replyingCharacterName}. However, there is a large database of memories/lore/facts/etc. which you'll need to use to make sure your reply makes sense, and doesn't contradict established facts/lore/memories. Respond with a list of keyphrases that you would like to use to search the database for useful information. Try to surface facts that are relevant to ${replyingCharacterName}'s *very next* message - rephrase/reword keyphrases multiple times if needed. Look for specific entities/things/claims/topics/people/places/questions/etc. in the previous message (the one ending with "...${mostRecentMessage.content.slice(-100)}" and the ones before that) that may be important. Write several rephrasings of important queries. Try to search the database for things you don't know, but which might be important for writing a reply that doesn't contradict established world lore/facts/etc. Reply with this template:\n\nMEMORY SEARCH KEYPHRASES:\n- <keyphrase 1>\n- <keyphrase 2>\n- ...`},
            ],
            modelName,
            temperature: 0.7,
            threadId, // just used to track token usage
            signals,
          });
          if(!rawResult) {
            if(!signals.stop) alert("There was an error getting the memory search queries. Please try again.");
            return {};
          }

          if(signals.stop === true) return {};

          onProgressMessage({message:"got queries"});

          searchQueries.push(...rawResult.trim().split("\n").filter(l => l.startsWith("- ") || l.startsWith(" - ")).map(l => l.trim().replace(/^ ?- /, "").trim()).slice(0, 10));

          searchQueries = searchQueries.map(q => q.replace(/^"(.+)"$/, "$1"));

          console.log(`MEMORY/LORE SEARCH QUERIES:\n${searchQueries.join("\n")}`);
          addToDebugLog(`<b>Memory queries:</b><br>${searchQueries.join("<br>")}`);

          memoryQueriesUsed.push(...searchQueries);

          onProgressMessage({message:"embed queries"});

          let embeddingModelName = await getRealTextEmbeddingModelName(thread.textEmbeddingModelName);
          let embeddingModel = availableModels[embeddingModelName];
          if (embeddingModel === undefined) {
            throw new Error(`computing memories/lore using unknown model ${embeddingModelName}`);
          }
          // The average inverse distance between two random embeddings varies on the model
          let averageInverseDistance = embeddingModel.averageInverseDistance;
          if (averageInverseDistance === undefined) {
            throw new Error(`can't find average inverse distance for model ${embeddingModelName}`);
          }

          let searchEmbeddings = await embedTexts({textArr:searchQueries, modelName:embeddingModelName});

          if(signals.stop === true) return {};

          const scoreThreshold = 0; // this is zero now because we subtract the average inverseDistance from the score when computing the score
          console.log("memory/lore score threshold:", scoreThreshold);

          onProgressMessage({message:"calc mem/lore scores"});

          for(let entry of memoriesAndLore) {
            if(!entry.embeddings[embeddingModelName]) {
              // embeddings should have been computed during addThread
              if(entry._type === "memory") {
                throw new Error(`memory doesn't have embedding for model ${embeddingModelName}:\ntext:${entry.text}`);
              } else {
                throw new Error(`lore doesn't have embedding for model ${embeddingModelName}:\ntext:${entry.text}\nbookUrl:${entry.bookUrl}\nbookId:${entry.bookId}`);
              }
            }
          }

          for(let entry of memoriesAndLore) {
            if(entry._relevanceScore === undefined) entry._relevanceScore = 0;
            let i = 0;
            for(let searchEmbedding of searchEmbeddings) {
              let multiplier = 1;
              if(i === 0) multiplier = 3; // first search query is likely to be much more relevant (later ones tend to be grasping at straws)
              let inverseDistance = (1 / cosineDistance(searchEmbedding, entry.embeddings[embeddingModelName]));
              let score = (inverseDistance-averageInverseDistance) * multiplier;
              entry._relevanceScore += score;
              i++;
            }
          }
          
          const maxLoggedMemoriesAndLore = 100;
          const maxLoggedMemoriesAndLoreTextLength = 80;
          let loggedMemoriesAndLore = memoriesAndLore.sort((a,b) => b._relevanceScore - a._relevanceScore).slice(0, maxLoggedMemoriesAndLore);
          for (let entry of loggedMemoriesAndLore) {
            console.log(`score of ${entry._relevanceScore.toFixed(1)} for this ${entry._type} entry: ${entry.text.slice(0, maxLoggedMemoriesAndLoreTextLength)}`);
          }

          let relevantMemoriesAndLore = memoriesAndLore.filter(m => m._relevanceScore > scoreThreshold).sort((a, b) => b._relevanceScore - a._relevanceScore);
          console.log("relevant memories/lore:", relevantMemoriesAndLore.slice(0, 1000));

          onProgressMessage({message:"get top mem/lore"});

          let relevantMemories = relevantMemoriesAndLore.filter(m => m._type === "memory");
          let relevantLore = relevantMemoriesAndLore.filter(m => m._type === "lore");
          
          // we create "batches" of memories - i.e. chronologically ordered groups of memories that are relevant and adjacent
          // use top memories as "seeds" for each batch:
          // CAUTION: We need to `slice(0, 20)` not to stay under token limit (we drop them later if there are too many), but because we extend batches based on adjacent memories that occur in `memoryBatches`, and that can result in a looonng loop if we include every memory as a batch.
          let memoryBatches = relevantMemories.slice(0, 20).sort((a,b) => a.index-b.index).map(m => ({memories:[m], seedMemory:m}));
          memoryBatches.sort((a,b) => b.seedMemory._relevanceScore - a.seedMemory._relevanceScore);

          let maxMemoryIndex = memories.at(-1)?.index ?? 0;
          let minMemoryIndex = memories[0]?.index ?? 0; // note: the term `index` is actually a misnomer here - should be `order` or something, since the `status:"noncurrent"` memories can create gaps in the `status:"current"` memories.

          for(let i = 0; i < memoryBatches.length; i++) {
            let batch = memoryBatches[i];
            let numPreviousAdded = 0;
            let numNextAdded = 0;
            let numPreviousToAdd = 1;
            let numNextToAdd = 1;
            let addedNext;
            let addedPrevious;
            while(true) {
              if(batch.memories.length >= 1+numPreviousToAdd+numNextToAdd) break;
              addedNext = false;
              addedPrevious = false;

              if(numNextAdded < numNextToAdd) {
                let lastMemory = batch.memories.at(-1);
                if(lastMemory === undefined) debugger;
                let mI = memories.findIndex(m => m === lastMemory);
                if(memories[mI+1]) {
                  batch.memories.push(memories[mI+1]);
                  addedNext = true;
                  numNextAdded++;
                }
              }

              if(numPreviousAdded < numPreviousToAdd) {
                let firstMemory = batch.memories[0];
                if(firstMemory === undefined) debugger;
                let mI = memories.findIndex(m => m === firstMemory);
                if(memories[mI-1]) {
                  batch.memories.unshift(memories[mI-1]);
                  addedPrevious = true;
                  numPreviousAdded++;
                }
              }

              // if we added a nextMemory or previousMemory that's the same as one of the seeds in the batches that
              // we haven't processed yet, then we should remove that batch and widen the limits on this batch
              if(addedNext) {
                let lastMemory = batch.memories.at(-1);
                let batchToRemove = memoryBatches.slice(i+1).find(b => b.seedMemory.id === lastMemory.id);
                if(batchToRemove) {
                  memoryBatches.splice(memoryBatches.indexOf(batchToRemove), 1);
                  numNextToAdd++;
                }
              }
              if(addedPrevious) {
                let firstMemory = batch.memories[0];
                let batchToRemove = memoryBatches.slice(i+1).find(b => b.seedMemory.id === firstMemory.id);
                if(batchToRemove) {
                  memoryBatches.splice(memoryBatches.indexOf(batchToRemove), 1);
                  numPreviousToAdd++;
                }
              }

              if(!addedNext && !addedPrevious) break;
            }
          }

          for(let batch of memoryBatches) {
            // use the max rather than the mean, because the memories around a SUPER-relevant memory could be irrelevant (at least, score-wise) and thus drag it down
            batch._relevanceScore = batch.memories.reduce((max, m) => Math.max(max, m._relevanceScore), -99999999);
          }
          memoryBatches.sort((a,b) => b._relevanceScore - a._relevanceScore);
          relevantLore.sort((a,b) => b._relevanceScore - a._relevanceScore);

          console.log("memoryBatches:", memoryBatches.slice(0));
          console.log("relevantLore:", relevantLore.slice(0));
          if(memoryBatches.length > 0 || relevantLore.length > 0) {
            
            let retrievalPrefixText = `Some potentially helpful things/facts/happenings that may or may not be relevant:`;
            let memoryPrefixText = `# Some stuff that happened previously:\n`;
            let lorePrefixText = `# A fact or piece of world 'lore':\n`;
            let memoryJoinerText = ` ‚Üí `;

            const createMemoriesAndLoreMessageContent = () => {
              if(memoryBatches.length === 0 && relevantLore.length === 0) return "";

              let chunks = [retrievalPrefixText];
              if(memoryBatches.length > 0) {
                for(let batch of memoryBatches) {
                  chunks.push(`${memoryPrefixText}${batch.memories.map(m => m.text).join(memoryJoinerText)}`);
                }
              }
              if(relevantLore.length > 0) {
                for(let entry of relevantLore) {
                  chunks.push(`${lorePrefixText}${entry.text}`);
                }
              }
              return chunks.join("\n\n");
            };

            onProgressMessage({message:"dropping mem/lore"});
            await delay(10); // to ensure progress message is rendered in case of infinite loop below - helpful for bug reports

            for(let batch of memoryBatches) {
              for(let memory of batch.memories) {
                memory._tokenCount = await countTokens(memory.text, modelName);
              }
            }
            for(let entry of relevantLore) {
              entry._tokenCount = await countTokens(entry.text, modelName);
            }
            let retrievalPrefixTextTokenCount = await countTokens(retrievalPrefixText, modelName);
            let memoryPrefixTextTokenCount = await countTokens(memoryPrefixText, modelName);
            let lorePrefixTextTokenCount = await countTokens(lorePrefixText, modelName);
            let memoryJoinerTokenCount = await countTokens(memoryJoinerText, modelName);

            function countTokensInRetrievalText() {
              let tokensInPrefixes = retrievalPrefixTextTokenCount + memoryPrefixTextTokenCount*memoryBatches.length + lorePrefixTextTokenCount*relevantLore.length;
              let tokensInMemories = memoryBatches.reduce((count, b) => count + b.memories.reduce((count, m) => count+m._tokenCount, 0), 0);
              let tokensInLore = relevantLore.reduce((count, e) => count + e._tokenCount, 0);
              let tokensInJoiners = memoryJoinerTokenCount*(memoryBatches.length-1);
              return tokensInPrefixes + tokensInMemories + tokensInLore + tokensInJoiners;
            }

            let retrievalTextTokenCount;

            function dropBatchOrMemoryFromBatch() {
              let b = memoryBatches.pop();
              let tokensInDroppedBatch = b.memories.reduce((count, m) => count+m._tokenCount, 0);
              if(tokensInDroppedBatch > 0.3*retrievalTextTokenCount) {
                // if the dropped batch is a significant fraction of the total, then we should just drop one memory from it instead - the one from either end that has lowest score
                if(b.memories.at(0)._relevanceScore < b.memories.at(-1)._relevanceScore) {
                  b.memories.shift();
                } else {
                  b.memories.pop();
                }
                if(b.memories.length > 0) {
                  memoryBatches.push(b);
                }
              }
            }
            
            // drop worst entries/batches until we're under token limit allocated to memories:
            while(1) {
              retrievalTextTokenCount = await countTokensInRetrievalText();
              if(retrievalTextTokenCount < retrievedMemoriesTokenLimitFraction * getModel(modelName).maxSequenceLength) {
                break;
              }

              if(relevantLore.length === 0) {
                dropBatchOrMemoryFromBatch();
              } else if(memoryBatches.length === 0) {
                relevantLore.pop();
              } else {
                if(memoryBatches.at(-1)._relevanceScore < relevantLore.at(-1)._relevanceScore) dropBatchOrMemoryFromBatch();
                else if(memoryBatches.at(-1)._relevanceScore >= relevantLore.at(-1)._relevanceScore) relevantLore.pop();
                else throw new Error("This shouldn't happen - weird relevance score bug while dropping memories/lore.");
              }
            }
            // put memoryBatches in chronological order:
            memoryBatches.sort((a,b) => a.seedMemory.id - b.seedMemory.id);
            if(memoryBatches.length > 0 || relevantLore.length > 0) {

              // batch merging:
              for(let i = 0; i < memoryBatches.length; i++) {
                let batch = memoryBatches[i];
                // if any of the memories in this batch are in the next batch, then we should remove the overlapping memories from the next batch and then add the remaining memories to this batch:
                let nextBatch = memoryBatches[i+1];
                if(nextBatch) {
                  let memoryIdsInThisBatch = batch.memories.map(m => m.id);
                  let memoryIdsInNextBatch = nextBatch.memories.map(m => m.id);
                  let thereAreOverlappingMemories = memoryIdsInThisBatch.some(id => memoryIdsInNextBatch.includes(id));
                  if(thereAreOverlappingMemories) {
                    // add the non-overlapping memories to this batch:
                    batch.memories.push(...nextBatch.memories.filter(m => !memoryIdsInThisBatch.includes(m.id)));
                    // as a quick sanity check, ensure that all memory.index values are larger than the previous one:
                    for(let j = 1; j < batch.memories.length; j++) {
                      if(batch.memories[j].index <= batch.memories[j-1].index) {
                        console.error("memory.index values are not in chronological order - during memory batch merging");
                        debugger; // this shouldn't happen
                      }
                    }
                    // remove next batch:
                    memoryBatches.splice(i+1, 1);
                    // we need to re-check this batch against the next batch, so decrement i:
                    i--;
                  }
                }
              }

              memoryIdBatchesUsed = memoryBatches.map(b => b.memories.map(m => m.id));
              loreIdsUsed = relevantLore.map(l => l.id);

              if(memoryIdBatchesUsed.flat().filter(id => id === undefined).length > 0) {
                debugger; // this shouldn't happen
              }

              let insertionPointIndex = messagesArr.findIndex(m => m._isMemoryLoreMarker);
              let content = createMemoriesAndLoreMessageContent();
              if(content) {
                let memoriesMessage = {role:authorToRoleMap["system"], content};
                if (insertionPointIndex !== -1) {
                  messagesArr[insertionPointIndex] = memoriesMessage;
                } else if (memoryLorePlacementMethod === "startOfPrompt") {
                  messagesArr.unshift(memoriesMessage);
                } else {
                  throw("Couldn't find right place to insert memories");
                }
              }
            }
          }
        }

        if(signals.stop === true) {
          return {};
        }

        for(let message of messagesArr) {
          // delete tags that are used only for memory and lore management
          if(message._isSummary !== undefined) delete message._isSummary;
          if(message._isReminder !== undefined) delete message._isReminder;
          if(message._isMemoryLoreMarker !== undefined) delete message._isMemoryLoreMarker;
          if(message._isStartOfConversationMarker !== undefined) delete message._isStartOfConversationMarker;
        }

        if (repliesToGenerate > 1) {
          onProgressMessage({message:`querying api for ${repliesToGenerate} responses...`})
        } else {
          onProgressMessage({message:"querying api..."});
        }

        console.log("getBotReply - messagesArr:", messagesArr);

        let apiKey = thisModelObj.apiKey;
        
        if(apiKey === "<OPENAI>") {
          apiKey = await getOpenAiApiKey();
        }

        async function handleStreamingResponse(reader) {
          result = ""; // `result` comes from parent scope
          let chunkI = 0;
          let prevText = null;
          let textBuffer = "";
          const streamId = (await sha256Text(Math.random().toString()+Math.random().toString())).slice(0, 16);

          function processLine(line) {
            if(!line.trim()) return;
            if(line.startsWith("data: ")) line = line.slice(6);
            if(line === "[DONE]") return;

            let json;
            try {
              json = JSON.parse(line);
            } catch(e) {
              alert(`The streaming API response had some invalid JSON:\n\n${line}\n\n---\n\n${textBuffer}`);
              console.error(e, line, textBuffer);
            }
            let text;

            if(json.choices[0].text !== undefined) { // this indicates that we're streaming from a 'completion' (non-chat) model
              text = json.choices[0].text;
              if(chunkI===0) text = text.trimStart(); // trimStart due to the way we prompt 'completion' models (we show messages with a space after `[name]:`)
            } else {
              if(json.choices[0].delta.role) return; // first response always starts with a role=assistant delta to indicate that the assistant is the one talking
              if(!json.choices[0].delta.content) return; // final response alway has empty delta object
              text = json.choices[0].delta.content;
            }
            
            result += text;
            onStreamingReplyChunk({text, isFirst:chunkI===0});

            // we keep the StreamingMessageChunk events "one step behind" so that we can set last:true on the last chunk
            if(prevText === null) {
              prevText = text;
            } else {
              triggerStreamingMessageChunkCustomCodeEvent(threadId, {text:prevText, index:chunkI-1, last:false, streamId});
              prevText = text;
            }

            chunkI++;
          }

          while(true) {
            const res = await reader?.read();
            if(res?.done) {
              // process all remaining lines:
              for(let line of textBuffer.split("\n")) {
                processLine(line);
              }
              break;
            }
            if(chunkI === 0 && res?.value.trim().startsWith("{")) { // errors don't start with 'data'
              let json = JSON.parse(res.value);
              if(!signals.stop) alert("Error streaming message:\n\n"+JSON.stringify(json.error, null, 2));
              break;
            } else {
              textBuffer += res.value;

              // keep consuming up to first new line while a newline exists:
              while(textBuffer.indexOf("\n") !== -1) {
                let newLineIndex = textBuffer.indexOf("\n");
                let line = textBuffer.slice(0, newLineIndex);
                textBuffer = textBuffer.slice(newLineIndex+1);
                processLine(line);
              }
            }
            if(signals.stop === true) {
              break;
            }
          }
          triggerStreamingMessageChunkCustomCodeEvent(threadId, {text:prevText, index:chunkI-1, last:true, streamId});
        }


        let modelType = getModel(modelName).type;
        if(!modelType) throw new Error("modelType is undefined for model "+modelName);
        let modelNoTemperatureSupport = getModel(modelName).noTemperatureSupport;
        let getStreamingResponse = threadCharacter.streamingResponse;
        if (getStreamingResponse && (repliesToGenerate > 1)) {
          console.log("Disabling streaming response for multiple replies");
          getStreamingResponse = false;
        }
        let result = undefined;
        let apiTokenUsage;

        let headers = {"Content-Type": "application/json"};
        if(apiKey) headers.authorization = `Bearer ${apiKey}`;
        if(apiKey && new URL(thisModelObj.endpointUrl).hostname.includes("azure")) headers["api-key"] = apiKey;

        let abortController = new AbortController();
        let abortSignal = abortController.signal;
        let abortCheckInterval = setInterval(() => {
          if(signals.stop) {
            abortController.abort();
            clearInterval(abortCheckInterval);
          }
        }, 100);
        setTimeout(() => {
          clearInterval(abortCheckInterval); // hacky, but just in case this code below throws an error before it reaches the clearInterval
        }, 1000*60*10) // <-- must be longer than the longest possible response time

        if(modelType === "chat-completion") {

          let tokensInPrompt = await countTokensInMessages(messagesArr, modelName);

          let data = {
            model: modelName,
            messages: messagesArr,
          };
          if (!(modelNoTemperatureSupport)) {
            data.temperature = replyingCharacter.temperature ?? 0.7;
          }
          data.n = repliesToGenerate;

          if(replyingCharacter.topP) data.top_p = replyingCharacter.topP;
          if(replyingCharacter.frequencyPenalty) data.frequency_penalty = replyingCharacter.frequencyPenalty;
          if(replyingCharacter.presencePenalty) data.presence_penalty = replyingCharacter.presencePenalty;
          if(replyingCharacter.stopSequences && replyingCharacter.stopSequences.length > 0) data.stop = replyingCharacter.stopSequences;

          if(replyingCharacter.maxTokensPerMessage) {
            // note that the chat completion endpoint defaults to unlimited max_tokens (i.e. uses [up to] the full context size), so we only need to mess with it if the user has set a limit
            let max_tokens = Math.round((getModel(modelName).maxSequenceLength - tokensInPrompt) * 0.95); // *0.95 just to add a bit of a buffer in case of a few off-by-one errors, or whatever
            if(max_tokens > replyingCharacter.maxTokensPerMessage) {
              max_tokens = replyingCharacter.maxTokensPerMessage;
            }
            if (model.useMaxCompletionTokens) {
              data.max_completion_tokens = max_tokens;
            } else {
              data.max_tokens = max_tokens;
            }
          }

          if(getStreamingResponse) {
            data.stream = true;
            apiTokenUsage = {prompt:tokensInPrompt, completion:0, total:tokensInPrompt};
            
            let response = await fetch(thisModelObj.endpointUrl, {
              headers,
              body: JSON.stringify(data),
              method: "POST",
              signal: abortSignal,
            }).catch(e => {
              if(!signals.stop) {
                if(e.stack.toString().toLowerCase().includes("failed to fetch")) alert("Looks like there was a network error. This can happen now and then - you may need to refresh the page. If it's happening quite often, please report this on Github or Discord.\n\ngetChatCompletion: "+e.stack);
                else alert("getBotReply > modelType:chat:streaming > fetch: \n\n"+e.stack);
              }
            });
            
            if(response) { // <-- e.g. request was aborted by user
              const reader = response.body?.pipeThrough(new TextDecoderStream()).getReader();
              await handleStreamingResponse(reader).catch(e => {  // this appends chunks to the `result` variable
                if(!signals.stop) alert("getBotReply > modelType:chat > handleStreamingResponse:\n\n"+e.stack);
              });
              result = sanitizeBotMessage(result, replyingCharacterName, smartQuoteMethod, deleteEmoji);
              apiTokenUsage.completion += await countTokens(result, modelName);
              apiTokenUsage.total += await countTokens(result, modelName);
            }
            
          } else {
            let json = await fetch(thisModelObj.endpointUrl, {
              method: 'POST',
              headers,
              body: JSON.stringify(data),
              signal: abortSignal,
            }).then(r => r.json()).catch(e => {
              if(!signals.stop) {
                if(e.stack.toString().toLowerCase().includes("failed to fetch")) alert("Looks like there was a network error. This can happen now and then - you may need to refresh the page. If it's happening quite often, please report this on Github or Discord.\n\ngetChatCompletion: "+e.stack);
                else alert("getBotReply > modelType:chat:non-streaming > fetch: \n\n"+e.stack);
              }
            });

            if(json?.error) {
              console.error(json.error);
              if(!signals.stop) alert(`Error during getBotReply:\n` + (openAiErrorTypeToReadableError[json.error.type] ? openAiErrorTypeToReadableError[json.error.type] : JSON.stringify(json.error, null, 2)+"\n\nPlease screenshot this error and share on our Discord server or Github."));
            }
            if(json?.usage) {
              apiTokenUsage = {prompt:json?.usage.prompt_tokens, cachedprompt:json?.usage.prompt_token_details?.cached_tokens, completion:json?.usage.completion_tokens, total:json?.usage.total_tokens};
            }
            const resultsReturned = json?.choices?.length;
            if (allowMultipleReplies) {
              result = new Array();
              for (let i = 0; i < json?.choices?.length; i++) {
                result.push(sanitizeBotMessage(json?.choices?.[i].message.content, replyingCharacterName, smartQuoteMethod, deleteEmoji));
              }
            } else {
              result = sanitizeBotMessage(json?.choices?.[0].message.content, replyingCharacterName, smartQuoteMethod, deleteEmoji);
            }
          }

        } else {

          let promptIntro = `Below are some message logs between ${replyingCharacterName} and other characters. Some messages are "System" messages which do not originate from any character.\n\nThe chat begins now:\n\n\n\n`;
          let prompt = promptIntro + messagesArr.map(m => (m.role=="user"?`[[${m.name ?? userName}]]: `:m.role=="system"?`[[SYSTEM]]: `:`[[${m.name}]]: `)+m.content).join("\n\n") + `\n\n[[${replyingCharacterName}]]:`;
          
          // davinci *requires* max_tokens else it defaults to 16 (unlike turbo which defaults to infinity)
          let max_tokens = Math.round((getModel(modelName).maxSequenceLength - await countTokens(prompt, modelName)) * 0.95); // *0.95 just to add a bit of a buffer in case of a few off-by-one errors, or whatever
          
          if(replyingCharacter.maxTokensPerMessage && max_tokens > replyingCharacter.maxTokensPerMessage) {
            max_tokens = replyingCharacter.maxTokensPerMessage;
          }

          let data = {
            model: modelName,
            prompt,
            stop: [`\n\n[[`],
          };
          if (!(model.noTemperatureSupport)) {
            data.temperature = replyingCharacter.temperature ?? 0.7;
          }
          if (model.useMaxCompletionTokens) {
            data.max_completion_tokens = max_tokens;
          } else {
            data.max_tokens = max_tokens;
          }
          if(replyingCharacter.topP) data.top_p = replyingCharacter.topP;
          if(replyingCharacter.frequencyPenalty) data.frequency_penalty = replyingCharacter.frequencyPenalty;
          if(replyingCharacter.presencePenalty) data.presence_penalty = replyingCharacter.presencePenalty;
          if(replyingCharacter.stopSequences && replyingCharacter.stopSequences.length > 0) data.stop.push(...replyingCharacter.stopSequences);

          if(getStreamingResponse) {
            data.stream = true;
            let tokensInPrompt = await countTokensInMessages(messagesArr, modelName);
            apiTokenUsage = {prompt:tokensInPrompt, completion:0, total:tokensInPrompt};

            let response = await fetch(thisModelObj.endpointUrl, {
              headers,
              body: JSON.stringify(data),
              method: "POST",
              signal: abortSignal,
            }).catch(e => {
              if(!signals.stop) {
                if(e.stack.toString().toLowerCase().includes("failed to fetch")) alert("Looks like there was a network error. This can happen now and then - you may need to refresh the page. If it's happening quite often, please report this on Github or Discord.\n\ngetChatCompletion: "+e.stack);
                else alert("getBotReply > modelType:general:streaming > fetch: \n\n"+e.stack);
              }
            });
            
            if(response) { // <-- e.g. request was aborted by user
              const reader = response.body?.pipeThrough(new TextDecoderStream()).getReader();
              await handleStreamingResponse(reader).catch(e => {  // this appends chunks to the `result` variable
                if(!signals.stop) alert("getBotReply > modelType:chat > handleStreamingResponse:\n\n"+e.stack);
              });
              apiTokenUsage.completion += await countTokens(result, modelName);
              apiTokenUsage.total += await countTokens(result, modelName);
            }

          } else {
            let json = await fetch(thisModelObj.endpointUrl, {
              method: "POST",
              headers,
              body: JSON.stringify(data),
              signal: abortSignal,
            }).then(r => r.json()).catch(e => {
              if(!signals.stop) {
                if(e.stack.toString().toLowerCase().includes("failed to fetch")) alert("Looks like there was a network error. This can happen now and then - you may need to refresh the page. If it's happening quite often, please report this on Github or Discord.\n\ngetChatCompletion: "+e.stack);
                else alert("getBotReply > modelType:general:non-streaming > fetch: \n\n"+e.stack);
              }
            });
            
            if(json?.error) {
              console.error(json.error);
              if(!signals.stop) alert(`Error during getBotReply:\n` + (openAiErrorTypeToReadableError[json.error.type] ? openAiErrorTypeToReadableError[json.error.type] : JSON.stringify(json.error, null, 2)+"\n\nPlease screenshot this error and share on our Discord server or Github."));
            }

            if(json?.usage) {
              apiTokenUsage = {prompt:json?.usage.prompt_tokens, cachedprompt:json?.usage.prompt_token_details?.cached_tokens, completion:json?.usage.completion_tokens, total:json?.usage.total_tokens};
            }
            result = sanitizeBotMessage(json?.choices?.[0].text.trim(), replyingCharacterName, smartQuoteMethod, deleteEmoji);
          }
        }

        if(apiTokenUsage) {
          await trackTokenUsage({threadId, modelName, usageData:apiTokenUsage, purpose:"bot reply"});
        }
        
        onProgressMessage({message:"finished"});

        clearInterval(abortCheckInterval);

        $.sendButton.disabled = originalSendButtonDisabledState;

        return {message:result, memoryIdBatchesUsed, loreIdsUsed, summaryHashUsed, memoryQueriesUsed, messageIdsUsed};
      }

      function getCurrentDateHour() {
        // get date object, rounded down to nearest hour
        let date = new Date();
        date.setMinutes(0, 0, 0); // set minutes, seconds, ms, all to 0
        return date.getTime();
      }

      async function trackTokenUsage({threadId, modelName, usageData, purpose}) {
        const cachedTokens = (usageData.cachedprompt) || 0;
        console.log(`Token usage tracked for ${purpose}: prompt ${usageData.prompt}, cached prompt ${cachedTokens}, completion ${usageData.completion}, total ${usageData.total}`);
        
        // get the character id:
        let thread = await db.threads.get(threadId);
        let characterId = thread.characterId;
        // get current usage:
        let dateHour = getCurrentDateHour();
        let entry = await db.usageStats.get({dateHour, threadId, modelName});
        // create entry if it doesn't exist:
        if(!entry) {
          entry = {dateHour, threadId, modelName, characterId, tokens:{prompt:0, cachedprompt:0, completion:0, total:0}};
          await db.usageStats.add(entry);
        }
        // update db with new usage:
        entry.tokens.completion += usageData.completion;
        entry.tokens.cachedprompt += cachedTokens;
        entry.tokens.prompt += usageData.prompt;
        entry.tokens.total += usageData.total;
        // need to use `where+modify` instead of `update` because I can't update schema to change the mistaken primary key of threadId to [dateHour+threadId+modelName] without making a mess: https://github.com/dexie/Dexie.js/issues/1025
        // await db.usageStats.where({dateHour, threadId, modelName}).modify(e => e.tokens=entry.tokens);
        await db.usageStats.put(entry);
        // update ui:
        await updateThreadUsageStatsSpendDisplay(threadId);
      }


      async function getChatCompletion(opts) {
        if(!opts.signals) opts.signals = {};
        if(opts.attemptsSoFar === undefined) opts.attemptsSoFar = 0;
        if(opts.maxAttempts === undefined) opts.maxAttempts = 2;
        let {messages, modelName, temperature, stopSequences, topP, frequencyPenalty, presencePenalty, threadId, retries, triesAttempted, signals} = opts;
        // note: threadId is just for tracking token usage

        messages = structuredClone(messages);

        messages = messages.filter(m => !m.hiddenFrom || !m.hiddenFrom.includes("ai"));

        for(let m of messages) {
          m.content = m.content.replace(/<!--hidden-from-ai-start-->.+?<!--hidden-from-ai-end-->/gs, "");
        }

        let modelObj = getModel(modelName);
        let apiKey = modelObj.apiKey;
        if(apiKey === "<OPENAI>") {
          apiKey = (await db.misc.get("openAiApiKey"))?.value;
        }

        let modelType = modelObj.type;
        if(!modelType) throw new Error("modelType not found for model: "+modelName);
        let modelNoTemperatureSupport = modelObj.noTemperatureSupport;

        let result;
        let apiTokenUsage;

        let headers = {"content-type": "application/json"};
        if(apiKey) headers.authorization = `Bearer ${apiKey}`;
        if(apiKey && new URL(modelObj.endpointUrl).hostname.includes("azure")) headers["api-key"] = apiKey;

        let abortController = new AbortController();
        let abortSignal = abortController.signal;
        let abortCheckInterval = setInterval(() => {
          if(signals.stop) {
            abortController.abort();
            clearInterval(abortCheckInterval);
          }
        }, 100);
        setTimeout(() => {
          clearInterval(abortCheckInterval); // hacky, but just in case this code below throws an error before it reaches the clearInterval
        }, 1000*60);

        if(modelType === "chat-completion") {

          let data = {
            model:modelName,
            messages,
          };
          if (!(modelNoTemperatureSupport)) {
            data.temperature = temperature ?? 0.7;
          }
          if(stopSequences) data.stop = stopSequences;
          if(topP) data.top_p = topP;
          if(frequencyPenalty) data.frequency_penalty = frequencyPenalty;
          if(presencePenalty) data.presence_penalty = presencePenalty;

          let json = await fetch(modelObj.endpointUrl, {
            method: 'POST',
            headers,
            body: JSON.stringify(data),
            signal: abortSignal,
          }).then(r => r.json()).catch(e => {
            if(!signals.stop) {
              if(e.stack.toString().toLowerCase().includes("failed to fetch")) alert("Looks like there was a network error. This can happen now and then - you may need to refresh the page. If it's happening quite often, please report this on Github or Discord.\n\ngetChatCompletion: "+e.stack);
              else alert("getChatCompletion: "+e.stack);
            }
          });
          
          if(json?.error) {
            console.error(json.error);
            alert(`Error during getChatCompletion:\n` + (openAiErrorTypeToReadableError[json.error.type] ? openAiErrorTypeToReadableError[json.error.type] : JSON.stringify(json.error, null, 2)+"\n\nPlease screenshot this error and share on our Discord server or Github."));
          }

          apiTokenUsage = json?.usage;

          result = json?.choices?.[0].message.content;

        } else {

          let aiName = messages.find(m => m.role === "ai")?.name ?? "Assistant";
          let userName = messages.find(m => m.role === "user")?.name ?? "User";
          let systemName = messages.find(m => m.role === "system")?.name ?? defaultSystemName;
          let messagesFinal = structuredClone(messages);
          for(let m of messagesFinal) {
            if(m.role === "ai" && !m.name) m.name = aiName;
            if(m.role === "user" && !m.name) m.name = userName;
            if(m.role === "system" && !m.name) m.name = systemName;
          }

          let data = {
            model:modelName,
            prompt: messagesFinal.map(m => `[[${m.name}]]: ${m.content}`).join("\n\n") + `\n\n[[${aiName}]]: `,
            stop: [`\n\n[[`],
          };
          if (!(modelNoTemperatureSupport)) {
            data.temperature = temperature ?? 0.7;
          }
          if(stopSequences) data.stop.push(...stopSequences);
          if(topP) data.top_p = topP;
          if(frequencyPenalty) data.frequency_penalty = frequencyPenalty;
          if(presencePenalty) data.presence_penalty = presencePenalty;

          let json = await fetch(modelObj.endpointUrl, {
            method: "POST",
            headers,
            body: JSON.stringify(data),
            signal: abortSignal,
          }).then(r => r.json()).catch(e => {
            if(!signals.stop) {
              if(e.stack.toString().toLowerCase().includes("failed to fetch")) alert("Looks like there was a network error. This can happen now and then - you may need to refresh the page. If it's happening quite often, please report this on Github or Discord.\n\ngetChatCompletion: "+e.stack);
              else alert("getChatCompletion > modelType:general > fetch: \n\n"+e.stack);
            }
          });
          
          if(json?.error) {
            console.error(json.error);
            alert(`Error during getChatCompletion:\n` + (openAiErrorTypeToReadableError[json.error.type] ? openAiErrorTypeToReadableError[json.error.type] : JSON.stringify(json.error, null, 2)+"\n\nPlease screenshot this error and share on our Discord server or Github."));
          }

          apiTokenUsage = json?.usage;

          result = json?.choices?.[0].text.trim();
        }

        if(apiTokenUsage) {
          let usageData = {prompt:apiTokenUsage.prompt_tokens, cachedprompt:((apiTokenUsage.prompt_token_details?.cached_tokens) || 0), completion:apiTokenUsage.completion_tokens, total:apiTokenUsage.total_tokens};
          await trackTokenUsage({threadId, modelName, usageData, purpose:"chat completion"});
        }

        opts.attemptsSoFar++;

        if(!result) {
          if(opts.attemptsSoFar >= opts.maxAttempts) {
            return null;
          } else {
            return await getChatCompletion(opts);
          }
        }

        clearInterval(abortCheckInterval);

        return result;
      }

      // for debugging:
      window.embedTexts = embedTexts;
      window.cosineDistance = cosineDistance;
      window.getChatCompletion = getChatCompletion;


      // async function getCompletion({prompt, modelName, temperature, stopSequences, topP, frequencyPenalty, presencePenalty}) {

      //   // NOTE: This function is currently unused.
      //   // TODO: before using this function, you need to fix/add this stuff like in getChatCompletion:
      //   // - openAiErrorTypeToReadableError
      //   // - trackTokenUsage
      //   // - modelNameToModelType
      //   // - modelNameToMaxTokenLimit
      //   // ********You basically need to go through getChatCompletion line-by-line and copy over the relevant stuff.********

      //   // let tokenLimit = modelNameToMaxTokenLimit[modelName];
      //   // tokenLimit -= tokenLimit*0.15; // buffer due to token count being an estimate
      //   // let numTokensInContext = await countTokensInMessages(messages);

      //   let modelObj = getModel(modelName);
      //   let apiKey = modelObj.apiKey;
      //   if(apiKey === "<OPENAI>") {
      //     apiKey = (await db.misc.get("openAiApiKey"))?.value;
      //   }

      //   let modelType = modelObj.type;
      //   if(!modelType) throw new Error(`getCompletion: modelType not found for modelName: ${modelName}`);
      //   let modelNoTemperatureSupport = modelObj.noTemperatureSupport;

      //   let result;

      //   if(modelType === "completion") {

      //     let data = {
      //       model:modelName,
      //       prompt,
      //     };
             // if (!(modelNoTemperatureSupport)) data.temperature = temperature ?? 0.7;
      //     if(stopSequences) data.stop = stopSequences;
      //     if(topP) data.top_p = topP;
      //     if(frequencyPenalty) data.frequency_penalty = frequencyPenalty;
      //     if(presencePenalty) data.presence_penalty = presencePenalty;

      //     let json = await fetch(modelObj.endpointUrl, {
      //       method: "POST",
      //       headers: apiKey ? { "Authorization": `Bearer ${apiKey}`, "Content-Type": "application/json" } : undefined,
      //       body: JSON.stringify(data),
      //     }).then(r => r.json()).catch(e => alert("getCompletion: "+e.stack));
          
      //     if(json?.error) {
      //       console.error(json.error);
      //       alert(`Error during getCompletion:\n` + (openAiErrorTypeToReadableError[json.error.type] ? openAiErrorTypeToReadableError[json.error.type] : JSON.stringify(json.error, null, 2)+"\n\nPlease screenshot this error and share on our Discord server or Github."));
      //     }

      //     result = json?.choices[0].text.trim();

      //   } else {

      //     let leadInTextLength = 20;

      //     let data = {
      //       model:modelName,
      //       messages: [
      //         {
      //           role: "system",
      //           content: "You are a text completion assistant. You respond with the most likely completion of the prompt that the user provides."
      //         },
      //         {
      //           role: "user",
      //           content: `${prompt}\n\n---\n\nPlease continue the above text. Your reply must start with "${prompt.slice(-leadInTextLength)}", and should ONLY include the completion of the prompt - nothing else. Reply with a plausible completion and start your message with: "${prompt.slice(-leadInTextLength)}"`,
      //         },
      //       ],
      //     }
      //     if (!(modelNoTemperatureSupport)) data.temperature = temperature ?? 0.7;
      //     if(stopSequences) data.stop = stopSequences;
      //     if(topP) data.top_p = topP;
      //     if(frequencyPenalty) data.frequency_penalty = frequencyPenalty;
      //     if(presencePenalty) data.presence_penalty = presencePenalty;

      //     let json = await fetch(modelObj.endpointUrl, {
      //       method: 'POST',
      //       headers: apiKey ? { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' } : undefined,
      //       body: JSON.stringify(data),
      //     }).then(r => r.json()).catch(e => alert("getCompletion: "+e.stack));
          
      //     if(json?.error) {
      //       console.error(json.error);
      //       alert(`Error during getCompletion:\n` + (openAiErrorTypeToReadableError[json.error.type] ? openAiErrorTypeToReadableError[json.error.type] : JSON.stringify(json.error, null, 2)+"\n\nPlease screenshot this error and share on our Discord server or Github."));
      //     }

      //     result = json.choices[0].message.content;
      //     result = result.slice(leadInTextLength); // remove the "lead in" text
      //   }
      //   return result;
      // }

      let hljs = null;
      let initiatedHighlightJsLoad = false;
      async function highlightCodeBlocks(el) {
        if(el.querySelectorAll("pre").length === 0) return;
        if(!initiatedHighlightJsLoad) {
          initiatedHighlightJsLoad = true;
          // importStylesheet("https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/default.min.css");
          importStylesheet("https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css");
          hljs = await import("https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/es/highlight.min.js").then(m => m.default);
        }
        while(!hljs) {
          await new Promise(r => setTimeout(r, 100));
        }
        // i was originally checking el.isConnected as an optimisation, but it sometimes returns false (not exactly sure why) so I'm not checking it anymore
        el.querySelectorAll("pre[data-markdown-codeblock]").forEach(pre => {
          let language = pre.dataset.markdownCodeblock;
          if(language && hljs.getLanguage(language)) {
            hljs.highlightElement(pre, { language });
          } else {
            hljs.highlightElement(pre); // auto-detect language
          }
        });
      }

      function handleStreamingReplyChunk(chunk, messageEl) {
        let messageTextEl = messageEl.querySelector(".messageText");
        if(chunk.isFirst) messageEl.dataset.streamedMessageText = "";
        messageEl.dataset.streamedMessageText += chunk.text;
        let streamedMessageText = messageEl.dataset.streamedMessageText;

        let shouldScrollDown = messageFeedIsNearBottom();

        // if there's an unclosed codeblock, close it during streaming:
        if([...streamedMessageText.matchAll(/\n```/g)].length % 2 === 1) {
          streamedMessageText += "\n```";
        }

        messageTextEl.innerHTML = DOMPurify.sanitize(marked.parse(streamedMessageText), domPurifyOptions);
        // messageTextEl.querySelectorAll("pre > code").forEach(el => el.outerHTML = el.innerHTML); // not sure why `marked` is adding <pre><code>...</code></pre> around code blocks, but this fixes it
        
        highlightCodeBlocks(messageTextEl);

        if(shouldScrollDown) $.messageFeed.scrollTop = $.messageFeed.scrollHeight;
      }


      async function autoNameThreadIfNeeded(threadId) {
        let thread = await db.threads.get(threadId);
        let userCharacter = await getUserCharacterObj(threadId);
        let aiCharacter = await db.characters.get(thread.characterId);
        let messages = await db.messages.where("threadId").equals(threadId).toArray();
        messages.sort((a,b) => a.order - b.order);
        messages = messages.slice(0, 10);

        if(thread.name === defaultThreadName && messages.length > 8) {

          let modelName;
          if(await threadIsUsingOpenAiModel(thread)) {
            modelName = openAISummarizationModel;
          } else {
            modelName = thread.modelName;
          }

          let preparedMessages = await prepareMessagesForBot({messages});

          for(let m of preparedMessages) {
            m.content = m.content.length > 1000 ? m.content.slice(0, 1000)+"..... (message has been truncated)" : m.content;
          }

          while(await countTokensInMessages(preparedMessages, modelName) > 2000 && preparedMessages.length > 1) {
            preparedMessages.pop();
          }

          let chatCompletionMessages = [
            {role: "system", content: "You are an expert chat thread naming assistant. You help the user come up with a very short name that succinctly summarizes a text chat."},
            {role: "user", content: `Here are some logs from a text chat:\n\n---\n\n${preparedMessages.map(m => `[[${m.name}]]: ${m.content}`).join("\n\n")}\n\n---\n\nPlease come up with a very short name for this thread (just a few words) that succinctly summarizes the chat. You MUST reply with this exact template:\n\nSUMMARY: <a couple of sentences describing the chat thread>\nSHORT NAME: <proposed name of the thread - only a few words>`},
          ];
          let response = await getChatCompletion({messages:chatCompletionMessages, modelName, temperature:0.7, threadId});
          let newName = response.match(/\nSHORT NAME: (.*)/)?.[1]?.slice(0, 50);
          if(newName?.trim()) {
            await db.threads.update(threadId, { name: newName });
            await renderThreadList();
          }
        }
      }


      let lastBotReplyTime = 0;
      let botIsCurrentlyReplying = false;
      async function doBotReplyIfNeeded({forceReply=false, replyInstruction=null, signals=null, result={}, characterOverride=null, expectsReply=undefined, allowMultipleReplies=false}={}) {
        while(Date.now()-lastBotReplyTime < 1000) {
          await delay(200); // don't reply too fast in case of infinite bot reply loop (e.g. due to custom code stuff)
        }

        lastBotReplyTime = Date.now();

        // if thread is not currently visible, don't reply
        let messageThreadIsVisible = messageFeed.offsetHeight > 0;
        if(!messageThreadIsVisible) return;

        // if page is not visible, wait for it to become visible (don't want to accidentally burn credits in the background - e.g. if character's custom code is causing a reply loop)
        while(document.visibilityState !== "visible") {
          await delay(300);
        }

        // get all messages in the thread so far, so we can send them to bot
        const threadId = activeThreadId;
        const messages = await db.messages.where("threadId").equals(threadId).toArray();
        messages.sort((a,b) => a.order - b.order);

        let messagesVisibleToAi = messages.filter(m => {
          if(m.hiddenFrom && m.hiddenFrom.includes("ai")) return false;
          return true;
        });

        const characterId = characterOverride?.id ?? activeCharacterId;
        const character = await db.characters.get(characterId);
        
        if(!forceReply) {
          let lastMessage = messagesVisibleToAi.at(-1);
          if(botIsCurrentlyReplying) return;
          if(!lastMessage) return;
          if(lastMessage.expectsReply === false) {
            return; // there is a message, and bot isn't replying, but the message explicitely says not to reply
          } else if(lastMessage.expectsReply === true) {
            // do response
          } else {
            // expectsReply was neither false, nor true, so we use the default behavior:
            if(lastMessage.characterId === characterId) {
              return; // last message was from bot, so don't reply
            } else {
              // do response
            }
          }
        }
        botIsCurrentlyReplying = true;

        // this is to prevent custom code data updates during bot replies, because otherwise it deletes the "typing indicator" and streaming response message during the renderMessageFeed() that follows
        let botIsCurrentlyReplyingPromiseResolve;
        botIsCurrentlyReplyingPromise = new Promise(r => botIsCurrentlyReplyingPromiseResolve = r);
        try {
          let messageObj = createMessageObj({threadId, message:"...", characterId, instruction:replyInstruction || null});
          
          let messageEl = await addMessageToFeed(messageObj, {character, skipReaderRendering:true});
          messageEl.querySelector(".messageText").innerHTML = createPaddedTypingIndicatorHtml();
          messageEl.dataset.canDelete = "false"; // to tell delete handler that this message "doesn't exist" yet - we handle the deletion in this function instead

          if(!signals) signals = {stop:false, wasDeleted:false};

          messageEl.querySelector(".info .deleteButton").addEventListener("click", async e => {
            e.preventDefault(); e.stopPropagation();
            signals.stop = true;
            signals.wasDeleted = true;
            botIsCurrentlyReplying = false;
            messageEl.remove();
            await updateInlineReminderMessage();
            $.sendButton.disabled = false;
          }, {passive: false});

          $.statusNotifier.innerHTML = "<button style='font-size: 0.9rem; margin-top:1.5rem;'>üõë stop response</button>";
          $.statusNotifier.querySelector("button").addEventListener("click", async (e) => {
            e.preventDefault(); e.stopPropagation();
            signals.stop = true;
            // we don't set botIsCurrentlyReplying=false here because getBotReply will return "successfully", except with a partially-streamed message
            if(!character.streamingResponse || (character.streamingResponse && streamingChunkCount === 0)) {
              messageEl.remove();
              signals.wasDeleted = true;
              botIsCurrentlyReplying = false;
            }
            await updateInlineReminderMessage();
            $.statusNotifier.innerHTML = "";
            hideEl($.statusNotifier);
            $.sendButton.disabled = false;
          }, {passive: false});
          showEl($.statusNotifier);

          let streamingChunkCount = 0;
          function onStreamingReplyChunk(c) {
            handleStreamingReplyChunk(c, messageEl);
            streamingChunkCount++;
          }

          const onProgressMessage = (e) => messageEl.querySelector(".statusMessage").innerHTML=e.message;
          const {message, memoryIdBatchesUsed, loreIdsUsed, summaryHashUsed, memoryQueriesUsed, messageIdsUsed} = await getBotReply({messages, replyingCharacter:character, threadId, replyInstruction, onProgressMessage, onStreamingReplyChunk, allowMultipleReplies, signals}).catch(e => {
            if(e.name !== "AbortError") {
              alert("There was an error during doBotReplyIfNeeded:\n\n"+e.stack);
            }
            messageEl.remove();
            return {};
          });
          messageEl.querySelector(".statusMessage").innerHTML = "";

          hideEl($.statusNotifier);
          $.statusNotifier.innerHTML = "";

          if(signals.wasDeleted || message === undefined) {
            // we don't need to set botIsCurrentlyReplying=false here because it's done in delete handler, and setting it here would disrupt other calls to this function since it's global
            return;
          }

          messageObj.memoryIdBatchesUsed = memoryIdBatchesUsed;
          messageObj.loreIdsUsed = loreIdsUsed;
          messageObj.summaryHashUsed = summaryHashUsed;
          messageObj.memoryQueriesUsed = memoryQueriesUsed;
          messageObj.messageIdsUsed = messageIdsUsed;

          messageObj.expectsReply = expectsReply;
          
          let shouldAddMessage = true;
          if (Array.isArray(message)) {
            const repliesReturned = message.length;
            if (repliesReturned < 1) {
              debugger;
              shouldAddMessage = false;
            } else {
              messageObj.message = message[0];
              result.message = message[0];
              for (let i = 1; i < repliesReturned; i++) {
                messageObj.variants.push(message[i]);
              }
            }
          } else if (typeof message !== "string" && message) { // I've added `&& message` because I think with streaming enabled, it could be an empty string even though there was an error? no harm either way.
            shouldAddMessage = false;
          } else {
            messageObj.message = message;
            result.message = message;
          }

          if(!shouldAddMessage) {
            messageEl.remove();
          } else {
            messageObj.id = await addMessageToDb(messageObj);
            messageEl.dataset.id = messageObj.id;

            let shouldScrollDown = messageFeedIsNearBottom();
            await addMessageToFeed(messageObj, {character, inPlaceOf:messageEl})
            if(shouldScrollDown) $.messageFeed.scrollTop = $.messageFeed.scrollHeight;

            if(character.fitMessagesInContextMethod === "summarizeOld") {
              // we don't await this because we want to do it in the background
              computeAndSaveThreadSummaryIfNeeded({threadId, continuePastCurrentSummary:true});
            }
            
            messageEl.dataset.canDelete = "true";
            await triggerMessageActionCustomCodeEvent({threadId, eventData:{}, eventName:"MessageAdded"});
          }

        } catch(e) {
          if(e.name !== "AbortError") { // AbortError is thrown by AbortController.abort() when user clicks "stop response" - for some reason I can't catch it
            console.error(e);
            alert(e.stack);
            botIsCurrentlyReplying = false;
          }
        }
        
        autoNameThreadIfNeeded(threadId);

        botIsCurrentlyReplying = false;
        botIsCurrentlyReplyingPromiseResolve();
        botIsCurrentlyReplyingPromise = null;

        $.sendButton.disabled = false;
      }

      let alreadyRecomputingBotReply = false;
      async function regenerateMessage(messageEl, opts={}) {
        if(alreadyRecomputingBotReply) return;
        alreadyRecomputingBotReply = true;
        try {

          if(currentBotReplySignals) {
            currentBotReplySignals.stop = true;
            currentBotReplySignals.wasDeleted = true;
            await delay(100);
          }

          messageEl.querySelector(".messageText").innerHTML = createPaddedTypingIndicatorHtml();

          let messageId = parseInt(messageEl.dataset.id);
          const messageObj = await db.messages.get(messageId);
          const threadId = messageObj.threadId;
          let thread = await db.threads.get(threadId);
          
          let messages = await db.messages.where("threadId").equals(threadId).toArray();
          messages.sort((a,b) => a.order - b.order);

          const isLastMessage = messageId === messages.at(-1).id;

          // remove this message and all following messages from the array
          let contextMessages = messages.slice(0, messages.findIndex(m => m.id === messageObj.id));

          const threadCharacter = await db.characters.get(thread.characterId);
          let replyingCharacter; // <-- can of course be the same as the thread character
          if(messageObj.characterId === -1) {
            replyingCharacter = await getUserCharacterObj(threadId);
          } else {
            replyingCharacter = await db.characters.get(messageObj.characterId);
          }
          let replyingCharacterName = replyingCharacter.name;
          let smartQuoteMethod = replyingCharacter.smartQuoteMethod;
          let deleteEmoji = replyingCharacter.deleteEmoji;

          let signals = {stop:false, wasDeleted:false};

          messageEl.querySelector(".info .deleteButton").addEventListener("click", async e => {
            e.preventDefault(); e.stopPropagation();
            signals.stop = true;
            signals.wasDeleted = true;
            messageEl.remove();
          }, {passive: false});

          $.statusNotifier.innerHTML = "<button data-stop-reponse-button='1' style='font-size: 0.9rem; margin-top:1.5rem;'>üõë stop response</button>";
          $.statusNotifier.querySelector("button").addEventListener("click", async (e) => {
            e.preventDefault(); e.stopPropagation();
            signals.stop = true;
            $.statusNotifier.innerHTML = "";
            hideEl($.statusNotifier);
          }, {passive: false});
          showEl($.statusNotifier);

          let streamingChunkCount = 0;
          function onStreamingReplyChunk(c) {
            handleStreamingReplyChunk(c, messageEl);
            streamingChunkCount++;
          }

          const onProgressMessage = (e) => messageEl.querySelector(".statusMessage").innerHTML=e.message;

          let botReplyOpts = {messages:contextMessages, threadId, signals, onProgressMessage, onStreamingReplyChunk, allowMultipleReplies:true};
          if(opts.modelNameOverride) botReplyOpts.modelNameOverride = opts.modelNameOverride;
          if(messageObj.instruction) botReplyOpts.replyInstruction = messageObj.instruction;
          if(messageObj.characterId !== threadCharacter.id) {
            botReplyOpts.replyingCharacter = replyingCharacter;
          }
          
          const {message, memoryIdBatchesUsed, summaryHashUsed, memoryQueriesUsed, messageIdsUsed} = await getBotReply(botReplyOpts);
          messageEl.querySelector(".statusMessage").innerHTML = "";

          hideEl($.statusNotifier);
          $.statusNotifier.innerHTML = "";

          if(signals.wasDeleted || message === undefined) {
            return;
          }

          if(message === undefined) {
            await addMessageToFeed(messageObj, {inPlaceOf:messageEl});
            return;
          }

          messageObj.memoryIdBatchesUsed = memoryIdBatchesUsed;
          messageObj.summaryHashUsed = summaryHashUsed;
          messageObj.memoryQueriesUsed = memoryQueriesUsed;
          messageObj.messageIdsUsed = messageIdsUsed;

          if(message) {
            if (Array.isArray(message)) {
              let numReplies = message.length;
              if (numReplies < 1) {
                throw new Error("Unexpectedly received no replies while regenerating message");
              }
              messageObj.variants[messageObj.variants.findIndex(v => v===null)] = messageObj.message;
              messageObj.variants.push(null);
              messageObj.message = sanitizeBotMessage(message[0], replyingCharacterName, smartQuoteMethod, deleteEmoji);
              for(let i = 1; i < numReplies; i++) {
                messageObj.variants.push(sanitizeBotMessage(message[i], replyingCharacterName, smartQuoteMethod, deleteEmoji));
              }
            } else {
              messageObj.variants[messageObj.variants.findIndex(v => v===null)] = messageObj.message;
              messageObj.variants.push(null);
              messageObj.message = sanitizeBotMessage(message, replyingCharacterName, smartQuoteMethod, deleteEmoji);
            }

            let shouldScrollDown = messageFeedIsNearBottom();
            let newMessageEl = await addMessageToFeed(messageObj, {inPlaceOf:messageEl});
            if(shouldScrollDown) $.messageFeed.scrollTop = $.messageFeed.scrollHeight;

            let currentVariantNumber = messageObj.variants.findIndex(v => v===null) + 1;
            newMessageEl.querySelector(".currentVariantNumber").innerHTML = `${currentVariantNumber}<span style="opacity:0.5">/${messageObj.variants.length}</span>`;
            
            if(isMobile) showEl(newMessageEl.querySelector(".messageVariantsCtn"));

            // update db with bot's reply
            await db.messages.put(messageObj);
            // update thread's lastMessageTime
            await db.threads.update(threadId, { lastMessageTime: Date.now() });

            await incrementOperationsSinceLastExport();

            // if this isn't at the top of the thread list, re-render the thread list
            let threadElements = [...$.chatThreads.querySelectorAll(".thread")];
            if(!thread.isFav) threadElements = threadElements.filter(el => el.querySelector(".favStar").dataset.isFav==="false");
            if(threadElements[0].dataset.threadId !== threadId.toString()) {
              await renderThreadList();
            }

            if(!signals.stop) { // <-- don't call custom code if they stopped the message
              await triggerMessageActionCustomCodeEvent({threadId, eventData:{messageId:messageObj.id}, eventName:"MessageEdited"});
            }
          }
        } catch(e) {
          console.error(e);
          alert("regenerateMessage failed:\n"+e.stack);
        }

        alreadyRecomputingBotReply = false;
      }

      function createPaddedTypingIndicatorHtml() {
        return `<div style="margin-top:0.25rem; margin-left:0.25rem;">${createTypingIndicatorHtml()}</div>`;
      }
      function createTypingIndicatorHtml() {
        return `<div class="ticontainer"><div class="tiblock"><div class="tidot"></div><div class="tidot"></div><div class="tidot"></div></div></div>`;
      }

      function messageFeedIsNearBottom() {
        return $.messageFeed.scrollHeight - $.messageFeed.scrollTop - $.messageFeed.offsetHeight < 100;
      }

      async function addMessageToFeed(originalMessageObj, opts={}) {
        let threadId = originalMessageObj.threadId;
        let thread = await db.threads.get(threadId);

        let messageObj;
        if(opts.skipReaderRendering) {
          messageObj = originalMessageObj;
        } else {
          [ messageObj ] = await renderMessagesForReader({messages:[originalMessageObj], reader:"user", threadId});
        }
        
        let userCharacter = await getUserCharacterObj(threadId);
        let character = opts.character;
        if(!character) {
          if(messageObj.characterId === -1) character = userCharacter;
          else if(messageObj.characterId === -2) character = await getSystemCharacterObj(threadId);
          else character = await db.characters.get(messageObj.characterId);
        }
        let el = await createMessageElement(messageObj, {character});
        
        if(opts.inPlaceOf) {
          opts.inPlaceOf.replaceWith(el);
        } else if(opts.insertAfter) {
          opts.insertAfter.after(el);
        } else if(opts.insertBefore) {
          opts.insertBefore.before(el);
        } else {
          // otherwise we append:
          let shouldScrollDown = messageFeedIsNearBottom();
          $.messageFeed.appendChild(el);
          if(shouldScrollDown) $.messageFeed.scrollTop = $.messageFeed.scrollHeight;
        }

        hideEl($.noMessagesNotice);
        attachEventHandlersToMessageEl(el, {showVariantsSelector:opts.showVariantsSelector});
        
        await updateInlineReminderMessage();
        await updateThreadScene();

        for(let undoButton of $.messageFeed.querySelectorAll(".undoMessageDeleteButton")) {
          undoButton.remove();
        }

        return el;
      }

      let mousePos = {x:0, y:0};
      window.addEventListener("mousemove", function(e) {
        mousePos = {x:e.clientX, y:e.clientY};
      }, {passive: true});

      async function switchMessageVariant(messageEl, nextOrPrevious) {
        if(nextOrPrevious === "previous") {
          let message = await db.messages.get(parseInt(messageEl.dataset.id));
          let currentIndex = message.variants.findIndex(v => v===null); // current message is represented with `null` in variant array
          message.variants[currentIndex] = message.message;
          if(currentIndex-1 < 0) currentIndex = message.variants.length;
          message.message = message.variants[currentIndex-1];
          message.variants[currentIndex-1] = null;
          await db.messages.put(message);
          let newMessageEl = await addMessageToFeed(message, {inPlaceOf:messageEl, showVariantsSelector:true});
          newMessageEl.querySelector(".currentVariantNumber").innerHTML = `${(currentIndex-1) + 1}<span style="opacity:0.5">/${message.variants.length}</span>`; // +1 because 1-indexed
          await incrementOperationsSinceLastExport();
        } else if(nextOrPrevious === "next") {
          let message = await db.messages.get(parseInt(messageEl.dataset.id));
          let currentIndex = message.variants.findIndex(v => v===null); // current message is represented with `null` in variant array
          message.variants[currentIndex] = message.message;
          if(currentIndex+1 >= message.variants.length) currentIndex = -1;
          message.message = message.variants[currentIndex+1];
          message.variants[currentIndex+1] = null;
          await db.messages.put(message);
          let newMessageEl = await addMessageToFeed(message, {inPlaceOf:messageEl, showVariantsSelector:true});
          newMessageEl.querySelector(".currentVariantNumber").innerHTML = `${(currentIndex+1) + 1}<span style="opacity:0.5">/${message.variants.length}</span>`; // +1 because 1-indexed
          await incrementOperationsSinceLastExport();
        } else {
          throw new Error("Invalid nextOrPrevious value: "+nextOrPrevious);
        }
      }

      function attachEventHandlersToMessageEl(messageEl, opts={}) {
        const recomputeButton = messageEl.querySelector(".recomputeButton");

        messageEl.querySelector(".editButton").addEventListener("click", messageEditButtonClickHandler, {passive: false});
        recomputeButton.addEventListener("click", async function() {
          await regenerateMessage(messageEl);
        }, {passive: true});

        messageEl.querySelector(".recomputeWithAltModelButton").addEventListener("click", async function() {
          let modelNameOverride = openAIAlternateModel;
          await regenerateMessage(messageEl, {modelNameOverride});
        }, {passive: true});


        messageEl.querySelector(".prevMessageVariantButton").addEventListener("click", async function() {
          await switchMessageVariant(messageEl, "previous");
        }, {passive: true});
        messageEl.querySelector(".nextMessageVariantButton").addEventListener("click", async function() {
          await switchMessageVariant(messageEl, "next");
        }, {passive: true});

        if(!isMobile) { // on mobile the variants container is always visible after user has created at least 1 variant
          let variantsCtnHideTimeout = null;
          recomputeButton.addEventListener("mouseenter", function(e) {
            clearTimeout(variantsCtnHideTimeout);
            let variantsCtn = messageEl.querySelector(".messageVariantsCtn");
            showEl(variantsCtn);
            // hotizontally position variantsCtn so it sits directly above recomputeButton (centered)
            variantsCtn.style.left =  `${recomputeButton.offsetLeft + (recomputeButton.offsetWidth/2) - (variantsCtn.offsetWidth/2)}px`;
          }, {passive: true});

          recomputeButton.addEventListener("mouseleave", async function() {
            let variantsCtn = messageEl.querySelector(".messageVariantsCtn");
            variantsCtnHideTimeout = setTimeout(() => hideEl(variantsCtn), 500);
          }, {passive: true});

          messageEl.querySelector(".messageVariantsCtn").addEventListener("mouseenter", function() {
            clearTimeout(variantsCtnHideTimeout);
          }, {passive: true});
          messageEl.querySelector(".messageVariantsCtn").addEventListener("mouseleave", function() {
            let variantsCtn = messageEl.querySelector(".messageVariantsCtn");
            variantsCtnHideTimeout = setTimeout(() => hideEl(variantsCtn), 500);
          }, {passive: true});
          if(opts.showVariantsSelector) {
            recomputeButton.dispatchEvent(new Event("mouseenter"));
            delay(100).then(() => {
              // if mouse is not on top of variantsCtn, dispatch mouseleave:
              let variantsCtn = messageEl.querySelector(".messageVariantsCtn");
              let variantsCtnRect = variantsCtn.getBoundingClientRect();
              if(!(mousePos.x >= variantsCtnRect.left && mousePos.x <= variantsCtnRect.right && mousePos.y >= variantsCtnRect.top && mousePos.y <= variantsCtnRect.bottom)) {
                // debugger;
                recomputeButton.dispatchEvent(new Event("mouseleave"));
              }
            });
          }
        }

        messageEl.querySelector(".deleteButton").addEventListener("click", messageDeleteButtonClickHandler, {passive: false});
        messageEl.querySelector(".showHiddenMessageButton").addEventListener("click", showHiddenMessageClickHandler, {passive: true});
        // messageEl.querySelector(".messageText").querySelectorAll("pre > code").forEach(el => el.outerHTML = el.innerHTML); // not sure why `marked` is adding <pre><code>...</code></pre> around code blocks, but this fixes it
        messageEl.querySelector(".statusMessage").addEventListener("click", () => summariesWindow.show());

        messageEl.querySelector(".brainButton")?.addEventListener("click", async function() {
          let message = await db.messages.get(parseInt(messageEl.dataset.id));
          
          let summary;
          let summaryUsed;
          if(message.summaryHashUsed) {
            summary = await db.summaries.get(message.summaryHashUsed);
            summaryUsed = summary.summary;
          }

          let memoriesUsed = await db.memories.where("id").anyOf(message.memoryIdBatchesUsed.flat()).toArray();
          let memoryBatchesUsed = message.memoryIdBatchesUsed;
          // replace ids in memoryBatchesUsed with memories from memoriesUsed:
          for(let batch of memoryBatchesUsed) {
            for(let i = 0; i < batch.length; i++) {
              batch[i] = memoriesUsed.find(m => m.id === batch[i]) ?? {text:"(memory not found - likely because it has since been edited or deleted)"};
            }
          }
          let loreEntriesUsed = await db.lore.where("id").anyOf(message.loreIdsUsed).toArray();

          let content = [];

          if(message.instruction) {
            content.push(`<b>Instruction Used:</b> ${message.instruction}`);
          }

          if(message.summaryHashUsed === undefined) {
            content.push(`<b>Summary Used:</b><div style="opacity:0.5;font-size: 80%; margin-top:0.5rem;">(This message was created before message-summary-usage tracking was implemented)</div>`);
          } else if(message.summaryHashUsed === null) {
            content.push(`<b>Summary Used:</b><div style="opacity:0.5;font-size: 80%; margin-top:0.5rem;">(No summary was used to generate this message. This is likely because the conversation was not yet long enough to warrant summarization)</div>`);
          } else {

            let summarySummarized = summary.prevSummaryHash ? await db.summaries.get(summary.prevSummaryHash) : null;
            let messagesSummarized = await db.messages.where("id").anyOf(summary.messageIds).toArray();
            messagesSummarized.sort((a,b) => a.order - b.order);

            messagesSummarized = await prepareMessagesForBot({messages:messagesSummarized});

            let messagesSummarizedHtml = `<details style="opacity:0.5; padding:1rem;"><summary style="cursor:pointer;">Click here to show what was summarized</summary>${summarySummarized ? "\n"+summarySummarized.summary : ""}\n\n${messagesSummarized.map(m => `<b>[${m.name}]:</b> ${sanitizeHtml(m.content)}`).join("\n\n")}</details>`;

            content.push(`<b>Summary Used:</b>\n${sanitizeHtml(summaryUsed)}<div style="opacity:0.5;font-size: 80%; margin-top:0.5rem;">(you can edit the latest summary by typing <b>/sum</b> in the chat)</div>${messagesSummarizedHtml}`);
          }

          if(memoryBatchesUsed.length > 0) {
            content.push(`<b>Memories Used:</b>\n${sanitizeHtml(memoryBatchesUsed.map(batch => batch.map(m => m.text).join(" ‚Æï ")).join("\n\n"))}<div style="opacity:0.5;font-size: 80%; margin-top:0.5rem;">(you can add and edit memories by typing <b>/mem</b> in the chat)</div>`);
          } else {
            content.push(`<b>Memories Used:</b>\n<div style="opacity:0.5;font-size: 80%; margin-top:0.5rem;">(No memories were used to generate this message. This is either because the conversation was not yet long enough to warrant memory storage/retrieval, or you don't have memories enabled in the character settings, or lore entries took precedence)</div>`);
          }
          
          if(loreEntriesUsed.length > 0) {
            content.push(`<b>Lore Entries Used:</b>\n${sanitizeHtml(loreEntriesUsed.map(m => m.text).join("\n\n"))}<div style="opacity:0.5;font-size: 80%; margin-top:0.5rem;">(you can add and edit lore by typing <b>/lore</b> in the chat)</div>`);
          } else {
            content.push(`<b>Lore Entries Used:</b>\n<div style="opacity:0.5;font-size: 80%; margin-top:0.5rem;">(No lore entries were used to generate this message. This is either because the conversation was not yet long enough to warrant memory storage/retrieval, or you don't have memories enabled in the character settings, or memory entries took precedence. You can add and edit lore by typing <b>/lore</b> in the chat.)</div>`);
          }

          if(message.memoryQueriesUsed.length > 0) {
            content.push(`<b>Memory/Lore Queries Used:</b>\n${sanitizeHtml(message.memoryQueriesUsed.join("\n"))}`);
          }

          if(message.messageIdsUsed.length > 0) {
            let messages = await db.messages.where("id").anyOf(message.messageIdsUsed.filter(id => id !== -1)).toArray();
            messages.sort((a,b) => a.order - b.order);

            messages = await prepareMessagesForBot({messages});
            
            // we want `null` "holes" in the array for the messages that no longer exist:
            let messagesMap = {};
            messages.forEach((message) => { messagesMap[message.id] = message; });
            let messagesWithHoles = message.messageIdsUsed.map(id => id === -1 ? null : messagesMap[id]);

            content.push(`<b>Messages Used:</b>\n<details style="opacity:0.5; padding:1rem;"><summary style="cursor:pointer;">Click here to show messages</summary>\n${messagesWithHoles.map(m => m ? `<b>[${m.name}]:</b> ${sanitizeHtml(m.content)}` : "<b>[???]</b>: <span style='opacity:0.5;'>(Message no longer exists. May have been deleted by user, or by custom code.)</span>").join("\n\n")}</details>`);
          }
          
          prompt2({
            display:{html:`<div style="white-space:pre-wrap;">Here's some data that the character used to generate this message:\n\n${content.join("\n\n")}</div>`, type:"none"},
          }, { submitButtonText: "close", cancelButtonText: null });
        }, {passive: true});
        messageEl.querySelector(".debugButton")?.addEventListener("click", async function() {
          let message = await db.messages.get(parseInt(messageEl.dataset.id));
          
          let content = [];

          content.push(`Message order: ${message.order.toString()}`);

          prompt2({
            display:{html:`<div style="white-space:pre-wrap;">Here's debugging information about this message:\n\n${content.join("\n\n")}</div>`, type:"none"},
          }, { submitButtonText: "close", cancelButtonText: null });
        }, {passive: true});
        messageEl.querySelector(".summarizeToHereButton")?.addEventListener("click", async function() {
          alert(`Summarize button clicked for message ${messageEl.dataset.id}`);
        }, {passive: true});
      }

      // right/left arrow to switch message variants:
      window.addEventListener("keydown", async function(e) {
        // if active element is a textarea/input, then return
        if(document.activeElement.tagName === "TEXTAREA" || document.activeElement.tagName === "INPUT") {
          return;
        }
        if($.messageFeed.offsetWidth === 0 || activeThreadId === null) {
          return;
        }

        // if they press right arrow, and the last message is on the final variant, then recompute the final message:
        if(e.key === "ArrowRight" || e.key === "ArrowLeft") {
          let threadId = parseInt($.messageFeed.dataset.threadId);
          let thread = await db.threads.get(threadId);
          let messages = await db.messages.where("threadId").equals(threadId).toArray();
          messages.sort((a,b) => a.order - b.order);
          let lastMessage = messages[messages.length-1];
          let lastMessageEl = [...$.messageFeed.querySelectorAll(".message")].pop();
          if(e.key === "ArrowRight") {
            // the `lastMessage.variants` array has `null` in the position of the 'current' message, so if null is at the end of the array, and they pressed right arrow, then we recompute:
            if(lastMessage.variants[lastMessage.variants.length-1] === null) {
              await regenerateMessage(lastMessageEl);
            } else {
              // otherwise we just move to the next variant:
              await switchMessageVariant(lastMessageEl, "next");
            }
          }
          if(e.key === "ArrowLeft") {
            // if the first variant is null, then we recompute:
            if(lastMessage.variants[0] === null) {
              await regenerateMessage(lastMessageEl);
            } else {
              // otherwise we just move to the previous variant:
              await switchMessageVariant(lastMessageEl, "previous");
            }
          }
        }
      }, {passive: false});

      async function showHiddenMessageClickHandler() {
        let messageEl = this.closest(".message");
        let messageObj = db.messages.get(parseInt(messageEl.dataset.id));
        messageEl.classList.remove("hiddenFromUser");
      }

      let dataUrlToBlobUrlCache = new Map();
      async function dataUrlToCachedBlobUrl(dataUrl) {
        if(dataUrlToBlobUrlCache.has(dataUrl)) return dataUrlToBlobUrlCache.get(dataUrl);
        let blob = await fetch(dataUrl).then(r => r.blob()); 
        let blobUrl = URL.createObjectURL(blob);
        dataUrlToBlobUrlCache.set(dataUrl, blobUrl);
        return blobUrl;
      }

      async function createMessageElement(messageObj, opts={}) {

        let messageObjHash = await sha256Text(JSON.stringify(messageObj));

        if(messageObj.character) debugger;

        let thread = await db.threads.get(messageObj.threadId);

        let character = opts.character;

        let showDebugInfo = (await db.misc.get("showDebugInfo"))?.value;
        let showDebugVerbose = (showDebugInfo == "verbose");
        let showDebugBasics = showDebugVerbose || (showDebugInfo == "brief");
        let showSummarize = true;

        if(!character && messageObj.characterId === -1) character = await getUserCharacterObj(messageObj.threadId)
        if(!character && messageObj.characterId === -2) character = await getSystemCharacterObj(messageObj.threadId);
        if(!character && messageObj.characterId >= 0) character = await db.characters.get(messageObj.characterId);

        let tmp = document.createElement("div");
        let currentVariantNumber = messageObj.variants.findIndex(v => v === null) + 1;

        let variantCtnCss;
        if(isMobile) {
          // on mobile we show when there are multiple variants
          if(messageObj.variants.length >= 2) {
            variantCtnCss = "margin-left:1rem;";
          } else {
            variantCtnCss = "margin-left:1rem; display:none;";
          }
        } else {
          // on desktop we show in hover:
          variantCtnCss = "display:none; position:absolute; bottom:1.4rem; padding: 0.125rem;";
        }

        let avatarUrl = character.avatar.url;
        if(thread.character.avatar.url) avatarUrl = thread.character.avatar.url;
        if(messageObj.avatar?.url) avatarUrl = messageObj.avatar.url;
        if(avatarUrl && avatarUrl.startsWith("data:")) {
          avatarUrl = await dataUrlToCachedBlobUrl(avatarUrl);
        }

        let avatarShape = character.avatar.shape;
        if(thread.character.avatar.shape) avatarShape = thread.character.avatar.shape;
        if(messageObj.avatar?.shape) avatarShape = messageObj.avatar.shape;

        let avatarSize = character.avatar.size;
        if(thread.character.avatar.size) avatarSize = thread.character.avatar.size;
        if(messageObj.avatar?.size !== undefined) avatarSize = messageObj.avatar.size;

        let wrapperStyle = messageObj.wrapperStyle || thread.messageWrapperStyle || "";

        // fall back to ai character's settings where appropriate:
        if(character.id < 0) {
          let thread = await db.threads.get(messageObj.threadId);
          let aiCharacter = await db.characters.get(thread.characterId);

          if(avatarSize === null || avatarSize === undefined) {
            avatarSize = aiCharacter.avatar.size;
          }
          if(avatarShape === null || avatarShape === undefined) {
            avatarShape = aiCharacter.avatar.shape;
          }
        }

        let avatarWidth = 50 * (avatarSize ?? 1);
        let avatarHeight = 50 * (avatarSize ?? 1);
        let avatarBorderRadius = "var(--border-radius)";
        if(avatarShape === "circle") {
          avatarBorderRadius = "50%";
        }
        if(avatarShape === "portrait") {
          avatarHeight *= 1.5;
        }

        let characterName = messageObjToCharacterName(messageObj, {thread, character});

        let showRecomputeWithAltButtonModel = false;
        if(thread.modelName === "gpt-3.5-turbo" || thread.modelName === "gpt-4") {
          if(textContainsAsALanguageModelText(messageObj.message + messageObj.variants.join(" "))) {
            showRecomputeWithAltButtonModel = true;
          }
        }

        tmp.innerHTML = `
          <div class="message ${messageObj.hiddenFrom?.includes("user") ? "hiddenFromUser" : ""}" data-id="${sanitizeHtml(messageObj.id)}" data-order="${sanitizeHtml(messageObj.order)}" data-character-id="${sanitizeHtml(messageObj.characterId)}" data-can-delete="true" data-hash="${messageObjHash}" style="${sanitizeHtml(wrapperStyle)}; position:relative;">
            <div style="text-align:center;"><button class="showHiddenMessageButton" style="cursor:pointer; font-size:0.65rem;">Show hidden message</button></div>
            <div class="bottomButtons">
              <div title="More message info" class="brainButton emojiButton">üß†</div>
              ${showDebugBasics ? `<div title="Debugging info" class="debugButton emojiButton">ü™≤</div>` : "" }
              ${showSummarize ? `<div title="Summarize thread to this point" class="summarizeToHereButton emojiButton">‚àë</div>` : ""}
            </div>
            <div class="messageWrap">
              <div class="avatar" style="${avatarUrl ? `background-image:url(${sanitizeHtml(avatarUrl)})` : ""};width:${sanitizeHtml(avatarWidth)}px; min-width:${sanitizeHtml(avatarWidth)}px; height:${sanitizeHtml(avatarHeight)}px; border-radius:${sanitizeHtml(avatarBorderRadius)};"></div>
              <div style="padding-left:0.5rem; min-width: 0; width:100%;">
                <div class="info" style="flex-grow:1; display:flex; font-size:80%; align-items:center; user-select:none;">
                  <div class="characterName" style="font-weight:bold;">${sanitizeHtml(characterName)}</div>
                  <!-- <div class="time" style="font-size:0.8rem; opacity:0.5; margin-left:0.5rem; display: flex; align-items: center;">${getDateTimeString(messageObj.creationTime)}</div> -->
                  <div title="Edit message" class="editButton emojiButton" style="font-size:0.8rem; margin-left:1rem; display: flex; align-items: center; cursor:pointer;">‚úèÔ∏è</div>
                  <div title="Delete message" class="deleteButton emojiButton" style="font-size:0.8rem; margin-left:1rem; display: flex; align-items: center; cursor:pointer;">üóëÔ∏è</div>
                  <div style="position:relative;display:flex; align-items:center;">
                    <div title="New message variant" class="recomputeButton emojiButton" style="font-size:0.8rem; margin-left:1rem; display:flex; align-items: center; cursor:pointer;">üîÅ</div>
                    <div title="New message variant with alternate model" class="recomputeWithAltModelButton emojiButton" style="font-size:0.8rem; margin-left:1rem; display:${showRecomputeWithAltButtonModel ? "flex" : "none"}; align-items: center; cursor:pointer;" title="Regenerate this message with the davinci model (10x more expensive, but less filtered)">üôÑ</div>
                    <div title="Message variants" class="messageVariantsCtn" style="user-select:none; background: var(--button-bg); border: 1px solid var(--border-color); border-radius: var(--border-radius); min-width:max-content; ${sanitizeHtml(variantCtnCss)}">
                      <span class="prevMessageVariantButton emojiButton">‚óÑ</span>
                      <span class="currentVariantNumber">${sanitizeHtml(currentVariantNumber)}<span style="opacity:0.5">/${sanitizeHtml(messageObj.variants.length)}</span></span>
                      <span class="nextMessageVariantButton emojiButton">‚ñ∫</span>
                    </div>
                  </div>
                  ${messageObj.hiddenFrom?.includes("ai") ? `<div class="hiddenFromAiIcon" onclick="alert('This icon indicates that this message is hidden from the AI.')" title="The AI cannot see this message." style="font-size:0.8rem; margin-left:1rem; display:flex; align-items: center; cursor:pointer;">üôà</div>` : ""}
                  <div class="statusMessage" style="margin-left:1rem;display: flex;align-items: center;cursor:pointer;font-size: 0.7rem;opacity: 0.5;"></div>
                ${showDebugVerbose ? ("<span title='Debugging info'>" + messageObj.order + "</span>") : ""}
                </div>
                <div class="messageText" style="overflow-wrap:break-word;"></div>
              </div>
            </div>
          </div>
        `;
        let el = tmp.firstElementChild;
        el.querySelector(".messageText").innerHTML = DOMPurify.sanitize(marked.parse(messageObj.message), domPurifyOptions);
        // el.querySelector(".messageText").querySelectorAll("pre > code").forEach(el => el.outerHTML = el.innerHTML); // not sure why `marked` is adding <pre><code>...</code></pre> around code blocks, but this fixes it
        
        highlightCodeBlocks(el.querySelector(".messageText"));

        // add 'copy' button to code blocks
        el.querySelectorAll('.messageText pre').forEach(pre => {
          const wrapper = document.createElement('div');
          const button = document.createElement('button');
          button.innerText = 'copy';
          button.style.cssText = 'font-size:80%; position:absolute; top:0.25rem; right:0.25rem;';
          wrapper.style.position = 'relative';
          pre.parentNode.insertBefore(wrapper, pre);
          wrapper.appendChild(pre);
          wrapper.appendChild(button);

          button.addEventListener('click', async () => {
            let text = pre.innerText.trim(); // trim removes trailing newlines from bash commands which is a very good idea
            await navigator.clipboard.writeText(text);
            button.innerText = 'copied!';
            setTimeout(() => {
              button.innerText = 'copy';
            }, 2000);
          }, {passive: true});
        });
        return el;
      }


      function textContainsAsALanguageModelText(text) {
        let t = text.toLowerCase();
        return t.includes("as a language model")
          || t.includes("trained by openai")
          || t.includes("as a large language model")
          || t.includes("language model trained")
          || /\bas an ai\b/.test(t)
          || /\bi'm sorry.+(appropriate|acceptable)\b/.test(t)
          || /\bi apologi[zs]e.+(appropriate|acceptable)\b/.test(t)
          || /\b(i (can't|cannot) (assist|help)( you|) with that)\b/.test(t)
          || /\b(i'm |)sorry, i (can't|cannot)\b/.test(t.slice(0, 50))
          || /\bunfortunately,? i (can't|cannot)\b/.test(t.slice(0, 50))
          || /\bsorry.+(cannot|can't|won't be able to).+(generate|write|create|do that)\b/.test(t.slice(0, 50))
      }

      // This cannot be called from passive event listeners
      async function messageEditButtonClickHandler(e) {
        e.preventDefault();
        e.stopPropagation();
        let messageEl = this.closest(".message");
        const messageId = parseInt(messageEl.dataset.id);
        const originalMessage = await db.messages.get(messageId);
        let threadId = originalMessage.threadId;
        const thread = await db.threads.get(threadId);
        let threadCharacter = await db.characters.get(thread.characterId);
        let smartQuoteMethod = threadCharacter.smartQuoteMethod;
        let deleteEmoji = threadCharacter.deleteEmoji;

        let insertNewMessageEl = document.createElement("div");
        insertNewMessageEl.style.cssText = "margin-top: 1rem;";
        insertNewMessageEl.innerHTML = `<span style="font-size:85%;">insert new message:</span> <button class="insertAbove">above</button> <button class="insertBelow">below</button>`;
        async function insertMessageHandler(aboveOrBelow) {
          const result = await prompt2({
            content: {label: "message:", type: "text", height:"fit-content", focus:true},
            author: {label: "author:", type: "select", options:[{value:"user"}, {value:"ai"}, {value:"system"}], defaultValue: "user"},
            instruction: {label: "instruction:", show:(data) => data.author==="ai", type: "text", height: "fit-content"},
            hiddenFrom: {hidden:true, label: "hidden from:", type: "select", options:[{value:"user"}, {value:"ai"}, {content:"both", value:"user,ai"}, {content:"neither", value:""}], defaultValue: originalMessage.hiddenFrom.join(",")},
          });
          if(!result) return;
          // Using the user-reply sanitization handler for everything here is close enough
          result.content = sanitizeUserMessage(result.content, smartQuoteMethod, deleteEmoji);
          let characterId = result.author === "user" ? -1 : result.author === "system" ? -2 : thread.characterId;
          let messageObj = createMessageObj({threadId, message:result.content, instruction:result.instruction, characterId, hiddenFrom:result.hiddenFrom.split(",")});
          
          let messages = await db.messages.where({threadId}).toArray();
          messages.sort((a,b) => a.order - b.order);
          let messageIndex = messages.findIndex(m => m.id === messageId);
          let prevOrder, nextOrder;
          if(aboveOrBelow === "above") {
            prevOrder = messageIndex > 0 ? messages[messageIndex-1].order : messages[messageIndex].order-2;
            nextOrder = originalMessage.order;
          } else {
            prevOrder = originalMessage.order;
            nextOrder = messageIndex < messages.length-1 ? messages[messageIndex+1].order : messages[messageIndex].order+2;
          }
          if ((nextOrder - prevOrder) < 0.0000001) {
            alert("There's a bit of a problem. You've inserted enough messages in one place that I can't safely insert a new one here. To fix this, please exit out of this dialog, then type the command '/respacemessageorders' into the message textbox and click Send. This will reset the thread's ordering information and let you insert lots more messages.");
            return;
          }

          messageObj.order = (prevOrder + nextOrder) / 2;
          messageObj.id = await addMessageToDb(messageObj);
          
          let opts = {};
          if(aboveOrBelow === "above") opts.insertBefore = messageEl;
          else opts.insertAfter = messageEl;

          let newMessageEl = await addMessageToFeed(messageObj, opts);

          await incrementOperationsSinceLastExport();

          await triggerMessageActionCustomCodeEvent({threadId, eventData:{messageId:messageObj.id}, eventName:"MessageInserted"});

          if ((messageObj.characterId == thread.characterId) && (messageObj.message === "")) {
            await regenerateMessage(newMessageEl);
          }
        }
        insertNewMessageEl.querySelector(".insertAbove").addEventListener("click", insertMessageHandler.bind(null, "above"), {passive: true});
        insertNewMessageEl.querySelector(".insertBelow").addEventListener("click", insertMessageHandler.bind(null, "below"), {passive: true});
        
        const instructionHidden = (!!!originalMessage.instruction) || (originalMessage.author == "ai");
        let promptOpts = {
          // CAUTION: All non-none types must have a defaultValue, since we use it for change detection, below
          message: {label: "message:", type: "text", height:"fit-content", defaultValue: originalMessage.message, focus:true},
          instruction: {hidden:instructionHidden, label: "instruction:", type: "text", height: "fit-content", minHeight:"2rem", defaultValue: originalMessage.instruction || ""},
          hiddenFrom: {hidden:true, label: "hidden from:", type: "select", options:[{value:"user"}, {value:"ai"}, {content:"both", value:"user,ai"}, {content:"neither", value:""}], defaultValue: originalMessage.hiddenFrom.join(",")},
          insertMessage: {hidden:true, html: insertNewMessageEl, type: "none"},
        };
        const result = await prompt2(promptOpts, {submitButtonText:"save"});
        if(!result) return;

        let noChangesMade = true;
        for(let key of Object.keys(result)) {
          if(promptOpts[key].type === "none") continue;

          if(result[key] !== promptOpts[key].defaultValue) {
            noChangesMade = false;
            break;
          }
        }
        if(noChangesMade) return;

        result.hiddenFrom = result.hiddenFrom.split(",").filter(x => x);
        if(!result.instruction || !result.instruction.trim()) result.instruction = null;

        result.message = sanitizeUserMessage(result.message, smartQuoteMethod, deleteEmoji);
        await db.messages.update(messageId, result);

        let newMessage = await db.messages.get(messageId);

        let shouldScrollDown = messageFeedIsNearBottom();
        await addMessageToFeed(newMessage, {inPlaceOf:messageEl});
        if(shouldScrollDown) $.messageFeed.scrollTop = $.messageFeed.scrollHeight;

        await incrementOperationsSinceLastExport();

        await triggerMessageActionCustomCodeEvent({threadId, eventData:{messageId}, eventName:"MessageEdited"});
      }

      // This cannot be called from passive event listeners
      async function messageDeleteButtonClickHandler(e) {
        let messageEl = this.closest(".message");
        if(messageEl.dataset.canDelete === "false") return; // it doesn't exist (just a "typing indicator" place holder) - deletion during that time is handled within the doBotReplyIfNeeded function
        let threadId = activeThreadId;
        e.preventDefault();
        e.stopPropagation();
        const messageId = parseInt(messageEl.dataset.id);

        let prevMessageEl = messageEl.previousElementSibling;
        while(prevMessageEl && !prevMessageEl.classList.contains("message")) prevMessageEl = prevMessageEl.previousElementSibling;
        
        let messageObj = await db.messages.get(messageId);

        // remove any exsiting undo buttons
        for(let undoButton of $.messageFeed.querySelectorAll(".undoMessageDeleteButton")) {
          undoButton.remove();
        }

        let undoBtn = document.createElement("div");
        undoBtn.innerHTML = `<div class="undoMessageDeleteButton" style="text-align:center;"><button>undo deletion</button></div>`;
        undoBtn.querySelector("button").addEventListener("click", async function() {
          // add message back to db.
          // NOTE: the message will no longer be referenced in messageIdsUsed of other messages (due to safelyDeleteMessagesByIds tidying up those references), but that's not a big deal. Can improve this later if needed.
          await db.messages.add(messageObj);

          let opts = {};
          if(prevMessageEl) opts.insertAfter = prevMessageEl;
          await addMessageToFeed(messageObj, opts);
          await incrementOperationsSinceLastExport();
          
          undoBtn.remove();

          await updateInlineReminderMessage();
          await updateThreadScene();
        }, {passive: true});

        await safelyDeleteMessagesByIds([messageId]);
        messageEl.replaceWith(undoBtn);
        if(!$.messageFeed.querySelector(".message")) {
          showEl($.noMessagesNotice);
        }
        await incrementOperationsSinceLastExport();
        await updateInlineReminderMessage();
        await updateThreadScene();
        await triggerMessageActionCustomCodeEvent({threadId, eventData:{messageId}, eventName:"MessageDeleted", triggerBotReply:false});
      }

      const defaultUserName = "Anon";

      async function getUserCharacterObj(threadId) {
        // set defaults:
        let characterObj = {
          id: -1,
          name: (await db.misc.get("userName"))?.value || defaultUserName,
          // avatarUrl: (await db.misc.get("userAvatarUrl"))?.value || "",
          roleInstruction: "",
          reminderMessage: "",
          initialMessage: [],
          customCode: "",
          fitMessagesInContextMethod: "dropOld",
          smartQuoteMethod: "smartQuotes",
          deleteEmoji: false,
          avatar: {
            url: (await db.misc.get("userAvatarUrl"))?.value || "",
            // we leave `shape` and `size` as thread default
          },
          streamingResponse: false,
          maxTokensPerMessage: null,
        };
        // override with character and then thread-specific settings:
        let thread = await db.threads.get(threadId);
        applyObjectOverrides({object:characterObj, overrides:thread.userCharacter});

        return characterObj;
      }



      async function getSystemCharacterObj(threadId) {
        let characterObj = {
          id: -2,
          name: defaultSystemName,
          avatar: {
            url: null,
            shape: null, // null => default to character setting
            size: null,
          },
          maxTokensPerMessage: null,
        };
        // override with character and then thread-specific settings:
        let thread = await db.threads.get(threadId);
        applyObjectOverrides({object:characterObj, overrides:thread.systemCharacter});

        return characterObj;
      }

      {
        let debounceTimeout = null;
        $.messageInput.addEventListener("input", async function(e) {
          // debounce, and after 500ms, save current $.messageInput.value to thread.unsentMessageText
          if(debounceTimeout) clearTimeout(debounceTimeout);
          debounceTimeout = setTimeout(async function() {
            let threadId = activeThreadId;
            await db.threads.update(threadId, {unsentMessageText: $.messageInput.value});
          }, 500);
        }, {passive: true});
      }


      async function sendButtonClickHandler() {
        $.sendButton.disabled = true;

        try {
          await incrementOperationsSinceLastExport();

          let threadId = activeThreadId;
          let thread = await db.threads.get(threadId);
          let characterId = thread.characterId;
          let threadCharacter = await db.characters.get(characterId);
          let message = $.messageInput.value;
          let repliesToGenerate = Number($.repliesPerSendMenu.value);

          // This use used to detect if the browser is not allowing persistent storage, even if the user has been using the app for quite a while.
          // Can't just use e.g. message count because user could have just imported a bunch of messages.
          let datesApplicationWasUsedInThisBrowser = (await db.misc.get("datesApplicationWasUsedInThisBrowser"))?.value ?? [];
          datesApplicationWasUsedInThisBrowser.push(new Date().toISOString().slice(0,10));
          datesApplicationWasUsedInThisBrowser = [...new Set(datesApplicationWasUsedInThisBrowser)];
          await db.misc.put({key: "datesApplicationWasUsedInThisBrowser", value: datesApplicationWasUsedInThisBrowser});

          // if user sent message history contains message, move it to the end, otherwise add it to the end:
          let userMessageHistoryEntry = thread.userMessagesSentHistory.find(x => x.text === message);
          if(userMessageHistoryEntry) {
            thread.userMessagesSentHistory.splice(thread.userMessagesSentHistory.indexOf(userMessageHistoryEntry), 1);
          } else {
            userMessageHistoryEntry = {text:message, isPinned:false};
          }
          thread.userMessagesSentHistory.push(userMessageHistoryEntry);
          // ensure isPinned items are at the end of the array:
          thread.userMessagesSentHistory.sort((a,b) => a.isPinned === b.isPinned ? 0 : a.isPinned ? 1 : -1);
          // keep only the last 50 messages:
          thread.userMessagesSentHistory = thread.userMessagesSentHistory.slice(-30); 
          await db.threads.update(threadId, {userMessagesSentHistory:thread.userMessagesSentHistory});

          try {

            if(message.trim() === "/ai" || message.startsWith("/ai ")) {
              // $.messageInput.value = "";

              if(message.trim() === "/ai") {
                await doBotReplyIfNeeded({forceReply:true, expectsReply:false, allowMultipleReplies:true});
              } else {
                let replyInstruction = message.replace(/^\/ai /, "").trimStart();
                // extract char name and ID from start of message if it's present
                let charNameAndId = replyInstruction.match(/^@([^#]+)#([0-9]+)/);
                let characterOverride = null;
                if(charNameAndId) {
                  // let charName = charNameAndId[1];
                  let characterId = parseInt(charNameAndId[2]);
                  characterOverride = await db.characters.get(characterId);
                  if(!characterOverride) {
                    alert(`CharacterID not found: #${characterId}`);
                  }
                  replyInstruction = replyInstruction.replace(/^@([^#]+)#([0-9]+)/, "").trim() || null;
                }
                await doBotReplyIfNeeded({forceReply:true, replyInstruction, characterOverride, expectsReply:false, allowMultipleReplies:true});
              }

            } else if(message.trim() === "/user" || message.trim().startsWith("/user ")) {
              if(message.trim() === "/user") {
                let characterToReplyWith = await getUserCharacterObj(threadId);
                characterToReplyWith.modelName = thread.modelName; // use whatever model the thread character is using
                await doBotReplyInPlaceOfUser({characterToReplyWith, expectsReply:false});
                // await doBotReplyIfNeeded();
              } else {
                let replyInstruction = message.replace(/^\/user /, "").trimStart();
                // extract char name and ID from start of message if it's present
                let charNameAndId = replyInstruction.match(/^@([^#]+)#([0-9]+)/);
                let characterToReplyWith = null;
                if(charNameAndId) {
                  // let charName = charNameAndId[1];
                  let characterId = parseInt(charNameAndId[2]);
                  characterToReplyWith = await db.characters.get(characterId);
                  if(!characterToReplyWith) {
                    alert(`CharacterID not found: #${characterId}`);
                  }
                  replyInstruction = replyInstruction.replace(/^@([^#]+)#([0-9]+)/, "").trim() || null;
                }
                if(!characterToReplyWith) {
                  characterToReplyWith = await getUserCharacterObj(threadId);
                }
                await doBotReplyInPlaceOfUser({characterToReplyWith, replyInstruction, expectsReply:false});
              }
            } else if(message.trim() === "/sum") {
              // first ensure summary is up to date:
              let loadingModal = createLoadingModal("Please wait...");
              const onProgressMessage = (e) => loadingModal.updateContent("Please wait... "+e.message);
              let {summary, instructionHash, remainingMessages} = await computeAndSaveThreadSummaryIfNeeded({threadId, onProgressMessage});
              loadingModal.delete();
              if(summary === undefined) {
                return alert("No summary available for this thread yet. Wait until the thread gets longer.");
              }
              // now let them edit it:
              let result = await prompt2({summary: {label: "Summary:", type: "text", height:"fit-content", defaultValue: summary, focus:true}});
              if(result) {
                await db.summaries.update(instructionHash, {summary:result.summary});
                addToDebugLog(`<b>edited summary:</b> ${result.summary}`);
              }
            } else if(message.trim() === "/import") {
              let defaultValue = "";
              while(1) {
                let result = await prompt2({
                  messagesText: {label: `Add messages in the same format as <a href='${projectDocsURL}/initial-messages.md' target='blank'>initial messages</a> to add them to this thread:`, type: "text", height:"fit-content", defaultValue: "", placeholder:"[USER]: Here's a user message.\n[SYSTEM]: Here's a system message.\n[AI]: Here's an AI message.\n[USER]: Messages can be multi-line\nlike this.", focus:true},
                });
                if(!result) break;
                let messages = parseMessagesFromTextFormat(result.messagesText);
                if(!messages) {
                  defaultValue = result.messagesText;
                  alert("Invalid message formating. Should start with either '[SYSTEM]:' or '[USER]:' or '[AI]:' (without the quotes).");
                } else {
                  let loadingModal = createLoadingModal("Please wait...");
                  let i = 0;
                  for(let message of messages) {
                    let messageCharacterId;
                    if(message.author === "ai") messageCharacterId = characterId;
                    else if(message.author === "user") messageCharacterId = -1;
                    else if(message.author === "system") messageCharacterId = -2;
                    else {
                      alert("There's a problem with parseMessagesFromTextFormat - it's producing an invalid 'author' value. Please report this problem on Github or the Discord server.");
                      defaultValue = result.messagesText;
                      continue;
                    }
                    let messageObj = createMessageObj({threadId, message:message.content, characterId:messageCharacterId, hiddenFrom:message.hiddenFrom || []});
                    messageObj.id = await addMessageToDb(messageObj);
                    i++;
                    if(i % 10 === 0) loadingModal.updateContent(`Please wait... (${i}/${messages.length})`);
                  }
                  await renderMessageFeed(threadId);
                  loadingModal.delete();
                  break;
                }
              }
              $.messageInput.value = "";
            } else if(message.trim() === "/mem") {
              let embeddingModelName = await getRealTextEmbeddingModelName(thread.textEmbeddingModelName);

              let originalGeneratedMemories = await db.memories.where({threadId, status:"current"}).toArray();
              originalGeneratedMemories.sort((a,b) => a.index - b.index);

              let textToMemoryObj = new Map();
              for(let entry of originalGeneratedMemories) {
                if(textToMemoryObj.has(entry.text)) {
                  // there's a duplicate, so for now we just hackily add a space to the end to avoid problems with mapping entries back to their object:
                  while(textToMemoryObj.has(entry.text)) {
                    entry.text += " ";
                  }
                  await db.memories.update(entry.id, {text:entry.text});
                }
                textToMemoryObj.set(entry.text, entry);
              }

              let textToEmbeddingCache = new Map();
              for(let entry of originalGeneratedMemories) {
                if(entry.embeddings[embeddingModelName] === undefined) { // <-- entry may not have an embedding if the embedding model was changed (or if there's a bug)
                  console.warn("Memory entry has no embedding for the current embedding model:", entry);
                } else {
                  textToEmbeddingCache.set(entry.text, entry.embeddings[embeddingModelName]);
                }
              }


              let originalGeneratedMemoriesText = originalGeneratedMemories.map(m => `${m.text}`).join("\n\n");

              let generatedDefaultValue = originalGeneratedMemoriesText;

              let loadingModal;

              let controls;

              async function regenerateMemoriesHandler() {
                if(!confirm("This DELETE all SUMMARIES and MEMORIES. Fresh summaries and memories will be regenerated during your character's next reply. Are you sure you want to delete all summaries and memories?")) return;
                let { instructionHashChain } = await computeAndSaveThreadSummaryIfNeeded({threadId, exitOnFirstHashMissAndReturnHashChain:true});
                await db.transaction('rw', [db.summaries, db.memories], async tx => {
                  await tx.table("summaries").where("hash").anyOf(instructionHashChain).delete();
                  await tx.table("memories").where({threadId}).delete();
                });
                controls.cancel();
              }

              while(1) {

                controls = {};

                let result = await prompt2({
                  generatedMemoriesText: {label: "Edit character 'memories'. Entries should be separated with a blank line. Edits should not significantly change the overall chronology. Use the <b>/lore</b> command to store non-chronological facts/things.", type: "text", height:"fit-content", defaultValue:generatedDefaultValue, placeholder:"If this box is empty, your character hasn't stored any memories yet because the chat thread isn't long enough to warrant it."},
                  reloadLoreUrlsButton: {hidden:true, type:"buttons", label:null, buttons:[{text:"delete &amp; regenerate all memories", onClick:regenerateMemoriesHandler}]},
                }, {submitButtonText:"save", controls});
                if(!result) break;
                
                // we set these so that if there's an error (e.g. while embedding, or with database) the while loop continues and they don't lose their edits
                generatedDefaultValue = result.generatedMemoriesText;

                // note: bit hacky, but we only trim newlines from start and end - NOT spaces, since we are using spaces to distinguish between different memories with the same text
                let newGeneratedMemoryTextEntries = result.generatedMemoriesText.replace(/\r/g, "").split(/\n{2,}/).map(m => m.replace(/^\n+|\n+$/g, "")).filter(m => m);

                loadingModal = createLoadingModal("Computing memory embeddings. Please wait...", $.middleColumn);

                let newTexts = [];
                for(let text of newGeneratedMemoryTextEntries) {
                  if(!textToEmbeddingCache.has(text)) {
                    newTexts.push(text);
                  }
                }

                try {

                  let newEmbeddings = await embedTexts({textArr:newTexts, modelName:embeddingModelName, shouldCache:true});
                  for(let i = 0; i < newTexts.length; i++) {
                    textToEmbeddingCache.set(newTexts[i], newEmbeddings[i]);
                  }

                  if(originalGeneratedMemoriesText !== result.generatedMemoriesText || newEmbeddings.length > 0) { // we need the `newEmbeddings.length > 0` bit because of stuff related to duplicate memories (possibly only due to since-fixed database upgrade bug)
                    let newMemoryObjs = [];
                    let index = 0;
                    let prevSummaryHash = originalGeneratedMemories[0]?.summaryHash ?? ""; // empty string as a summary hash indicates that the memory doesn't "belong" to any summary
                    for(let text of newGeneratedMemoryTextEntries) {
                      let embedding = textToEmbeddingCache.get(text);
                      let obj;
                      let existingObj = textToMemoryObj.get(text);
                      if(existingObj && !newMemoryObjs.includes(existingObj)) { // need to check if it's already in newMemoryObjs (and create a new one if so) otherwise we get a duplicate key error because the object has an id property
                        obj = textToMemoryObj.get(text);
                        prevSummaryHash = obj.summaryHash;
                        obj.index = index;
                        if(obj.embeddings[embeddingModelName] === undefined) obj.embeddings[embeddingModelName] = textToEmbeddingCache.get(text); // needed due to since-fixed bug
                      } else {
                        let embedding = textToEmbeddingCache.get(text);
                        // we group new memories under the previous memory hash. a valid summary hash is necessary because it's what we use to 'validate' that memories are 'current' during the summarization process.
                        obj = {summaryHash:prevSummaryHash, threadId, text, characterId:thread.characterId, embeddings:{[embeddingModelName]:embedding}, status:"current", index, triggers:[]};
                      }
                      newMemoryObjs.push(obj);
                      index++;
                    }

                    await db.transaction('rw', db.memories, async tx => {
                      // note: entries lose their original id if they are edited, which means references from message.memoryIdBatchesUsed are lost - that's okay, since it's just used for 'debugging' anyway - we just indicate to the user (in the 'brain icon modal') that the memory no longer exists.
                      await tx.table("memories").where({threadId, status:"current"}).delete();
                      await tx.table("memories").bulkAdd(newMemoryObjs);
                    });
                  }

                } catch(e) {
                  alert("There was an error while saving the memories:\n"+e.stack);
                  loadingModal.delete();
                  continue;
                }
                
                loadingModal.delete();
                break;
              }
              $.messageInput.value = "";
            } else if(message.trim().startsWith("/lore ")) {
              // text following /lore is a lore entry to add to db.lore
              let loadingModal = createLoadingModal("Computing lore embedding. Please wait...", $.middleColumn);
              let text = message.trim().slice("/lore ".length);
              let bookId = thread.loreBookId;
              let modelName = await getRealTextEmbeddingModelName(thread.textEmbeddingModelName);
              let embedding = await embedTexts({textArr:[text], modelName});
              let obj = {bookId, bookUrl:null, text, embeddings:{[modelName]:embedding[0]}, triggers:[]};
              await db.lore.add(obj);
              loadingModal.delete();
              $.messageInput.value = "";
            } else if(message.trim() === "/lore") {
              let loreBookId = thread.loreBookId;
              if(loreBookId === undefined) debugger;
              let originalLoreEntries = await db.lore.where({bookId:loreBookId}).toArray();

              let textToEmbeddingCache = new Map();
              for(let entry of originalLoreEntries) {
                textToEmbeddingCache.set(entry.text, entry.embedding);
              }

              let textToLoreObj = new Map();
              for(let entry of originalLoreEntries) {
                textToLoreObj.set(entry.text, entry);
              }

              let originalLoreEntriesText = originalLoreEntries.map(m => `${m.text}`).join("\n\n");

              let loreDefaultValue = originalLoreEntriesText;

              let loreBookUrlEntries = await db.lore.where("bookUrl").anyOf(threadCharacter.loreBookUrls).toArray();

              while(1) {
                let controls = {}; // this will get populated with `data` object that is proxied such that we can update the values of the inputs in reloadButtonClickHandler.

                async function reloadButtonClickHandler() {
                  let embeddingModelName = getRealTextEmbeddingModelName(thread.textEmbeddingModelName);
                  await ensureLoreUrlsAreLoaded({loreBookUrls:threadCharacter.loreBookUrls, modelName:embeddingModelName}).catch(e => {
                    console.error("Error loading lore urls:", e);
                    alert("Error loading lore urls: "+e);
                  });
                  loreBookUrlEntries = await db.lore.where("bookUrl").anyOf(threadCharacter.loreBookUrls).toArray();
                  controls.data.loreBookUrlEntriesText = loreBookUrlEntries.map(m => `${m.text}`).join("\n\n");
                }

                let result = await prompt2({
                  loreEntriesText: {label: "Add/edit lore entries for this thread. Entries should be separated with a blank line.", type: "text", height:"fit-content", defaultValue:loreDefaultValue, placeholder:"Here's an example lore entry.\n\nAnd here's another.\n\nAnd here's yet another. As you can see, lore entries should be separated with a blank line.", focus:true, infoTooltip:"Lorebook entries can be used to describe facts about your world, characters, towns, demographics, relationships, etc. The AI 'searches' the lorebook for relevant entries when it's trying to work out the most appropriate thing to say/write next. Use relevant words, phrases, character names, etc. in each entry to help it trigger it at the appropriate moments. Don't make lore entries too big - probably aim for a few sentences per entry, at most. You can add thousands of entries - it will NOT increase the price or slow down replies any more than if you only had e.g. 10 entries. You should think of lore entries like \"dynamic reminder messages\" which get read by the AI only when they're deemed relevant to the current situation in your story/chat."},
                  loreBookUrlEntriesText: {hidden:true, label: "Here are the entries loaded from this character's lorebook URLs. You can't edit these directly. Click the reload button below to pull in any changes that have been made to the character's lorebook URLs or the content at those URLs.", type: "text", disabled:true, height:"fit-content", defaultValue:loreBookUrlEntries.map(e => e.text).join("\n\n")},
                  reloadLoreUrlsButton: {hidden:true, type:"buttons", label:null, buttons:[{text:"Reload Lore URLs", onClick:reloadButtonClickHandler}]},
                }, {submitButtonText:"save", controls});
                if(!result) break;
                
                // we set these so that if there's an error (e.g. while embedding, or with database) the while loop continues and they don't lose their edits
                loreDefaultValue = result.loreEntriesText;

                let newLoreEntries = result.loreEntriesText.replace(/\r/g, "").split(/\n{2,}/).map(e => e.trim()).filter(e => e);

                // remove duplicates from newLoreEntries to prevent problems with our textToLoreObj mappings.
                // doesn't make sense to have duplicate memories anyway.
                newLoreEntries = [...new Set(newLoreEntries)];

                let loadingModal = createLoadingModal("Computing lore embeddings. Please wait...", $.middleColumn);

                let embeddingModelName = await getRealTextEmbeddingModelName(thread.textEmbeddingModelName);
                let newTexts = [];
                for(let text of newLoreEntries) {
                  if(!textToEmbeddingCache.has(text)) {
                    newTexts.push(text);
                  }
                }

                try {

                  let newEmbeddings = await embedTexts({textArr:newTexts, modelName:embeddingModelName});
                  for(let i = 0; i < newTexts.length; i++) {
                    textToEmbeddingCache.set(newTexts[i], newEmbeddings[i]);
                  }

                  if(originalLoreEntriesText !== result.loreEntriesText) {
                    let newLoreEntryObjs = [];
                    for(let text of newLoreEntries) {
                      let obj;
                      if(textToLoreObj.has(text)) {
                        obj = textToLoreObj.get(text);
                      } else {
                        let embedding = textToEmbeddingCache.get(text);
                        obj = {bookId:loreBookId, bookUrl:null, text, embeddings:{[embeddingModelName]:embedding}, triggers:[]};
                      }
                      newLoreEntryObjs.push(obj);
                    }

                    await db.transaction('rw', db.lore, async tx => {
                      // note: entries lose their original id if they are edited, which means references from message.loreIdsUsed are lost - that's okay, since it's just used for 'debugging' anyway - we just indicate to the user (in the 'brain icon modal') that the lore entry no longer exists.
                      await tx.table("lore").where({bookId:loreBookId}).delete();
                      await tx.table("lore").bulkAdd(newLoreEntryObjs);
                    });
                  }

                } catch(e) {
                  alert("There was an error while saving the lore entries:\n"+e.stack);
                  continue;
                }
                
                loadingModal.delete();
                break;
              }
              $.messageInput.value = "";
            } else if (message.trim() === "/flushembeds") {
              let oldTextEmbeddingModelName = thread.textEmbeddingModelName;
              let newTextEmbeddingModelName = threadCharacter.textEmbeddingModelName;
              await db.textEmbeddingCache.clear();
              console.log("Flushed text embedding cache.");
              if (oldTextEmbeddingModelName != newTextEmbeddingModelName) {
                await db.threads.update(threadId, {textEmbeddingModelName: newTextEmbeddingModelName});
                console.log("Reset thread text embedding model from " + oldTextEmbeddingModelName + " to " + newTextEmbeddingModelName);
              }
              $.messageInput.value = "";
            } else if ((message.trim() === "/respacemessageorders") || (message.trim() === "/rmo")) {
              await respaceThreadMessageOrders(threadId);
              $.messageInput.value = "";
            } else if(message.startsWith("/name ") || message.startsWith("/avatar ")) {
              let arg = message.replace(/^\/(name|avatar) /, "");
              if(message.startsWith("/name ")) {
                let regex = new RegExp(characterNameValidationPattern);
                if(regex.test(arg)) {
                  thread.userCharacter.name = arg;
                  alert(`Your name has been changed to "${arg}" for this particular thread.`);
                } else {
                  alert(`Names must only contain letters, numbers, spaces, hyphens and underscores, and must be 64 characters or less. This is due to OpenAI API limitations.`);
                }

                // warn about changing name after summarization has started:
                let summaryCount = await db.summaries.where("threadId").equals(threadId).count();
                if(summaryCount > 0 && threadCharacter.fitMessagesInContextMethod === "summarizeOld") {
                  let warningMessage = `Warning: This character has summaries enabled which means that the summaries may contain references to your old name. You can see and edit the summary by typing /sum in the chat.`;
                  if(threadCharacter.associativeMemoryMethod !== "none") warningMessage += ` This is also the case for character memories. You can see and edit memories by typing /mem in the chat.`;
                  warningMessage += `\n\nIt's best to do any name changes at the start of the thread, before summaries${threadCharacter.associativeMemoryMethod !== "none" ? " and memories" : ""} start to be computed/stored.`;
                  alert(warningMessage);
                }
              } else if(message.startsWith("/avatar ")) {
                thread.userCharacter.avatar.url = arg;
              }
              await db.threads.update(threadId, {userCharacter: thread.userCharacter});
              await renderMessageFeed(threadId, {forceFullRender:true});
              $.messageInput.value = "";
            } else {

              let senderCharacterId = -1;
              if(message.startsWith("/sys ")) {
                message = message.replace(/^\/sys /, "");
                senderCharacterId = -2;
              }
              if(message.startsWith("/system ")) {
                message = message.replace(/^\/system /, "");
                senderCharacterId = -2;
              }

              let lastLineCommand = null;
              if(senderCharacterId === -1) {
                // user can end message with /ai <instruction> to give instruction to the AI for their reply:
                let messageLines = message.trim().split("\n");
                let lastLine = messageLines.pop();
                if(lastLine?.startsWith("/ai ") || lastLine?.startsWith("/user ")) {
                  message = messageLines.join("\n");
                  lastLineCommand = lastLine;
                }
              }

              const smartQuoteMethod = threadCharacter.smartQuoteMethod;
              const deleteEmoji = threadCharacter.deleteEmoji;
              message = sanitizeUserMessage(message, smartQuoteMethod, deleteEmoji);
              let messageObj = createMessageObj({threadId, message, characterId:senderCharacterId});
              
              let id = await addMessageToDb(messageObj);
              messageObj.id = id;
              
              let character;
              if(messageObj.characterId === -1) character = await getUserCharacterObj(threadId);
              if(messageObj.characterId === -2) character = await getSystemCharacterObj(threadId);

              await addMessageToFeed(messageObj, {character});
              
              $.messageInput.value = "";
              $.messageInput.style.height = "";
              await triggerMessageActionCustomCodeEvent({threadId, eventData:{}, eventName:"MessageAdded", triggerBotReply:false});

              if(lastLineCommand) {
                $.messageInput.value = lastLineCommand;
                await sendButtonClickHandler();
              } else {
                await doBotReplyIfNeeded({allowMultipleReplies:true}); // note that we can't just pass the replyInstruction here because doBotReplyIfNeeded can get called in the process of executing triggerMessageActionCustomCodeEvent, so we use the global instructionForNextBotReply instead
              }
            }
          } catch(e) {
            console.error(e);
            alert("sendButtonClickHandler error: "+e.stack);
            $.messageInput.value = message;
          }

          await db.threads.update(threadId, {unsentMessageText:$.messageInput.value});

          if(threadCharacter.fitMessagesInContextMethod === "summarizeOld") {
            // we don't `await` this because we want it to happen in the background
            computeAndSaveThreadSummaryIfNeeded({threadId});
          }

          let messageCount = await db.messages.count();
          if(await db.threads.count() === 1 && (messageCount === 4 || messageCount === 5)) {
            await showAdviceOnThreads(true);
          }

        } finally {
          $.sendButton.disabled = false;
        }

      } 

      async function queueUpAutoReplies(replies) {
        for(let reply of replies) {
          $.messageInput.value = reply;
          await sendButtonClickHandler();
        }
      }

      function getDateTimeString(utcMs) {
        let now = new Date();
        if(now-utcMs > 1000*60*60*24) return new Date(utcMs).toISOString().split('T')[0].replace(/-/g, "/")+" "+new Date(utcMs).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}).replace(/^0([0-9]):/, "$1:");
        else return new Date(utcMs).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}).replace(/^0([0-9]):/, "$1:");
      }

      // db naming --> public custom code API naming
      const characterPropertiesVisibleToCustomCode = {
        name: "name",
        avatar: "avatar",
        roleInstruction: "roleInstruction",
        reminderMessage: "reminderMessage",
        initialMessages: "initialMessages",
        customCode: "customCode",
        temperature: "temperature",
        topP: "topP",
        frequencyPenalty: "frequencyPenalty",
        presencePenalty: "presencePenalty",
        // bestOf: "bestOf",
        // maxTokens: "maxTokens",
        stopSequences: "stopSequences",
        modelName: "modelName",
        // note: we DO NOT expose `character.userCharacter` (and same for character.systemCharacter) - custom code instead edits thread.userCharacter, which is a copy of character.userCharacter that's created at the start of a new thread
        // scene: "scene", // not exposing `scene` yet because I think it should probably be like userCharacter - i.e. instantiated as a thread property. but devs can edit scene by adding to messages anyway so no rush here.
        streamingResponse: "streamingResponse",
        customData: "customData",
        maxTokensPerMessage: "maxTokensPerMessage",
      };

      
      const customCodeIframes = {}; // threadId -> iframe
      async function createNewCustomCodeIframeForThread(threadId) {

        let thread = await db.threads.get(threadId);
        let character = await db.characters.get(thread.characterId);
        let customCode = (await db.characters.get(thread.characterId)).customCode || "";

        if(customCodeIframes[threadId]) {
          delete customCodeIframes[threadId];
        }

        let iframe = document.createElement("iframe");

        let pageLoadId = Math.random().toString();
        let iframeLoadPromise = new Promise((resolve, reject) => {
          function handler(e) {
            if(e.data._id === pageLoadId) {
              resolve();
              window.removeEventListener("message", handler);
            }
          }
          window.addEventListener("message", handler);
        });

        iframe.setAttribute("sandbox", "allow-scripts");
        // we MUST NOT set display:none here, because otherwise window.innerWidth/innerHeight are zero on init, which can confuse plugin devs.
        // instead we set opacity:0 and pointer-events:none, and then switch to display:none after load.
        iframe.style.cssText = "border:0; width:100%; height:100%; pointer-events:none; opacity:0; display:absolute; background:var(--background);";
        iframe.dataset.threadId = threadId;
        
        // let floatingWindow = createFloatingWindow({header:character.name, closeButtonAction:"hide"});
        // floatingWindow.bodyEl.appendChild(iframe);
        // floatingWindow.hide();

        $.customCodeIframeCtn.appendChild(iframe);
        customCodeIframes[threadId] = iframe;

        let srcDoc = dedent(`
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width">
          <base target="_blank">
        </head>
        <body>
        <script type="module">
          window.___dataInitializationFINISHED_836283628 = false;

          // Proxy fetch to remove CORS restrictions
          const proxyHandler = {
            apply: async function (target, thisArg, argumentsList) {
              let url;
              if(typeof argumentsList[0] === "object") url = argumentsList[0].url;
              else url = argumentsList[0];

              if(url.startsWith("blob:") || url.startsWith("data:")) return target.call(thisArg, ...argumentsList);

              let origin = new URL(url).origin;

              // for performance, exclude some CDNs that don't need CORS proxying
              if(
                origin.endsWith("jsdelivr.net")
                || origin.endsWith("catbox.moe")
                || (origin.endsWith("huggingface.co") && url.includes("/resolve/"))
                || origin === "https://raw.githubusercontent.com"
              ) {
                return target.call(thisArg, ...argumentsList);
              }

              // Note: This proxy server's code is public - you can see the code here: https://replit.com/@joe64/opencharacters-cors-proxy
              // It's what allows characters to make arbitrary requests to resources on the internet.
              // DO NOT use this URL directly in your code. The URL may change in future and your code will break.
              // Just use 'fetch' as normal and this proxy will be used automatically.
              // Note: I was originally trying a normal fetch and then only falling back to this CORS proxy if it failed, but the problem with that is that this would hit the endpoint twice, which may have side effects, and the user might not want that.
              // I may eventually have to add manual "exemptions" to skip proxying certain URLs that don't need it - like huggingface models, for example, since we could start to become bandwidth limited.
              // EDIT: Moved to Glitch since Replit raised prices to an absurd $6/month for a 0.25 vCPU machine in Jan 2024 (no more "Always On" machines - only "Deployments" now).
              const proxiedUrl = "https://opencharacters-cors-proxy.glitch.me?url=" + encodeURIComponent(url);
              try {
                if(typeof argumentsList[0] === "object") {
                  argumentsList[0] = new Request(proxiedUrl, argumentsList[0]);
                  return target.call(thisArg, ...argumentsList);
                } else {
                  return target.call(thisArg, proxiedUrl, ...argumentsList.slice(1));
                }
              } catch(e) {
                console.error(e);
                return target.call(thisArg, ...argumentsList); // try unproxied if proxied fails
              }
            },
          };
          const originalFetch = window.fetch;
          window.fetch = new Proxy(fetch, proxyHandler);

          (function() {
            let userHandlers = {
              messageadded: [],
              messageedited: [],
              messagedeleted: [],
              messageinserted: [],
              streamingmessagechunk: [],
              streamingmessage: [],
            };
            let dataChangedByCustomCode = false;
            let dataSnapshotWhenLastSentToMainThread = null;
            
            window.oc = {
              thread: Object.seal({
                name: undefined,
                messages: [],
                userCharacter: Object.seal({
                  name: undefined,
                  avatar: Object.seal({
                    url: undefined,
                    size: undefined,
                    shape: undefined,
                  }),
                }),
                systemCharacter: Object.seal({
                  name: undefined,
                  avatar: Object.seal({
                    url: undefined,
                    size: undefined,
                    shape: undefined,
                  }),
                }),
                character: Object.seal({
                  name: undefined,
                  avatar: Object.seal({
                    url: undefined,
                    size: undefined,
                    shape: undefined,
                  }),
                  reminderMessage: undefined,
                  roleInstruction: undefined,
                }),
                customData: null,
                messageWrapperStyle: null,
                on: function(eventName, callback) {
                  userHandlers[eventName.toLowerCase()].push(callback);
                },
                off: function(eventName, callback) {
                  let i = userHandlers[eventName.toLowerCase()].indexOf(callback);
                  if(i !== -1) userHandlers[eventName.toLowerCase()].splice(i, 1);
                },
                once: function(eventName, callback) {
                  let handler = function() {
                    callback.apply(this, arguments);
                    this.off(eventName, handler);
                  }.bind(this);
                  this.on(eventName, handler);
                },
              }),
              character: Object.seal({
              ${Object.values(characterPropertiesVisibleToCustomCode).map(prop => `
                ${prop}: null,
              `).join("\n")}
                avatarUrl: null, // for backwards-compat
              }),
              window: Object.seal({
                show: function(args={}) {
                  window.parent.postMessage({type:"showWindow", threadId:${threadId}, args}, "*");
                },
                hide: function(args={}) {
                  window.parent.postMessage({type:"hideWindow", threadId:${threadId}, args}, "*");
                },
              }),
              //getCompletion: async function(options) {
              //  let data = {type:"getCompletion", options};
              //  return callParentWindow(data);
              //},
              getChatCompletion: async function(options) {
                let data = {type:"getChatCompletion", options};
                return callParentWindow(data);
              },
              messageRenderingPipeline: [],
            };


            // Construct StreamingMessage event out of StreamingMessageChunk events:
            class AsyncQueue {
              constructor() {
                this.queue = [];
                this.resolvers = [];
              }
              push(value) {
                if(this.resolvers.length > 0) this.resolvers.shift()(value);
                else this.queue.push(value);
              }
              async pop() {
                if(this.queue.length > 0) return this.queue.shift();
                return new Promise((resolve) => { this.resolvers.push(resolve); });
              }
            }
            async function* readChunks(streamId, queue) {
              while (true) {
                const chunk = await queue.pop();
                if(!chunk) break;
                yield chunk;
                if(chunk.last) {
                  streamQueues.delete(streamId);
                  break;
                }
              }
            }
            const streamQueues = new Map();
            oc.thread.on("StreamingMessageChunk", async function (chunk) {
              const { streamId } = chunk;
              let queue = streamQueues.get(streamId);
              if(!queue) {
                queue = new AsyncQueue();
                streamQueues.set(streamId, queue);
                for(let handler of userHandlers.streamingmessage) {
                  handler({ streamId, chunks: readChunks(streamId, queue) });
                }
              }
              queue.push(chunk);
            });

            function callParentWindow(data) {
              let _id = Math.random().toString()+Math.random().toString();
              return new Promise((resolve, reject) => {
                window.parent.postMessage({_id, data, threadId:${threadId}}, "*");
                function handler(e) {
                  if(e.data._id === _id) {
                    window.removeEventListener("message", handler);
                    if(e.data.success) resolve(e.data.result);
                    else reject(e.data.result);
                  }
                }
                window.addEventListener("message", handler);
              });
            }

            const originalOcObject = window.oc;

            // function watchObject(obj, callback) {
            //   let proxy = new Proxy(obj, {
            //     set: function(target, prop, value) {
            //       target[prop] = value;
            //       callback(prop, value);
            //       return true;
            //     }
            //   });
            //   return proxy;
            // }
            // function watchArray(arr, callback) {
            //   // note that we need to watch set and get because get is called for push/pop/etc.
            //   let proxy = new Proxy(arr, {
            //     set: function(target, prop, value) {
            //       target[prop] = value;
            //       callback(prop);
            //       return true;
            //     },
            //     get: function(target, prop) {
            //       if(isNaN(Number(prop))) { // ignore array indexing
            //         callback(prop); 
            //       }
            //       return target[prop];
            //     }
            //   });
            //   return proxy;
            // }

            // TODO: later we can track changes in a more fine-grained way to reduce data transfer between this frame and parent

            // oc.thread.messages = watchArray(oc.thread.messages, (prop) => {
            //   dataChangedByCustomCode = true;
            // });
            // let currentThreadMessagesArray = oc.thread.messages;
            // let ignoreMessagePropSetter = false;
            // window.oc.thread = watchObject(oc.thread, (prop, value) => {
            //   if(ignoreMessagePropSetter) return;
            //   // if they set the messages prop to a new array, we need to watch that array:
            //   if(prop === "messages" && value && value !== currentThreadMessagesArray) { // NOTE: oc.thread.messages is *already* set to 'value', so we need to track with currentThreadMessagesArray
            //     ignoreMessagePropSetter = true; // need to ignore because we're about to change oc.thread.messages which would cause infinite loop
            //     oc.thread.messages = watchArray(value, (prop) => {
            //       dataChangedByCustomCode = true;
            //     });
            //     ignoreMessagePropSetter = false;
            //     currentThreadMessagesArray = oc.thread.messages;
            //   }
            //   dataChangedByCustomCode = true;
            // });
            // window.oc.character = watchObject(oc.character, (prop) => {
            //   dataChangedByCustomCode = true;
            // });


            // https://stackoverflow.com/a/58983264/11950764
            // This tracks all changes to the object, including nested objects, and including new objects/arrays that are added as properties.
            let deepOnChangeProxyCache = new WeakMap();
            function createDeepOnChangeProxy(target, onChange) {
              return new Proxy(target, {
                get(target, property) {
                  const item = target[property];
                  if (item && typeof item === 'object') {
                    if (deepOnChangeProxyCache.has(item)) return deepOnChangeProxyCache.get(item);
                    const proxy = createDeepOnChangeProxy(item, onChange);
                    deepOnChangeProxyCache.set(item, proxy);
                    return proxy;
                  }
                  return item;
                },
                set(target, property, newValue) {
                  target[property] = newValue;
                  onChange();
                  return true;
                },
              });
            }


            window.oc.character = createDeepOnChangeProxy(window.oc.character, function() {
              dataChangedByCustomCode = true;
            });
            window.oc.thread = createDeepOnChangeProxy(window.oc.thread, function() {
              dataChangedByCustomCode = true;
            });

            window.oc = Object.freeze(window.oc);




            function getCurrentData() {
              // we need to ignore the Proxy trigger while we do this:
              let origFlag = dataChangedByCustomCode;
              let data = JSON.parse(JSON.stringify(oc));
              dataChangedByCustomCode = origFlag;
              return data;
            }
            function getChangedData() {
              let origFlag = dataChangedByCustomCode;
              let prevData = dataSnapshotWhenLastSentToMainThread;
              let changedData = getCurrentData();
              // delete any values of changedData that were the same as existing data so we only send back changes:
              for(let key in prevData.thread) {
                if(typeof prevData.thread[key] === "object") {
                  // need to stringify to test sameness of arrays and other non-primitives:
                  // TODO: maybe make this more efficient at some point - stringifying a huge thread could be sluggish
                  // TODO: and it should really just send back a *delta*, rather than whole messages array
                  if(JSON.stringify(prevData.thread[key]) === JSON.stringify(changedData.thread[key])) delete changedData.thread[key];
                } else {
                  if(prevData.thread[key] === changedData.thread[key]) delete changedData.thread[key];
                }
              }
              for(let key in prevData.character) {
                if(typeof prevData.character[key] === "object") {
                  if(JSON.stringify(prevData.character[key]) === JSON.stringify(changedData.character[key])) delete changedData.character[key];
                } else {
                  if(prevData.character[key] === changedData.character[key]) delete changedData.character[key];
                }
              }
              dataChangedByCustomCode = origFlag;
              return changedData;
            }
            async function sendBackDataUpdatesIfNeeded() {
              if(dataChangedByCustomCode) {
                let changedData = getChangedData();
                // if(changedData.thread.messages && new Set(changedData.thread.messages.map(m => m.content)).size < changedData.thread.messages.length) {
                //   debugger;
                // }
                dataChangedByCustomCode = false;
                dataSnapshotWhenLastSentToMainThread = getCurrentData();
                console.log("Custom code changed character/thread data:", changedData);
                await callParentWindow({type:"dataChanged", data:changedData})
              }
            }

            let currentlyProcessingMessageActionHandlers = false;
            (async function() {
              while(1) {
                try {
                  // TODO: make this more efficient - polling is not ideal
                  await new Promise(r => setTimeout(r, 100));

                  // MessageAdded/MessageEdited event is special in that it sends data back immediately afterwards,
                  // so to prevent any weirdness, we wait for it to finish:
                  while(currentlyProcessingMessageActionHandlers) {
                    await new Promise(r => setTimeout(r, 100));
                  }

                  if(dataChangedByCustomCode) {
                    await sendBackDataUpdatesIfNeeded();
                  }
                } catch(e) {
                  console.error(e);
                }
              }
            })();




            window.addEventListener("message", async function(e) {
              if(e.source !== window.parent || e.origin !== "${window.location.origin}") return;

              if(e.data.eventName?.toLowerCase() !== "streamingmessagechunk") {
                console.log("customCode iframe received message (note: streamingmessagechunk messages are not logged):", e.data);
              }

              if(!e.data._id) return;
              if(window.oc !== originalOcObject) {
                // oc is frozen and oc.character/thread are sealed, but they can still overwrite window.oc - however, this is a security issue, since oc gets JSONified and sent back to the main thread when data changes, and I don't want to have to deal with unexpected properties on the main thread because it could be dangerous
                window.parent.postMessage({_id:e.data._id, success:false, result:"oc has been modified. Please do not modify window.oc."}, "${window.location.origin}");
                return;
              }

              if(e.data.type === "function") {
                try {
                  let fn = new Function(\`return (\${e.data.functionText})\`)();
                  let output = await fn(e.data.functionArg);
                  window.parent.postMessage({_id:e.data._id, success:true, result:output}, "${window.location.origin}");
                } catch(err) {
                  console.error(err);
                  window.parent.postMessage({_id:e.data._id, success:false, result:err.message+"\\n"+err.stack}, "${window.location.origin}");
                }
              }

              if(e.data.type === "event") {
                let eventName = e.data.eventName.toLowerCase();
                
                if(eventName === "messageadded" || eventName === "messageedited"  || eventName === "messagedeleted" || eventName === "messageinserted") {
                  currentlyProcessingMessageActionHandlers = true; // <-- we use this variable to pause the normal data update polling.
                  let returnData = null;
                  try {
                    let updates = e.data.data.updates;
                    let eventData = e.data.data.eventData;

                    let userFacingEventData = {};

                    // this must come *before* overwriting oc.thread.messages because after that point we can't get the original message object
                    if(eventName === "messagedeleted") {
                      userFacingEventData.message = oc.thread.messages.find(m => m.id === eventData.messageId);
                      userFacingEventData.originalIndex = oc.thread.messages.findIndex(m => m.id === eventData.messageId);
                    }
                    
                    let origFlag = dataChangedByCustomCode;
                    oc.thread.messages = updates.thread.messages;
                    dataChangedByCustomCode = origFlag;

                    // this must come *after* overwriting oc.thread.messages because we want event.message to be an actual reference to the message object that's currently in the oc.thread.messages array.
                    if(eventName !== "messagedeleted") {
                      if(eventName === "messageadded") {
                        userFacingEventData.message = oc.thread.messages.at(-1);
                      } else {
                        userFacingEventData.message = oc.thread.messages.find(m => m.id === eventData.messageId);
                      }
                    }
                    
                    await Promise.all(userHandlers[eventName].map(handler => handler(userFacingEventData)));
                    
                    if(dataChangedByCustomCode) {
                      returnData = getChangedData();
                      dataChangedByCustomCode = false;
                      dataSnapshotWhenLastSentToMainThread = getCurrentData();
                    }
                  } catch(e) {
                    console.error(\`There was an error while processing the \${eventName} event:\`);
                    console.error(e);
                  }
                  console.log("custom code iframe sending back:", returnData);
                  window.parent.postMessage({_id:e.data._id, success:true, result:returnData}, "${window.location.origin}");
                  currentlyProcessingMessageActionHandlers = false;
                }

                if(eventName === "streamingmessagechunk") {
                  let data = e.data.data;
                  await Promise.all(userHandlers.streamingmessagechunk.map(handler => handler(data)));
                }

              }

              if(e.data.type === "init") {

                function applyObjectOverrides({object, overrides}) {
                  for(let key in overrides) {
                    if(Array.isArray(overrides[key])) {
                      object[key] = structuredClone(overrides[key]); // arrays are treated as "final" values - we don't go "into" them
                    } else if(typeof overrides[key] === "object" && overrides[key] !== null) {
                      if (!object.hasOwnProperty(key) || typeof object[key] !== "object" || object[key] === null) {
                        object[key] = {};
                      }
                      applyObjectOverrides({object:object[key], overrides:overrides[key]});
                    } else {
                      object[key] = overrides[key];
                    }
                  }
                }

                let data = e.data.initialData;
                applyObjectOverrides({object:oc.thread, overrides:data.thread});
                applyObjectOverrides({object:oc.character, overrides:data.character});
                window.___dataInitializationFINISHED_836283628 = true;
                dataChangedByCustomCode = false;
                dataSnapshotWhenLastSentToMainThread = getCurrentData();

                // it's important that we wait for custom code to finish loading before we indicate that init has finished.
                let loopDelay = 5;
                let waitedTime = 0;
                while(1) {
                  if(window.__customCodeInitializationIsComplete_846298638) {
                    break;
                  }
                  if(waitedTime > 10 && !window.__customCodeInitializationSTARTED_846298638) {
                    // it should at least *START* in milliseconds, so this almost certainly indicates they had a syntax error in their code which prevented the whole script tag from executing at all.
                    // note: *non-syntax* errors are caught by a try/catch loop. this is just for syntax errors.
                    break; // <-- break to prevent endless loading screen
                  }
                  await new Promise(r => setTimeout(r, loopDelay));
                  waitedTime += loopDelay;
                }
                
                window.parent.postMessage({_id:e.data._id, success:true, result:null}, "${window.location.origin}");
              }
            }, {passive: false};
          })();

          // this must come before the wait-for-initialization below, because it's what ends up triggering initialization
          window.addEventListener("load", () => {
            window.parent.postMessage({_id:"${pageLoadId}"}, "${window.location.origin}");
          }, {passive: false});

        <\/script>

        <!-- note: this must be a separate code block from above, because otherwise static imports are initialised before window.oc exists -->
        <script type="module" class="customCodeScriptElement">
          window.__customCodeInitializationSTARTED_846298638 = true;

          // we need to wait for the oc data to load because they may immediately reference it in their custom code
          while(1) {
            if(window.___dataInitializationFINISHED_836283628) break;
            await new Promise(r => setTimeout(r, 5));
          }
          console.log("Data initialization of sandboxed iframe is complete.");
          try {
            // currently the only reason this is wrapped in an async function is to throw an error if the user's code contains a static import, since static imports are pre-loaded and thus jump ahead of initialization
            // oh and maybe we need it to be able to catch wrap this try/catch around it too?
            await (async () => {
              {{customCode}}
            })();
          } catch(e) {
            console.error(e);
          }

          // backwards-compat with old processMessages function:
          if(window.processMessages) {
            oc.thread.on("MessageAdded", async function() {
              await window.processMessages(window.oc.thread.messages);
            });
          }
          window.__customCodeInitializationIsComplete_846298638 = true;
        <\/script>

        <!-- some code for helping devs with custom code bugs/problems: -->
        <script type="module">
          await new Promise(r => setTimeout(r, 100));

          let customCodeScriptElementText = document.querySelector(".customCodeScriptElement")?.textContent || ""; // optional chaining is needed since they may have deleted it via document.body.innerHTML=...

          if(!window.__customCodeInitializationSTARTED_846298638) { // if it hasn't *started* after 1 second, it's almost certainly a parsing bug
            let staticImportRegex = ${/(^|\s)import(\s+(\*\s+as\s+\w+|{[^}]*})?\s+from)?\s*['"][^'"]+\.js['"]\s*;?/.toString()};
            if(staticImportRegex.test(customCodeScriptElementText)) {
              console.warn("It looks like your character's custom code may have static import statements like:\\n\\nimport 'foo.js';  or  import { abc } from 'foo.js';\\n\\nIf so, please change them to dynamic imports like this:\\n\\nawait import('foo.js');  or  let { abc } = await import('foo.js');\\n\\nFor technical reasons, static imports are not supported in custom code.");
            }
          }
        <\/script>

        </body>
        </html>`); // need to escape the closing script tag so it doesn't close the script tag that this code is within
        
        // using template+split+join so dedent works properly
        iframe.srcdoc = srcDoc.split("{{customCode}}").join(customCode);

        await iframeLoadPromise;

        iframe.style.pointerEvents = "";
        iframe.style.opacity = "";
        iframe.style.display = "none";

        if(isMobile && activeThreadId === threadId && thread.customCodeWindow.visible && $.rightColumn.dataset.visible === "no") {
          // this is necessary (and must come before the triggerInitCustomCodeEvent call, below) because some iframes will require user interaction to initialize the thread - if dev shows the iframe, then they probably want the mobile user to see it first (new users probably wouldn't know to click the button that shows the iframe)
          $.toggleRightColumnButton.click();
        }

        await triggerInitCustomCodeEvent(threadId);

      }

      let customCodeResolvers = {}; // id -> resolver
      window.addEventListener("message", function(e) {
        let resolver = customCodeResolvers[e.data._id];
        if(resolver) {
          if(e.data.success) {
            resolver(e.data.result);
          } else {
            console.error(e);
            alert("There was a problem with this character's custom code:\n\n"+e.data.result);
            resolver(null);
          }
          delete customCodeResolvers[e.data._id];
        }
      }, {passive: false});

      window.addEventListener("message", async function(e) {
        let threadId = e.data.threadId;
        let args = e.data.args;
        let types = ["showWindow", "hideWindow"];
        if(types.includes(e.data?.type) && customCodeIframes[threadId]?.contentWindow === e.source) {
          let visible = null;
          if(e.data.type === "showWindow") visible = true;
          if(e.data.type === "hideWindow") visible = false;
          let thread = await db.threads.get(threadId);
          thread.customCodeWindow.visible = visible;
          if(args.width !== undefined && typeof args.width === "number" || typeof args.width === "string") {
            thread.customCodeWindow.width = args.width;
          }
          await db.threads.update(threadId, {customCodeWindow: thread.customCodeWindow});
          await updateCustomCodeIframeVisibility();
        }
      }, {passive: false});


      async function updateCustomCodeIframeVisibility() {
        let visibleThreadId = null;
        if($.messageFeed.offsetWidth > 0 && activeThreadId !== null) {
          visibleThreadId = activeThreadId;
        }
        let visibleThread = null;
        if(visibleThreadId !== null) visibleThread = await db.threads.get(visibleThreadId);

        let character = null;
        if(visibleThread !== null) character = await db.characters.get(visibleThread.characterId);

        $.customCodeIframeCtn.querySelectorAll(`iframe`).forEach(iframe => iframe.style.display = "none");
        $.customCodeColumn.style.display = "none";

        if(visibleThread !== null && character.customCode.trim() && visibleThread.customCodeWindow.visible === true) {
          customCodeIframes[visibleThreadId].style.display = "block";
          let width = visibleThread.customCodeWindow.width ?? "300px";
          if(typeof width === "number") width = width+"px";
          $.customCodeIframeCtn.style.width = width;
          $.customCodeColumn.style.display = "flex";
          if(isMobile) {
            $.toggleRightColumnButton.style.display = "flex";
            $.customCodeIframeCtn.style.width = "100%";
            if($.rightColumn.dataset.visible === "no") {
              $.toggleRightColumnButton.click();
            }
          }
        } else {
          if(isMobile) {
            $.toggleRightColumnButton.style.display = "none";
            if($.rightColumn.dataset.visible === "yes") {
              $.toggleRightColumnButton.click();
            }
          }
        }
      }

      $.customCodeIframeHorizontalResizeBar.addEventListener("mousedown", function(e) {
        e.preventDefault();

        // display an element that covers the entire screen, so that the user can drag the mouse over the iframe without losing mouse events:
        let cover = document.createElement("div");
        cover.style.cssText = "position:fixed;top:0;left:0;right:0;bottom:0;z-index:99";
        document.body.appendChild(cover);
        cover.addEventListener("mouseup", function() {
          cover.remove();
        });

        let startX = e.clientX;
        let startWidth = $.customCodeIframeCtn.offsetWidth;
        let mousemove = function(e) {
          let newWidth = startWidth - (e.clientX - startX);
          $.customCodeIframeCtn.style.width = newWidth+"px";
        };
        let mouseup = async function(e) {
          window.removeEventListener("mousemove", mousemove);
          window.removeEventListener("mouseup", mouseup);
          let visibleThreadId = activeThreadId;
          let visibleThread = await db.threads.get(visibleThreadId);
          visibleThread.customCodeWindow.width = $.customCodeIframeCtn.offsetWidth;
          await db.threads.update(visibleThreadId, {customCodeWindow: visibleThread.customCodeWindow});
        };
        window.addEventListener("mousemove", mousemove);
        window.addEventListener("mouseup", mouseup);
      }, {passive: false});


      let botIsCurrentlyReplyingPromise = null;


      // TODO: make this a user setting (in misc db)
      const customCodeCompletionTokenWarnLimit = 5_000_000; // $10 at current turbo-3.5 prices

      const customCodeCompletionUsage = {}; // token counts for each thread
      const threadIdsAllowedToGoOverTokenLimit = new Set();
      const threadIdsBlockedFromGoingOverTokenLimit = new Set();
      window.addEventListener("message", async function(e) {
        let threadId = e.data.threadId;
        let types = ["getChatCompletion", "dataChanged"];
        const data = e.data.data;
        if(data && types.includes(data.type) && customCodeIframes[threadId]?.contentWindow === e.source) {
          let thread = await db.threads.get(threadId);
          let character = await db.characters.get(thread.characterId);
          
          if(data.type === "getChatCompletion") {
            let options = data.options;
            let messages = options.messages;

            if(!messages || !messages[0].content || !messages[0].author) {
              let result = "Invalid parameter: The first input to oc.getChatCompletion should be an options object, and 'options.messages' must be an array of objects with 'content' and 'author' properties.";
              customCodeIframes[e.data.threadId].contentWindow.postMessage({_id:e.data._id, success:false, result}, "*");
              return;
            }

            // transform and clean the options data:
            options.messages.forEach(m => {
              m.content = m.content+"";
              m.role = m.author==="user"?"user" : m.author==="ai"?"assistant" : m.author==="system"?"system" : "system";
              if(m.name) m.name = m.name+"";
              let allowedKeys = ["content", "role", "name"];
              for(let key in m) {
                if(!allowedKeys.includes(key)) delete m[key];
              }
            });
            let o = {
              messages: options.messages,
              modelName: thread.modelName,
              temperature: options.temperature === undefined ? undefined : Number(options.temperature),
              stopSequences: Array.isArray(options.stopSequences) ? options.stopSequences.map(s => s+"") : undefined,
              topP: options.topP === undefined ? undefined : Number(options.topP),
              frequencyPenalty: options.frequencyPenalty === undefined ? undefined : Number(options.frequencyPenalty),
              presencePenalty: options.presencePenalty === undefined ? undefined : Number(options.presencePenalty),
            };
            if(!customCodeCompletionUsage[threadId]) customCodeCompletionUsage[threadId] = 0;
            let tokens = await countTokensInMessages(o.messages, thread.modelName);
            customCodeCompletionUsage[threadId] += tokens;
            if(customCodeCompletionUsage[threadId] > customCodeCompletionTokenWarnLimit && !threadIdsAllowedToGoOverTokenLimit.has(threadId)) {
              if(threadIdsBlockedFromGoingOverTokenLimit.has(threadId)) {
                return;
              }
              if(confirm(`This character's custom code has used ${customCodeCompletionUsage[threadId].toLocaleString()} tokens. Would you like to continue?`)) {
                threadIdsAllowedToGoOverTokenLimit.add(threadId);
              } else {
                threadIdsBlockedFromGoingOverTokenLimit.add(threadId);
                return;
              }
            }

            
            o.threadId = threadId; // this is just for tracking token usage

            let result = await getChatCompletion(o);
            customCodeCompletionUsage[threadId] += await countTokens(result, thread.modelName);
            customCodeIframes[e.data.threadId].contentWindow.postMessage({_id:e.data._id, success:true, result}, "*");
          }


          if(data.type === "dataChanged") {
            let receivedData = data.data;
            if(botIsCurrentlyReplyingPromise) {
              await botIsCurrentlyReplyingPromise; // otherwise we'll render the feed and thus delete the "typing indicator" placeholder or the streaming response
            }
            await updateDbWithNewDataFromCustomCode({threadId, receivedData});
            await renderMessageFeed(threadId);
            customCodeIframes[e.data.threadId].contentWindow.postMessage({_id:e.data._id, success:true, result:null}, "*");
          }

        }
      }, {passive: false});
      
      async function sendCustomCodeIframeMessage(threadId, data) {
        let iframe = customCodeIframes[threadId];
        let _id = Math.random().toString()+Math.random().toString();
        data._id = _id;
        iframe.contentWindow.postMessage(data, "*");
        return new Promise(r => {
          customCodeResolvers[_id] = r;
        });
      }

      // this is for onclick handlers in messages
      window.runCodeInCustomCodeIframe = function(code) {
        let threadId = activeThreadId;
        let functionText = `function() {
          ${code}
        }`;
        sendCustomCodeIframeMessage(threadId, {type:"function", functionText, functionArg:undefined});
      };

      async function getDataForCustomCode(threadId) {
        let thread = await db.threads.get(threadId);
        let threadCharacter = await db.characters.get(thread.characterId);

        let userCharacter = await getUserCharacterObj(threadId); // note that this function takes threadId as input because it thread-specific overrides, like for name and avatar url

        if(!threadCharacter.customCode?.trim()) return;

        let messages = await db.messages.where("threadId").equals(threadId).toArray();
        messages.sort((a,b) => a.order - b.order);
        // console.log("@@@@@@@@@@@ getDataForCustomCode: messages before formatting for custom code: ", messages);
        let formattedMessages = await messagesToCustomCodeFormat({messages});
        let data = {
          thread: {
            name: thread.name,
            messages: formattedMessages,
            userCharacter: thread.userCharacter,
            systemCharacter: thread.systemCharacter,
            customData: thread.customData,
            character: thread.character,
            messageWrapperStyle: thread.messageWrapperStyle,
          },
          character: {},
        };
        for(let key in characterPropertiesVisibleToCustomCode) {
          data.character[characterPropertiesVisibleToCustomCode[key]] = threadCharacter[key];
        }

        // backwards-compat properties:
        data.character.avatarUrl = threadCharacter.avatar.url;
        
        return {data, originalMessages:messages};
      }

      async function triggerInitCustomCodeEvent(threadId) {
        let {data, originalMessages} = await getDataForCustomCode(threadId);
        await sendCustomCodeIframeMessage(threadId, {type:"init", initialData:data});
      }

      // this function runs after every message is added: https://github.com/josephrocca/OpenCharacters/blob/main/docs/custom-code.md
      async function triggerMessageActionCustomCodeEvent({threadId, eventData, eventName, triggerBotReply=true}={}) {
        let thread = await db.threads.get(threadId);
        let threadCharacter = await db.characters.get(thread.characterId);

        if(!threadCharacter.customCode) return;

        $.statusNotifier.innerHTML = "<span style='opacity: 0.6; font-size: 0.9rem;'>‚åõ custom code processing</span><div style='width:0.5rem;'></div>"+createTypingIndicatorHtml();
        showEl($.statusNotifier);

        let { data, originalMessages } = await getDataForCustomCode(threadId);
        let updates = data;
        console.log(`@@@@@@@@@@@ Data sent to custom code for ${eventName} handler:`, updates);
        let receivedData = await sendCustomCodeIframeMessage(threadId, {type:"event", eventName:eventName.toLowerCase(), data:{updates, eventData}});
        console.log(`@@@@@@@@@@@ Data received from custom code after ${eventName} handler:`, receivedData);
        if(receivedData) await updateDbWithNewDataFromCustomCode({threadId, receivedData, originalMessages});
        $.statusNotifier.innerHTML = "";
        hideEl($.statusNotifier);

        let currentThreadId = activeThreadId;
        if(threadId === currentThreadId) { // <-- since user may have switched threads
          await renderMessageFeed(threadId, {triggerBotReply});
        }
      }

      async function triggerStreamingMessageChunkCustomCodeEvent(threadId, chunkData) {
        let thread = await db.threads.get(threadId);
        let threadCharacter = await db.characters.get(thread.characterId);
        if(!threadCharacter.customCode) return;
        
        await sendCustomCodeIframeMessage(threadId, {type:"event", eventName:"streamingmessagechunk", data:chunkData});
      }

      // let alreadyCurrentlyUpdatingDbWithNewDataFromCustomCode = false;
      async function updateDbWithNewDataFromCustomCode({threadId, receivedData, originalMessages}) {

        // backwards-compat:
        if(receivedData.character?.avatarUrl) {
          if(!receivedData.character?.avatar?.url?.trim()) {
            if(!receivedData.character.avatar) receivedData.character.avatar = {};
            receivedData.character.avatar.url = receivedData.character.avatarUrl;
          }
          delete receivedData.character.avatarUrl;
        }

        let thread = await db.threads.get(threadId);
        let threadCharacter = await db.characters.get(thread.characterId);

        // THREAD MESSAGES:
        if(receivedData.thread?.messages) {
          // note that originalMessages will only be defined if this is part of the MessageHandler process - because in that case we actually sent the messages, whereas in the data polling updates, we didn't send anything
          // currentMessages and originalMessages can differ because e.g. a message could have been deleted by the user while the custom code was processing
          let currentMessages = await db.messages.where("threadId").equals(threadId).toArray();
          currentMessages.sort((a,b) => a.order - b.order);
          let outputMessageObjs = await messagesFromCustomCodeFormat({messages:receivedData.thread.messages, originalMessages: originalMessages ?? currentMessages, threadId});
          // console.log("@@@@@@@@@@@ Messages back in db format:", outputMessageObjs);

          // order the messages (from the db's perspective) according to how the custom code ordered the oc.thread.messages array
          let order = 0;
          for(let m of outputMessageObjs) {
            m.order = order++;
          }

          for(let m of outputMessageObjs) {
            if(typeof m.id !== "number") {
              delete m.id;
            }
          }

          // they may have duplicated an object, which means there'll be an id collision, so we remove all later duplicate ids
          let idsGotAlready = [];
          for(let m of outputMessageObjs) {
            if(idsGotAlready.includes(m.id)) {
              delete m.id;
            } else {
              idsGotAlready.push(m.id);
            }
          }

          // if they have added an id that's not an id that exists in currentMessages, we remove that message's id:
          let currentMessageIds = currentMessages.map(m => m.id);
          for(let m of outputMessageObjs) {
            if(typeof m.id === "number" && !currentMessageIds.includes(m.id)) {
              delete m.id;
            }
          } 

          // if messages have been deleted, then we need to set those m.messageIdsUsed to -1
          for(let m of outputMessageObjs) {
            m.messageIdsUsed = m.messageIdsUsed.map(referencedId => {
              if(currentMessageIds.includes(referencedId)) return referencedId;
              else return -1;
              // if(!originalOrCurrentMessageIds.includes(referencedId) && referencedId !== -1) {
              //   // this is fine (i.e. not an error) if we *don't* have originalMessages (i.e. if we're relying on a fresh db request right at this moment) because it's possible that e.g. the user deleted a message while the custom code was processing.
              //   // but if we *do* have originalMessages, then something is wrong - why would messageIdsUsed (which isn't exposed to custom code, to be clear) contain ids of messages that don't exist in the *original* messages that we sent to the custom code iframe?
              //   if(originalMessages) {
              //     throw new Error("messageIdsUsed should only contain ids of messages that exist in the original messages");
              //   } else {
              //     return -1;
              //   }
              // }
              // if(deletedMessageIds.includes(referencedId)) return -1;
              // else return referencedId;
            });
          }

          // note that messagesFromCustomCodeFormat re-numbers `message.order` so it matches the order of the oc.thread.messages array that was returned.

          // replace messages in the database with the new messages
          // we need to make sure that no other db.messages code runs between .delete and .bulkAdd, so we use a transaction that gets a read-write lock on the messages table.
          // otherwise e.g. another call to updateDbWithNewDataFromCustomCode could run between them, and that would cause `db.messages.where("threadId").equals(threadId).toArray()` to incorrectly return zero messages.
          await db.transaction('rw', db.messages, async (tx) => {
            let existingMessageIds = await tx.table("messages").where("threadId").equals(threadId).toArray().then(arr => arr.map(m => m.id));
            await safelyDeleteMessagesByIds(existingMessageIds, {tx});

            let ids = outputMessageObjs.filter(m => m.id !== undefined).map(m => m.id);
            if(new Set(ids).size !== ids.length) {
              throw new Error("Duplicate message ids after custom code processing. This is a bug.");
            }

            await tx.table("messages").bulkAdd(outputMessageObjs).catch(e => {
              console.error(e);
              alert("There was an error during custom code handling - updateDbWithNewDataFromCustomCode.\n\n"+e.stack);
            });
          });

          // let newMessages = await db.messages.where("threadId").equals(threadId).toArray();
          // debugger;
        }
        
        // OTHER THREAD STUFF:
        let threadListChanged = false;
        await db.transaction('rw', db.threads, async tx => {
          let thread = await tx.table("threads").get(threadId);
          let changed = false;
          if(receivedData.thread?.userCharacter) {
            applyObjectOverrides({object:thread.userCharacter, overrides:receivedData.thread.userCharacter});
            changed = true;
          }
          if(receivedData.thread?.systemCharacter) {
            applyObjectOverrides({object:thread.systemCharacter, overrides:receivedData.thread.systemCharacter});
            changed = true;
          }
          if(receivedData.thread?.character) {
            applyObjectOverrides({object:thread.character, overrides:receivedData.thread.character});
            changed = true;
          }
          if(receivedData.thread?.customData) {
            thread.customData = receivedData.thread.customData;
            changed = true;
          }
          if(receivedData.thread?.messageWrapperStyle) {
            thread.messageWrapperStyle = receivedData.thread.messageWrapperStyle;
            changed = true;
          }
          if(receivedData.thread?.name) {
            thread.name = receivedData.thread.name;
            threadListChanged = true;
            changed = true;
          }
          if(changed) {
            await tx.table("threads").put(thread);
          }
        });

        if(threadListChanged) {
          await renderThreadList();
        }


        // CHARACTER updates:
        let characterKeysChanged = Object.keys(receivedData.character);
        for(let key in characterPropertiesVisibleToCustomCode) {
          let k = characterPropertiesVisibleToCustomCode[key]; // since "public api" naming is different to db naming
          if(characterKeysChanged.includes(k)) {
            if(key === "customCode" && threadCharacter.customCode !== receivedData.character.customCode) {
              // custom code has changed, so we need to reload the iframe
              await createNewCustomCodeIframeForThread(threadId);
            }
            threadCharacter[key] = receivedData.character[k];
          }
        }
        await db.characters.put(threadCharacter);

      }


      $.sendButton.addEventListener("click", sendButtonClickHandler);

      async function doBotReplyInPlaceOfUser({characterToReplyWith, replyInstruction=null, signals=null, expectsReply=undefined, result={}}={}) {
        let threadCharacter = await db.characters.get(activeCharacterId);
        let threadId = activeThreadId;

        let messageObj = createMessageObj({threadId, message:"...", characterId:-1, instruction:replyInstruction});
        messageObj.name = characterToReplyWith.name;
        messageObj.avatar = structuredClone(characterToReplyWith.avatar);
        
        let messageEl = await addMessageToFeed(messageObj, {character:characterToReplyWith, skipReaderRendering:true});
        messageEl.querySelector(".messageText").innerHTML = createPaddedTypingIndicatorHtml();
        
        if(!signals) signals = {stop:false, wasDeleted:false};
        messageEl.querySelector(".info .deleteButton").addEventListener("click", async e => {
          e.preventDefault(); e.stopPropagation();
          signals.stop = true;
          signals.wasDeleted = true;
          messageEl.remove();
        }, {passive: false});

        let messages = await db.messages.where("threadId").equals(threadId).toArray();
        messages.sort((a,b) => a.order - b.order);

        $.statusNotifier.innerHTML = "<button style='font-size: 0.9rem; margin-top:1.5rem;'>üõë stop response</button>";
        $.statusNotifier.querySelector("button").addEventListener("click", async (e) => {
          e.preventDefault(); e.stopPropagation();
          signals.stop = true;
          if(!characterToReplyWith.streamingResponse || (characterToReplyWith.streamingResponse && streamingChunkCount === 0)) {
            messageEl.remove();
            signals.wasDeleted = true;
          }
          $.statusNotifier.innerHTML = "";
          hideEl($.statusNotifier);
        }, {passive: false});
        showEl($.statusNotifier);

        let streamingChunkCount = 0;
        function onStreamingReplyChunk(c) {
          handleStreamingReplyChunk(c, messageEl);
          streamingChunkCount++;
        }
        
        const onProgressMessage = (e) => messageEl.querySelector(".statusMessage").innerHTML=e.message;
        let {message, memoryIdBatchesUsed, loreIdsUsed, summaryHashUsed, memoryQueriesUsed, messageIdsUsed} = await getBotReply({messages, replyingCharacter:characterToReplyWith, replyInstruction, threadId, onProgressMessage, onStreamingReplyChunk, signals}).catch(e => {
          if(e.name !== "AbortError") {
            alert("There was an error during doBotReplyInPlaceOfUser:\n\n"+e.stack);
          }
          messageEl.remove();
          return {};
        });
        messageEl.querySelector(".statusMessage").innerHTML = "";

        hideEl($.statusNotifier);
        $.statusNotifier.innerHTML = "";

        if(signals.wasDeleted || message === undefined) {
          return;
        }

        messageObj.memoryIdBatchesUsed = memoryIdBatchesUsed;
        messageObj.loreIdsUsed = loreIdsUsed;
        messageObj.summaryHashUsed = summaryHashUsed;
        messageObj.memoryQueriesUsed = memoryQueriesUsed;
        messageObj.messageIdsUsed = messageIdsUsed;

        messageObj.expectsReply = expectsReply;

        // if `message` is falsy, it means the bot failed to reply, so delete the message
        if(typeof message !== "string") {
          messageEl.remove();
          return false;
        } else {
          messageObj.message = message;
          result.message = message;

          messageObj.id = await addMessageToDb(messageObj);

          let shouldScrollDown = messageFeedIsNearBottom();
          await addMessageToFeed(messageObj, {character:characterToReplyWith, inPlaceOf:messageEl});
          if(shouldScrollDown) $.messageFeed.scrollTop = $.messageFeed.scrollHeight;

          await incrementOperationsSinceLastExport();
          await triggerMessageActionCustomCodeEvent({threadId, eventData:{}, eventName:"MessageAdded"});
        }
        return true;
      }

      $.threadOptionsButton.addEventListener("click", async function() {
        showEl($.threadOptionsPopup);
      }, {passive: true});

      // if user clicks anywhere other than $.threadOptionsPopup, hide it:
      window.addEventListener("click", function(e) {
        if(!$.threadOptionsPopup.contains(e.target) && !$.threadOptionsButton.contains(e.target)) {
          hideEl($.threadOptionsPopup);
        }
      }, {passive: true});

      $.addShortcutButton.addEventListener("click", async function() {
        let shortcut = await prompt2({
          intro: {html: `<div style="font-size: 0.85rem;margin-bottom: 0.5rem;">Shortcuts are buttons that appear above the text box which can be used to easily/quickly send a commonly-used message.</div>`, type:"none"},
          name: {label: "Shortcut name:", type: "textLine", placeholder:"user reply"},
          message: {label: "Message text:", type: "text", height:"fit-content", minHeight:"2rem", placeholder:"/user write an intersting first-person reply"},
          insertionType: {label: "Insertion type:", type: "select", options:[{content:"Replace existing text", value:"replace"}, {content: "Add to ùó≤ùóªùó± of existing text", value:"append"}, {content: "Add to ùòÄùòÅùóÆùóøùòÅ of existing text", value:"prepend"}]},
          autoSend: {label: "Auto-send?", type: "select", options:[{content:"Yes, send on click", value:"yes"}, {content: "No, just put it in the text box", value:"no"}]},
        });
        if(!shortcut) return;
        shortcut.autoSend = (shortcut.autoSend === "yes");
        shortcut.type = "message";
        let thread = await db.threads.get(activeThreadId);
        thread.shortcutButtons.push(shortcut);
        await db.threads.update(thread.id, {shortcutButtons: thread.shortcutButtons});
        await renderShortcutButtons(thread);
      }, {passive: true});

      // $.replyLoopButton.addEventListener("click", async function() {
        
      // });

      // let alreadyAutoReplying = false;
      // $.replyWithButton.addEventListener("click", async function() {
      //   if(alreadyAutoReplying) {
      //     return;
      //   }
      //   alreadyAutoReplying = true;
      //   $.sendButton.disabled = true;
      //   $.replyWithButton.disabled = true;

      //   let threadId = activeThreadId;

      //   let availableVoiceNames = speechSynthesis.getVoices().map(v => v.name).sort((a,b) => a.toLowerCase().includes("english") ? -1 : 1);

      //   // get list of characters, sorting by lastMessageTime
      //   const characters = await db.characters.orderBy("lastMessageTime").reverse().toArray();
      //   const promptResult = await prompt2({
      //     characterId: {label: "Choose a character to reply with:", type: "select", options:characters.map(c => ({content:`${c.name} #${c.id}`, value:c.id}))},
      //     repeat: {label: "How many replies?", type: "textLine", defaultValue: "10"},
      //     textToSpeechVoicesEnabled: {label: "Text-to-Speech Voices?", type: "select", options: [{content: "Disabled", value: "disabled"}, {content: "Enabled", value: "enabled"}]},
      //     threadCharVoiceName: {show:d=>d.textToSpeechVoicesEnabled==="enabled", label: "Existing chatacter voice:", type: "select", options:availableVoiceNames.map(v => ({content: v, value: v})) },
      //     otherCharVoiceName: {show:d=>d.textToSpeechVoicesEnabled==="enabled", label: "Reply-with character voice:", type: "select", options:availableVoiceNames.map(v => ({content: v, value: v})) },
      //   });
      //   if(!promptResult) {
      //     alreadyAutoReplying = false;
      //     $.replyWithButton.disabled = false;
      //     $.sendButton.disabled = false;
      //     return;
      //   }
      
      //   let ttsEnabled = promptResult.textToSpeechVoicesEnabled === "enabled";
      //   let threadCharVoiceName = promptResult.threadCharVoiceName;
      //   let otherCharVoiceName = promptResult.otherCharVoiceName;

      //   let characterToReplyWith = await db.characters.get(parseInt(promptResult.characterId));
      //   let repeat = parseInt(promptResult.repeat);
      //   let i = 0;
      //   let signals, result;
      //   while(i < repeat) {
      //     signals = {stop:false, wasDeleted:false};
      //     result = {};
      //     let success = await doBotReplyInPlaceOfUser({characterToReplyWith, signals, result});
      //     if(!success) break;

      //     if(signals.stop) {
      //       break;
      //     }

      //     if(threadId !== activeThreadId) {
      //       break; // if the user clicked into a different thread, stop replying
      //     }

      //     if(ttsEnabled) {
      //       // chrome has a bug that occurs if you try to speak text that's too long
      //       // so we split message up into sentences and speak each one
      //       let sentences = result.message.match(/[^\.!\?]+[\.!\?]+/g)?.map(s => s.trim()) ?? [result.message];
      //       for(let sentence of sentences) {
      //         let result = await textToSpeech({text: sentence, voiceName: otherCharVoiceName}).catch(e => {
      //           console.error(e);
      //           alert("There was an error with speech synthesis. You may need to close this tab and re-open it (not just refresh) if you're using Chrome due to a weird bug that sometimes causes this.\n\n"+e.toString());
      //           return false;
      //         });
      //         if(result === false) break;
      //       }
      //     }

      //     await delay(100);

      //     signals = {stop:false, wasDeleted:false};
      //     result = {};
      //     await doBotReplyIfNeeded({signals, result});

      //     if(signals.stop) {
      //       break;
      //     }

      //     if(ttsEnabled) {
      //       let sentences = result.message.match(/[^\.!\?]+[\.!\?]+/g)?.map(s => s.trim()) ?? [result.message];
      //       for(let sentence of sentences) {
      //         let result = await textToSpeech({text: sentence, voiceName: threadCharVoiceName}).catch(e => {
      //           console.error(e);
      //           alert("There was an error with speech synthesis. You may need to close this tab and re-open it (not just refresh) if you're using Chrome due to a weird bug that sometimes causes this.\n\n"+e.toString());
      //           return false;
      //         });
      //         if(result === false) break;
      //       }
      //     }

      //     // // wait for the other bot to respond
      //     // while(1) {
      //     //   await delay(100);
      //     //   let messages = await db.messages.where("threadId").equals(threadId).toArray();
      //     //   messages.sort((a,b) => a.order - b.order);
      //     //   // get characterId of this thread
      //     //   let thread = await db.threads.get(threadId);
      //     //   let thisThreadCharacterId = thread.characterId;
      //     //   let lastMessage = messages[messages.length-1];
      //     //   if(lastMessage.characterId === thisThreadCharacterId) {
      //     //     if(ttsEnabled) {
      //     //       let sentences = lastMessage.message.match(/[^\.!\?]+[\.!\?]+/g);
      //     //       for(let sentence of sentences) {
      //     //         let result = await textToSpeech({text: sentence, voiceName: threadCharVoiceName}).catch(e => {
      //     //           console.error(e);
      //     //           alert("There was an error with speech synthesis. You may need to close this tab and re-open it (not just refresh) if you're using Chrome due to a weird bug that sometimes causes this.\n\n"+e.toString());
      //     //           return false;
      //     //         });
      //     //         if(result === false) break;
      //     //       }
      //     //     }
      //     //     break;
      //     //   }
      //     // }

      //     i++;
      //   }
      //   alreadyAutoReplying = false;
      //   $.replyWithButton.disabled = false;
      //   $.sendButton.disabled = false;
      // });

      $.newThreadButton.addEventListener("click", async function() {
        document.querySelectorAll("#middleColumn > .middleColumnScreen").forEach(el => hideEl(el));
        showEl($.characterSelection);
        
        activeThreadId = null;
        if(threadLoadingModal) {
          threadLoadingModal.delete();
        }

        await updateCustomCodeIframeVisibility();
        // deselect selected thread
        document.querySelectorAll("#chatThreads .thread").forEach(el => el.classList.remove("selected"));
        await renderCharacterList();
        
        if(isMobile) {
          closeLeftColumn();
        } else {
          hideEl($.characterSelectionOpenLeftColumnButton);
        }
      }, {passive: true});


      $.threadSearchButton.addEventListener("click", async function() {
        let query = $.threadSearchInput.value.trim();
        if(query) {
          await renderThreadList({filterWithQuery: query});
        } else {
          // show all threads
          await renderThreadList();
        }
      }, {passive: true});
      $.threadSearchInput.addEventListener("keydown", async e => {
        if(e.key === "Enter") {
          $.threadSearchButton.click();
        }
      }, {passive: true});
      // if user deletes all text from the search input, show all threads
      $.threadSearchInput.addEventListener("input", async e => {
        if(!$.threadSearchInput.value.trim()) {
          await renderThreadList();
        }
      }, {passive: true});

      function resizeMessageInputTextAreaToFitContent() {
        $.messageInput.style.height = "";
        let height = Math.min(window.innerHeight*0.75, $.messageInput.scrollHeight);
        $.messageInput.style.height = height + "px";
      }

      // this executes on page load, so it should give us the full height.
      // note that if the user zooms on the page, it will change, so it's not full-proof for detecting e.g. on-screen keyboard, as we do below
      window.fullVisualViewportHeight = window.visualViewport.height;

      function isTouchDevice() {
        return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);
      }

      $.messageInput.addEventListener("keydown", async e => {
        if(isMobile) return; // on mobile, if enter/returns triggers send, then people can't add linebreaks
        if(isTouchDevice() && window.visualViewport.height < window.fullVisualViewportHeight*0.9) return; // likely indicates that onscreen keyboard is open, so we want to allow them to create a new line with 'enter' (shift+enter on a touch-screen keyboard is not ergonomic/possible)

        if(e.key === "Enter") {
          if(e.shiftKey) {
            // if shift is held, wait a moment (so the text area can have the new line added), then increase the height of the text area to match the full height of the content
            await delay(10);
            resizeMessageInputTextAreaToFitContent();
          } else {
            e.preventDefault();
            $.sendButton.click();
          }
        }
      }, {passive: false});
      // if user pastes text into the message input, increase the height of the text area to match the full height of the content
      $.messageInput.addEventListener("paste", async e => {
        await delay(10);
        resizeMessageInputTextAreaToFitContent();
      }, {passive: true});

      $.messageInput.addEventListener("input", async e => {
        if($.messageInput.value.length % 10 === 0) {
          await delay(10);
          resizeMessageInputTextAreaToFitContent();
        }
      }, {passive: true});

      $.clearDataButton.addEventListener("click", async function() {
        if(!confirm("üö® Are you sure you want to DELETE ALL DATA? This cannot be undone. üö®")) {
          return;
        }
        await delay(1000);
        if(!confirm("üö® Click OK again to confirm FULL DELETION of all your data. üö®")) {
          return;
        }
        await db.delete();
        window.location.reload();
      }, {passive: false});

      // User messages sent history:
      {
        let lastTapTime = 0;
        let lastClickTime = 0;

        $.messageInput.addEventListener('touchstart', handleDoubleTap, {passive: true});
//      $.messageInput.addEventListener('click', handleSingleClick, {passive: false});
        $.messageInput.addEventListener('dblclick', handleDoubleClick, {passive: false});

        function handleDoubleTap(e) {
          // Caution: Do not use e.preventDefault in handleDoubleTap, at least not without removing the 'passive' parameter from addEventListener above
          let currentTime = new Date().getTime();
          let tapInterval = currentTime - lastTapTime;
          
          if (tapInterval < 300 && tapInterval > 0) {
            onDoubleTapOrClick();
          }
          lastTapTime = currentTime;
        }

        // This cannot be used from passive event listeners
        function handleSingleClick(e) {
          e.preventDefault();
          let currentTime = new Date().getTime();
          let clickInterval = currentTime - lastClickTime;
          
          if (clickInterval < 300 && clickInterval > 0) {
            onDoubleTapOrClick();
          }
          lastClickTime = currentTime;
        }

        // This cannot be used from passive event listeners
        function handleDoubleClick(e) {
          e.preventDefault();
          onDoubleTapOrClick();
        }

        async function onDoubleTapOrClick() {
          console.log('Double-tap/double-click on message input textarea detected');
          let threadId = activeThreadId;
          let thread = await db.threads.get(threadId);
          if(thread.userMessagesSentHistory.length === 0) return;
          // sort so isPinned items are at the end:
          thread.userMessagesSentHistory.sort((a, b) => {
            if(a.isPinned && !b.isPinned) return 1;
            if(!a.isPinned && b.isPinned) return -1;
            return 0;
          });
          // create the history messages element:
          let ctn = document.createElement("div");
          ctn.innerHTML = thread.userMessagesSentHistory.map(m => `<div class="historyItem" data-is-pinned="${m.isPinned}" data-message-text="${encodeURIComponent(m.text)}"><span class="pinButton">üìå</span><span class="text">${m.text.slice(0, 500).replaceAll("\n", " ")}</span><span class="deleteButton">üóëÔ∏è</span></div>`).join("");
          // position it above the message input text area, with same width:
          ctn.style.cssText = `
            max-height: min(40vh, 200px);
            overflow: auto;
            background: var(--textarea-bg);
            border: 1px solid var(--button-border-color);
            border-radius: var(--border-radius);
            padding: 5px;
            position: absolute;
            bottom: 0;
            width: 100%;
          `;

          // if user clicks the pin button, toggle the fav status of the message and save the userMessagesSentHistory
          ctn.querySelectorAll(".historyItem .pinButton").forEach(el => {
            el.addEventListener("click", async function(e) {
              e.stopPropagation();
              let messageText = decodeURIComponent(el.parentElement.dataset.messageText);
              let message = thread.userMessagesSentHistory.find(m => m.text === messageText);
              message.isPinned = !message.isPinned;
              await db.threads.update(threadId, {userMessagesSentHistory:thread.userMessagesSentHistory});
              el.closest(".historyItem").dataset.isPinned = message.isPinned;
            }, {passive: true});
          });

          ctn.querySelectorAll(".historyItem .deleteButton").forEach(el => {
            el.addEventListener("click", async function(e) {
              e.stopPropagation();
              let messageText = decodeURIComponent(el.parentElement.dataset.messageText);
              let message = thread.userMessagesSentHistory.find(m => m.text === messageText);
              thread.userMessagesSentHistory.splice(thread.userMessagesSentHistory.indexOf(message), 1);
              await db.threads.update(threadId, {userMessagesSentHistory:thread.userMessagesSentHistory});
              el.closest(".historyItem").remove();
            }, {passive: true});
          });

          // add it to the DOM:
          $.userMessagesSentHistoryCtn.appendChild(ctn);
          // when the user clicks anywhere else, remove it from the DOM:
          function clickAnywhereElseHandler(e) {
            if(e.target === ctn || ctn.contains(e.target)) return;
            window.removeEventListener("click", clickAnywhereElseHandler);
            ctn.remove();
          }
          window.addEventListener("click", clickAnywhereElseHandler, {passive: true});
          // when user clicks a message, add it to the message input text area:
          ctn.querySelectorAll(".historyItem").forEach(el => {
            el.addEventListener("click", function() {
              $.messageInput.value = decodeURIComponent(el.dataset.messageText);
              $.messageInput.focus();
              window.removeEventListener("click", clickAnywhereElseHandler);
              ctn.remove();
            }, {passive: true});
          });

          // scroll to bottom of ctn:
          ctn.scrollTop = ctn.scrollHeight;
        }
      }


      // $.statsButton.addEventListener("click", async function() {
      //   let entries = await db.usageStats.toArray();
      //   let dayToSpendMap = {};
      //   for(let entry of entries) {
      //     entry.daysSinceEpoch = Math.floor(entry.dateHour / (1000 * 60 * 60 * 24));
      //   }
      //   let spent = usageStatsEntriesToCost(entries);

      //   await prompt2({
      //     chart: {html: "", type: "none"}
      //   });

      //   let Chart = await import('https://cdn.jsdelivr.net/npm/chart.js@4.2.1/+esm').then(m => m.default);
      //   const chart = new Chart(ctx, {
      //     type: 'line',
      //     data: {
      //       datasets: [{
      //         data: entries.map(),
      //       }],
      //     },
      //     options: {
      //       scales: {
      //         x: {
      //           type: 'time',
      //           time: {
      //             unit: 'day'
      //           }
      //         }
      //       }
      //     }
      //   });
      // });


      $.settingsButton.addEventListener("click", async function() {
        // use prompt2 to collect user's name and avatar, using defaults from db.misc
        let userNameOriginal = (await db.misc.get("userName"))?.value || defaultUserName;
        let userAvatarUrlOriginal = (await db.misc.get("userAvatarUrl"))?.value || "";
        let openAiApiKeyOriginal = (await db.misc.get("openAiApiKey"))?.value || "";
        let messagesPerRenderingBatchOriginal = (await db.misc.get("messagesPerRenderingBatch"))?.value || 50;
        let customModelConfigsOriginal = (await db.misc.get("customModelConfigs"))?.value || [];
        let showInlineReminderOriginal = (await db.misc.get("showInlineReminder"))?.value || "yes";
        let useCORSProxyOriginal = (await db.misc.get("useCORSProxy"))?.value || "yes";
        let showDebugInfoOriginal = (await db.misc.get("showDebugInfo"))?.value || "none";
        let customPostPageLoadMainThreadCodeOriginal = (await db.misc.get("customPostPageLoadMainThreadCode"))?.value || "";
        const result = await prompt2({
          userName: {label: "Your name:", type: "textLine", defaultValue: userNameOriginal},
          userAvatarUrl: {label: "Your avatar URL:", type: "textLine", placeholder: "(optional)", defaultValue: userAvatarUrlOriginal},
          openAiApiKey: {label: "OpenAI API secret key (<a href='https://platform.openai.com/account/api-keys' target='_blank'>from here</a>):", type: "textLine", placeholder:"sk-...", defaultValue: openAiApiKeyOriginal},
          messagesPerRenderingBatch: {label: "Chat messages to render at a time", infoTooltip:"Controls how many messages are rendered at a time when loading and scrolling through a thread. For example: If this is set to 50, then when you load a long thread, the most recent 50 messages in the thread will be displayed. If you scroll upward to the top of those 50 messages, the previous 50 messages will be loaded and displayed; and so on. Increasing this value can make scrolling a bit smoother, but can make page loads take longer.", type: "select", options: [{value:50}, {value:100}, {value:150}, {value:200}, {value:250}], defaultValue:messagesPerRenderingBatchOriginal },
          showInlineReminder: {hidden:true, label: "Show 'inline' reminder edit button:", type: "select", options:[{value:"yes"}, {value:"no"}], defaultValue: showInlineReminderOriginal},
          customModelConfigs: {hidden:true, cssText:"white-space:pre; font-family:monospace;", label: `Custom model configs (<a href='${projectDocsURL}/custom-models.md' target='_blank'>follow this guide</a>):`, type: "text", placeholder:`{name:"...", endpointUrl:"..."}\n{name:"...", endpointUrl:"...", apiKey:"..."}\n...`, defaultValue: customModelConfigsOriginal.map(o => JSON5.stringify(o)).join("\n")},
          useCORSProxy: {hidden:true, label:"Use CORS proxy when downloading lore", type: "select", options:[{value:"yes"}, {value:"no"}], defaultValue: useCORSProxyOriginal},
          customPostPageLoadMainThreadCode: {hidden:true, height:"fit-content", cssText:"white-space:pre; font-family:monospace;", label: "This code will be run on this page after page load. You can use it to mod the OpenCharacters UI, or to e.g. <a href='https://gist.github.com/josephrocca/a82216e2f2fdf54ad8dd79dbd4cfd625' target='_blank'>proxy all `fetch` requests</a>, or whatever. Note that there are no backwards-compatibility guarantees on the main thread UI, so your code may break eventually. <b>This code can access all your data</b> - make sure it's from a trustworthy source if you didn't write it yourself (maybe ask GPT-4 what it does if you don't know how to code and are weary). Refresh the page after saving for your code to take effect.", placeholder:"// add code here", type: "text", defaultValue: customPostPageLoadMainThreadCodeOriginal},
          showDebugInfo: {hidden:true, label:"Show debugging controls", type: "select", options:[{value:"verbose"}, {value: "brief"}, {value:"none"}], defaultValue: showDebugInfoOriginal},
        }, {showHiddenInputsText: "show advanced settings"});
        if(!result) return;
        let { userName, userAvatarUrl, openAiApiKey, messagesPerRenderingBatch, customModelConfigs, useCORSProxy, customPostPageLoadMainThreadCode, showDebugInfo } = result;

        customModelConfigs = customModelConfigs.split("\n").map(s => s.trim()).filter(s => s).map(s => JSON5.parse(s));
        for(let config of customModelConfigs) {
          config.endpointUrl = config.endpointUrl.trim();
          config.name = config.name.trim();
          if(!config.modelUrl) {
            config.modelUrl = `https://huggingface.co/${config.name}`;
          }
          config.modelUrl = config.modelUrl.trim().replace(/\/$/, ""); // remove trailing slash
          if(!config.name || !config.endpointUrl) {
            alert("Invalid custom model config. Must include at least name and endpointUrl:\n\n" + JSON5.stringify(config));
          }
          if(!config.type) {
            if(/v1\/completions\/?/.test(config.endpointUrl)) {
              config.type = "completion";
            } else if(/v1\/chat\/completions\/?/.test(config.endpointUrl)) {
              config.type = "chat-completion";
            } else {
              alert("Warning: If endpointUrl doesn't end with v1/completions or v1/chat/completions, then you need to specify a 'type' parameter that is either 'completion' or 'chat-completion'. You should choose 'chat-completion' if the model accepts the 'messages' parameter, or choose 'completion' if it accepts the 'prompt' parameter. The model has been assumed to be a 'completion' model. Here's the config line causing this warning:\n\n" + JSON5.stringify(config));
              config.type = "completion";
            }
          }
          if(!config.maxSequenceLength) {
            let modelConfigJson;
            modelConfigJson = await fetch(config.modelUrl+"/raw/main/config.json").then(r => r.json()).catch(e => null);
            if(modelConfigJson) {
              config.maxSequenceLength = modelConfigJson.ctx_len || modelConfigJson.max_position_embeddings || modelConfigJson.n_positions || modelConfigJson.max_position_embeddings || modelConfigJson.max_sequence_length;
            }
            if(!config.maxSequenceLength) {
              alert("Warning: maxSequenceLength was not provided, and could not be loaded from Hugging Face. It has been assumed to be 4096. Here's the config line causing this warning:" + JSON5.stringify(config));
              config.maxSequenceLength = 4096;
            }
          }
          if(!config.tokenPricing) {
            config.tokenPricing = {prompt:0, completion:0};
          }
          if(!config.apiKey && config.endpointUrl.startsWith("https://api.openai.com")) {
            config.apiKey = "<OPENAI>";
          }
        }

        let showInlineReminder = result.showInlineReminder;
        await incrementOperationsSinceLastExport();

        // save to db
        await db.misc.put({key: "userName", value: userName});
        await db.misc.put({key: "userAvatarUrl", value: userAvatarUrl});
        await db.misc.put({key: "openAiApiKey", value: openAiApiKey});
        await db.misc.put({key: "messagesPerRenderingBatch", value: messagesPerRenderingBatch});
        await db.misc.put({key: "customModelConfigs", value: customModelConfigs});
        await db.misc.put({key: "showInlineReminder", value: showInlineReminder});
        await db.misc.put({key: "useCORSProxy", value: useCORSProxy});
        await db.misc.put({key: "customPostPageLoadMainThreadCode", value: customPostPageLoadMainThreadCode});
        await db.misc.put({key: "showDebugInfo", value: showDebugInfo});        
        await updateModelList();

        // update the user's name and avatar in the message feed:
        if($.messageFeed.offsetHeight > 0) {
          const forceFullRender = (showDebugInfo != showDebugInfoOriginal);
          let threadId = activeThreadId;
          await renderMessageFeed(threadId, {forceFullRender:forceFullRender});
        }
      }, {passive: true});

      async function getCharacterHash(characterObj) {
        let char = structuredClone(characterObj);
        delete char.id;
        delete char.creationTime;
        delete char.lastMessageTime;
        delete char.uuid;
        delete char.folderPath;
        for(let key in char) {
          if(key.startsWith("$")) { // special `dexie-export-import` properties start with `$` (only exists in exported json data)
            delete char[key];
          }
        } 
        let entries = Object.entries(char);
        entries.sort((a,b) => a[0].localeCompare(b[0]));
        let hash = await sha256Text(JSON.stringify(entries));
        return hash;
      }

      // import data if they click import button
      $.importDataFileInput.addEventListener("change", async function() {

        let options = await prompt2({
          keepExistingData: {label: "Keep existing data?", type: "select", options:[{value:"yes", content:"Yes, keep."}, {value:"no", content:"No, DELETE existing data."}], defaultValue: "yes"},
        }, {submitButtonText:"import data"});

        if(!options) {
          $.importDataFileInput.value = "";
          return;
        }

        // warn about overwrite:
        if(options.keepExistingData === "no" && !confirm("Are you sure you want to DELETE all of your existing data? You should create an export of your data first! This cannot be undone.")) {
          $.importDataFileInput.value = "";
          return;
        }

        let file = $.importDataFileInput.files[0];

        $.importDataFileInput.value = "";

        let loadingModal = createLoadingModal(`Importing data...<br><span style="font-size:80%; opacity:0.6;">This could take a while if the file is large.</span>`);
        await delay(50); // give the loading modal a chance to render

        let success = false;
        try {
          if(await tryImportingDexieFile(file, options).catch(e => "fail") === "finished") {
            success = true;
          } else if(await tryImportingTavernAIThreadFile(file, options).catch(e => "fail") === "finished") {
            success = true;
          } else if(await tryImportingExternalCharacterFileFormat(file, options).catch(e => "fail") === "finished") {
            success = true;
          }
        } catch(e) {}

        loadingModal.delete();

        if (success) {
          await resetOperationsSinceLastExport();
        } else {
          alert("The file that you're importing doesn't seem to be a valid format, or something went wrong during import. If you think your file is valid, please report this as a bug on Github or Discord.");
        }

        await updateModelList();

      }, {passive: true});

      async function tryImportingDexieFile(file, options) {
        // backup existing data just in cast this wrecks the db for some reason (used in catch block below):
        const originalDbJsonBlob = await db.export({prettyJson:true, numRowsPerChunk:100});

        let singleThreadImportId = null;

        try {

          try {
            let json = JSON.parse(await new Blob([file]).text());
            if(!json.formatName && json.type === "application/json" && json.uri?.startsWith("file:///")) {
              alert("The file you provided is invalid. It's likely you tried to upload it to Discord, or something like that, and instead of actually uploading the file itself, Discord uploaded a *reference* to the file. I'm not sure why Discord does this, but you might want to try a different method of transferring the file. To check if your file is valid, you can open it up with a text editor and check that it starts with: {\"formatName\":\"dexie\", ...");
              return "finished";
            }
          } catch(e) {
            return "fail";
          }

          if(options.keepExistingData === "no") {
            await db.delete();
            await db.open();
            // db = await Dexie.import(file); // this wasn't doing a version upgrade, and I'm not sure how to trigger it, so I'm just using the code below which was written for partial imports (but also works for full imports), and does the version upgrade manually
          }

          let json = await new Response(new Blob([file])).json(); // a hack to go straight from blob to json to avoid maximum string length errors
          // let json = JSON.parse(await new Blob([file]).text());

          if(!json.data || !json.data.data) return "fail";

          // TODO: I should probably convert IDs to UUIDs so I don't need to do this sort of thing, but this is fine for now. Note: If you do this, you need to update the export modal because it currently uses comma-separated IDs
          
          // we need to re-number all ids in the imported data to be higher than the current max ids.

          // get current maximum id for each table
          let maxThreadId = (await db.threads.orderBy("id").last())?.id ?? -1;
          let maxMessageId = (await db.messages.orderBy("id").last())?.id ?? -1;
          let maxCharacterId = (await db.characters.orderBy("id").last())?.id ?? -1;
          let maxMemoryId = (await db.memories.orderBy("id").last())?.id ?? -1;
          let maxLoreId = (await db.lore.orderBy("id").last())?.id ?? -1;
          let maxLoreBookId = (await db.lore.orderBy("bookId").last())?.bookId ?? -1;
          // note: summaries don't have an id (we index by hash), so we don't need to re-number their ids (but note that we do need to renumber their thread ids to match the new thread ids)

          let importedCharacters = json.data.data.find(d => d.tableName === "characters").rows;
          let importedThreads = json.data.data.find(d => d.tableName === "threads").rows;
          let importedMessages = json.data.data.find(d => d.tableName === "messages").rows;
          let importedSummaries = json.data.data.find(d => d.tableName === "summaries")?.rows;
          let importedUsageStats = json.data.data.find(d => d.tableName === "usageStats")?.rows;
          let importedMemories = json.data.data.find(d => d.tableName === "memories")?.rows;
          let importedLore = json.data.data.find(d => d.tableName === "lore")?.rows;
          let importedTextCompressionCacheEntries = json.data.data.find(d => d.tableName === "textCompressionCache")?.rows;
          
          const existingCharacters = await db.characters.toArray();

          // hash existing characters, and new characters, so we can map ids of new characters to ones that may already exist
          let existingCharacterHashToId = {};
          let newCharacterIdToHash = {};
          for(let character of existingCharacters) {
            let hash = await getCharacterHash(character);
            existingCharacterHashToId[hash] = character.id;
          }
          for(let character of importedCharacters) {
            let hash = await getCharacterHash(character);
            newCharacterIdToHash[character.id] = hash;
          }

          // old id -> new id maps
          let characterIdMap = {};
          let threadIdMap = {};
          let messageIdMap = {};
          let summaryIdMap = {};
          let memoryIdMap = {};
          let loreIdMap = {};
          let loreBookIdMap = {};

          let charactersThatWeAlreadyHave = [];

          // re-number character ids
          for(let character of importedCharacters) {
            let existingCharacterId = existingCharacterHashToId[newCharacterIdToHash[character.id]];
            if(existingCharacterId !== undefined) {
              characterIdMap[character.id] = existingCharacterId;
              charactersThatWeAlreadyHave.push(character);
              continue;
            }
            // no existing character with this hash, so we need to create a new entry:
            maxCharacterId++;
            characterIdMap[character.id] = maxCharacterId;
            character.id = maxCharacterId;
          }

          // remove all the `charactersThatWeAlreadyHave` characters from the `importedCharacters`, since we don't need to import them:
          importedCharacters = importedCharacters.filter(c => !charactersThatWeAlreadyHave.includes(c));

          // re-number thread ids
          for(let thread of importedThreads) {
            maxThreadId++;
            threadIdMap[thread.id] = maxThreadId;
            thread.id = maxThreadId;
            // re-number character id of each thread
            thread.characterId = characterIdMap[thread.characterId];
          }

          if(importedLore) {
            // re-number lore ids
            for(let entry of importedLore) {
              maxLoreId++;
              loreIdMap[entry.id] = maxLoreId;
              entry.id = maxLoreId;
            }
            for(let message of importedMessages) {
              message.loreIdsUsed = message.loreIdsUsed.map(id => loreIdMap[id]);
            }

            // re-number lore bookIds
            for(let thread of importedThreads) {
              if(loreBookIdMap[thread.loreBookId] === undefined) {
                maxLoreBookId++;
                loreBookIdMap[thread.loreBookId] = maxLoreBookId;
              }
              thread.loreBookId = loreBookIdMap[thread.loreBookId];
            }
            for(let entry of importedLore) {
              if(typeof entry.bookId == "number") { // <-- bookId is null for bookUrl-based entries
                entry.bookId = loreBookIdMap[entry.bookId];
              }
            }
          }

          let importedThreadIdToCharacterId = {};
          for(let thread of importedThreads) {
            importedThreadIdToCharacterId[thread.id] = thread.characterId;
          }

          // re-number message ids
          for(let message of importedMessages) {
            maxMessageId++;
            messageIdMap[message.id] = maxMessageId;
            message.id = maxMessageId;
            // re-number thread id of each message
            message.threadId = threadIdMap[message.threadId];
            // re-number author/character id of each message
            if(message.characterId >= 0) { // remember, user messages have characterId = -1, and system messages have characterId = -2
              message.characterId = characterIdMap[message.characterId];
              if(message.characterId === undefined) { // this is possible due to an old bug in safelyDeleteCharacterById where I wasn't updating the characterId of messages in threads where the deleted character was included in a thread via `/ai @CharName#123` rather than actually being the main character of the thread.
                message.characterId = importedThreadIdToCharacterId[message.threadId]; // just set the ID to the characterId of the thread's main character
              }
            }
          }

          // re-number memory ids
          if(importedMemories) {
            for(let memory of importedMemories) {
              maxMemoryId++;
              memoryIdMap[memory.id] = maxMemoryId;
              memory.id = maxMemoryId;
            }
          }

          // re-number message.memoryIdBatchesUsed
          for(let message of importedMessages) {
            if(message.memoryIdBatchesUsed) { // <-- old exports won't have this
              message.memoryIdBatchesUsed = message.memoryIdBatchesUsed.map(b => b.map(id => memoryIdMap[id]));
            }
          }
          // (note: we don't need to do the same as above for summaryHashUsed since it obviously uses a hash instead of an id)

          // re-number message.messageIdsUsed
          for(let message of importedMessages) {
            if(message.messageIdsUsed) { // <-- old exports won't have this
              message.messageIdsUsed = message.messageIdsUsed.map(id => id === -1 ? -1 : messageIdMap[id]);
            }
          }

          if(importedSummaries) {
            // delete summaries that don't have messageIds (from an old version of the app)
            importedSummaries = importedSummaries.filter(s => s.messageIds !== undefined);

            // convert old summary thread/message ids to new ones
            for(let summary of importedSummaries) {
              summary.threadId = threadIdMap[summary.threadId];
              summary.messageIds = summary.messageIds.map(id => messageIdMap[id]);
            }

            // get existing summary hashes from db
            let existingSummaryHashes = new Set((await db.summaries.toArray()).map(s => s.hash));
            // remove summaries we already have
            importedSummaries = importedSummaries.filter(s => !existingSummaryHashes.has(s.hash));
          }

          if(importedUsageStats) {
            // convert old usageStats thread and character ids to new ones
            for(let entry of importedUsageStats) {
              entry.threadId = threadIdMap[entry.threadId];
              entry.characterId = characterIdMap[entry.characterId];
            }
          }

          if(importedMemories) {
            for(let memory of importedMemories) {
              memory.threadId = threadIdMap[memory.threadId];
              memory.characterId = characterIdMap[memory.characterId];
            }
          }

          if(importedTextCompressionCacheEntries) {
            
            let existingEntries = await db.textCompressionCache.toArray();
            let alreadyGotEntryKeys = new Set(existingEntries.map(entry => entry.uncompressedTextHash + "-<<-|->>-" + entry.modelName + "-<<-|->>-" + entry.tokenLimit));

            for(let entry of importedTextCompressionCacheEntries) {
              entry.threadId = threadIdMap[entry.threadId];
              let uniqueKey = entry.uncompressedTextHash + "-<<-|->>-" + entry.modelName + "-<<-|->>-" + entry.tokenLimit;
              if(alreadyGotEntryKeys.has(uniqueKey)) {
                entry.__shouldRemove = true;
              } else {
                alreadyGotEntryKeys.add(uniqueKey);
              }
            }
            importedTextCompressionCacheEntries = importedTextCompressionCacheEntries.filter(entry => !entry.__shouldRemove);
          }

          // if there's just one thread, then we assume it was from a single-thread export
          // and in that case we probably don't want isFav to persist, and we also probably
          // want that thread to be at the top - i.e. lastMessageTime = now
          if(importedThreads.length === 1) {
            importedThreads[0].isFav = false;
            importedThreads[0].lastViewTime = Date.now();
            importedThreads[0].lastMessageTime = Date.now();
            singleThreadImportId = importedThreads[0].id;
          }


          // UPGRADES:
          // TODO: shouldn't dexie's .upgrade function handle this? doesn't seem to be doing it. check again - I could be wrong.
          for(let character of importedCharacters) {
            upgradeCharacterFromOldVersion(character);
          }
          let allCharacters = [...existingCharacters, ...importedCharacters];
          for(let thread of importedThreads) {
            await upgradeThreadFromOldVersion(thread, {characters:allCharacters});
          }
          for(let message of importedMessages) {
            upgradeMessageFromOldVersion(message);
          }
          if(importedUsageStats) {
            importedUsageStats = importedUsageStats.filter(entry => entry.threadId !== undefined);
          }
          if(importedSummaries) {
            importedSummaries = importedSummaries.filter(entry => entry.messageIds !== undefined);
          }
          let loreEntriesToAddAfterImport = [];
          if(importedMemories) {
            let userWrittenMemories = importedMemories.filter(m => m.type === "user-written");
            if(userWrittenMemories.length > 0) {
              for(let m of userWrittenMemories) {
                if(importedLore) {
                  maxLoreId++;
                  importedLore.push({ id:maxLoreId, bookId:m.threadId, text:m.text, embedding:m.embedding, triggers:[] });
                } else {
                  loreEntriesToAddAfterImport.push({ bookId:m.threadId, text:m.text, embedding:m.embedding, triggers:[] });
                }
              }
              importedMemories = importedMemories.filter(m => m.type !== "user-written");
            }

            let memoryIdToIndexMap = createMemoryIdToIndexMapForIncorrectlyIndexedOrUnindexedMemories(importedMemories);
            for(let memory of importedMemories) {
              let opts = {};
              if(memoryIdToIndexMap[memory.id] !== undefined) opts.index = memoryIdToIndexMap[memory.id];
              upgradeMemoryFromOldVersion(memory, opts);
            }
          }
          if(importedLore) {
            for(let entry of importedLore) {
              upgradeLoreFromOldVersion(entry);
            }
          }
          for(let entry of loreEntriesToAddAfterImport) {
            upgradeLoreFromOldVersion(entry);
          }

          if(json.data.data.find(d => d.tableName === "textEmbeddingCache")) {
            let existingEntries = await db.textEmbeddingCache.toArray();
            let entries = json.data.data.find(d => d.tableName === "textEmbeddingCache").rows;
            for(let e of entries) {
              delete e.id;
            }
            // remove duplicate embeddings (duplicates were possible in older versions of the app, but are now disallowed)
            let seen = new Set(existingEntries.map(entry => entry.textHash + "-<<-|->>-" + entry.modelName));
            entries = entries.filter(entry => {
              let key = entry.textHash + "-<<-|->>-" + entry.modelName;
              if(seen.has(key)) return false;
              seen.add(key);
              return true;
            });
            json.data.data.find(d => d.tableName === "textEmbeddingCache").rows = entries;
          }
          

          json.data.data.find(d => d.tableName === "characters").rows = importedCharacters;
          json.data.data.find(d => d.tableName === "threads").rows = importedThreads;
          json.data.data.find(d => d.tableName === "messages").rows = importedMessages;
          if(importedSummaries) {
            json.data.data.find(d => d.tableName === "summaries").rows = importedSummaries;
          }
          if(importedUsageStats) {
            json.data.data.find(d => d.tableName === "usageStats").rows = importedUsageStats;
          }
          if(importedMemories) {
            json.data.data.find(d => d.tableName === "memories").rows = importedMemories;
          }
          if(importedLore) {
            json.data.data.find(d => d.tableName === "lore").rows = importedLore;
          }
          if(importedTextCompressionCacheEntries) {
            json.data.data.find(d => d.tableName === "textCompressionCache").rows = importedTextCompressionCacheEntries;
          }

          // delete old apiUsage table/data
          json.data.data = json.data.data.filter(d => d.tableName !== "apiUsage");
          json.data.tables = json.data.tables.filter(d => d.name !== "apiUsage");

          // check which misc keys user already has, and remove them from the misc table that we're importing:
          let existingMiscKeys = (await db.misc.toArray()).map(m => m.key);
          let miscData = json.data.data.find(d => d.tableName === "misc");
          miscData.rows = miscData.rows.filter(m => !existingMiscKeys.includes(m.key));

          // convert json back to blob and import
          // let blob = new Blob([JSON.stringify(json)], {type: "application/json"});
          let blob = jsonToBlob(json);
          
          await db.import(blob, {acceptVersionDiff:true, acceptMissingTables:true});

          if(loreEntriesToAddAfterImport.length > 0) {
            await db.lore.bulkAdd(loreEntriesToAddAfterImport); // we add these after import because there was no 'lore' table in the original JSON
          }

          // instead of importing the whole textEmbeddingCache, we just import the ones that are currently attached to memories/lore, which helpfully cleans out any unused entries in the cache
          {
            let importedMemoriesAndLore = [...(importedLore || []), ...(importedMemories || [])];
            let importedMemoryAndLoreTextHashes = await Promise.all(importedMemoriesAndLore.map(entry => sha256Text(entry.text)));
            let textEmbeddingsToAddToCache = [];
            for(let i = 0; i < importedMemoriesAndLore.length; i++) {
              for(let modelName of Object.keys(importedMemoriesAndLore[i].embeddings)) {
                textEmbeddingsToAddToCache.push({
                  text: importedMemoriesAndLore[i].text,
                  textHash: importedMemoryAndLoreTextHashes[i],
                  modelName: modelName,
                  embedding: importedMemoriesAndLore[i].embeddings[modelName],
                });
              }
            }
            let alreadyGotEmbeddings = await db.textEmbeddingCache.toArray();
            let alreadyGotTextHashModelNamePairs = new Set(alreadyGotEmbeddings.map(e => `${e.textHash}-<<-|->>-${e.modelName}`));
            
            textEmbeddingsToAddToCache = textEmbeddingsToAddToCache.filter(e => {
              let keep = !alreadyGotTextHashModelNamePairs.has(`${e.textHash}-<<-|->>-${e.modelName}`);
              alreadyGotTextHashModelNamePairs.add(`${e.textHash}-<<-|->>-${e.modelName}`);
              return keep;
            });
            await db.textEmbeddingCache.bulkAdd(textEmbeddingsToAddToCache).catch(e => {
              console.error("Something went wrong while adding text embeddings to cache. Not a critical error, but does indicate a bug in above code:", e);
            });
          }


          // TODO: should probably update the lastMessageTime of each charactersThatWeAlreadyHave to be the time of their last message, since this could be wrong now 

        } catch(e) {
          console.error(e);
          let yyyymmdd = new Date().toISOString().split("T")[0];
          downloadTextOrBlob(originalDbJsonBlob, `opencharacters-export-${yyyymmdd}.json`);
          await delay(1000);
          alert(`There was an error importing your data. Your data has been downloaded as a backup. Please share this error message on Github:\n\n${e.message}\n\n${e.stack}`);
          return "fail";
        }
        
        await renderCharacterList(); // <-- in case they're currently on the character screen
        await renderThreadList();
        if(singleThreadImportId !== null) {
          await showThread(singleThreadImportId);
        }
        return "finished";
      }

      async function tryImportingExternalCharacterFileFormat(file, options) {
        let text;
        let json;
        try {
          text = await new Blob([file]).text();
          json = JSON.parse(text);
        } catch(e) {}

        if(!json && file.name.endsWith(".json")) return "fail";

        // wasn't a json file - try parsing as webp/png
        if(!json) {
          try {
            let loadingModal = createLoadingModal("Loading parser...");
            let ExifReader = await import('https://cdn.jsdelivr.net/npm/exifreader@4.12.0/+esm');
            loadingModal.delete();

            let tags = await ExifReader.load(file);
            if(tags.chara) {
              json = JSON5.parse(atob(tags.chara.value));
            } else if(tags.UserComment) {
              json = JSON5.parse(tags.UserComment.value[0]);
            }
            // the image file itself is the avatar image, so:
            if(!json.avatar || json.avatar === "none") {
              // convert `file` to a data URL:
              let reader = new FileReader();
              let dataUrl = await new Promise((resolve, reject) => {
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
              });
              json.avatar = dataUrl;
            }
          } catch(e) {
            return "fail";
          }
        }

        if(!json) return "fail";

        if(options.keepExistingData === "no") {
          if(!confirm("You're importing an external character format, but you've requested that all existing data be deleted. This is not currently supported when importing external formats. Existing data will NOT be deleted.")) {
            return "finished";
          }
        }

        let character = {avatar:{}};

        // tavern/pyg/text-gen:
        if(json.name || json.char_name) {
          let name = json.name ?? json.char_name;
          let personality = json.personality ?? json.char_persona ?? null;
          let description = json.description ?? null;
          let firstAIMessage = json.char_greeting ?? json.first_mes ?? null;
          let exampleDialogue = json.example_dialogue ?? json.mes_example ?? ""
          let scenario = json.scenario ?? json.world_scenario ?? "";
          let avatarUrl = json.avatar === undefined || json.avatar === "none" || json.avatar === "" ? "" : json.avatar;
        

          let exampleDialogueChunks = [];
          if(exampleDialogue) {
            if(exampleDialogue.includes("<START>")) {
              exampleDialogueChunks = exampleDialogue.split("<START>").map(c => c.trim()).filter(c => c);
            } else {
              exampleDialogueChunks = [exampleDialogue];
            }
          }

          let roleInstructionChunks = [];
          if(description) roleInstructionChunks.push(`# Description of {{char}}:\n${description}`);
          if(personality) roleInstructionChunks.push(`# {{char}}'s Personality:\n${personality}`);

          character.name = name;
          character.avatar.url = avatarUrl;
          character.roleInstruction = roleInstructionChunks.join("\n\n");
          character.initialMessages = [];
          if(exampleDialogueChunks.length > 0) character.initialMessages.push({author:"system", content:`### Example Dialogue:\n${exampleDialogueChunks.map(c => `---start example---\n${c}\n---end example---`).join("\n\n")}`, hiddenFrom:["user"]});
          if(scenario) character.initialMessages.push({author:"system", content:"Scenario: "+scenario});
          if(firstAIMessage) character.initialMessages.push({author:"ai", content:firstAIMessage});
        } else if(json.character?.name) {
          character.name = json.character.name;
          let roleInstructionChunks = [];
          if(json.character.title) roleInstructionChunks.push(`# Title:\n${json.character.title}`);
          if(json.character.description) roleInstructionChunks.push(`# Description of ${character.name}:\n${json.character.description}`);
          if(json.character.definition) roleInstructionChunks.push(`# Character Definition:\n${json.character.definition}`);
          character.roleInstruction = roleInstructionChunks.join("\n\n");
          character.initialMessages = [{author:"ai", content:json.character.greeting}];
          character.avatar.url = "https://characterai.io/i/400/static/avatars/"+json.character.avatar_file_name;
        } else {
          return "fail";
        }

        let result = await characterDetailsPrompt(character);
        if(result) {
          const character = await addCharacter(result);
          await createNewThreadWithCharacterId(character.id);
        }
        
        return "finished";
      }

      async function tryImportingTavernAIThreadFile(file, options) {
        let text = await new Blob([file]).text();
        // parse text as jsonl format (lines are json objects):
        let jsonl = text.trim().split("\n").map(line => JSON.parse(line));
        // check if it's jsonl format:
        if(!jsonl.every(obj => typeof obj === "object" && obj !== null)) {
          return "fail";
        }
        // check if it's TavernAI thread format (first line is header/meta):
        let seemsValid = jsonl[0].user_name!==undefined && jsonl[0].character_name!==undefined && jsonl[0].create_date!==undefined && jsonl.slice(1).every(m => m.name!==undefined && m.is_user!==undefined && m.mes!==undefined && m.send_date!==undefined);
        if(!seemsValid) {
          return "fail";
        }

        if(options.keepExistingData === "no") {
          if(!confirm("You're importing a TavernAI thread, but you've requested that all existing data be deleted. This is not supported when importing TavernAI threads. Existing data will NOT be deleted.")) {
            return "finished";
          }
        }

        // if so, ask user which character it corresponds to, and then add it as a thread
        const characters = await db.characters.orderBy("lastMessageTime").reverse().toArray();
        let tavernOptions = await prompt2({
          characterId: {label: "You're importing a TavernAI thread. Choose the character for this thread. If you haven't created/imported it yet, you should click cancel and do that first.", type: "select", options:characters.map(c => ({content:`${c.name} #${c.id}`, value:c.id}))},
        }, {submitButtonText:"submit"});
        if(!tavernOptions) {
          return "finished";
        }
        tavernOptions.characterId = parseInt(tavernOptions.characterId);
        let character = await db.characters.get(tavernOptions.characterId);
        let thread = await addThread({name:defaultThreadName, characterId:character.id});
        for(let m of jsonl.slice(1)) {
          let characterId;
          if(m.is_user) characterId = -1;
          else characterId = character.id;
          let data = {threadId:thread.id, message:m.mes, characterId, creationTime:m.send_date};
          let messageObj = createMessageObj(data);
          await addMessageToDb(messageObj)
        }
        await renderThreadList();
        await showThread(thread.id);
        return "finished";
      }

      // parse url hash as json
      let ignoreHashChange = false;
      async function checkForHashCommand() {
        const urlHash = window.location.hash.slice(1);
        const urlHashJson = urlHash ? JSON.parse(decodeURIComponent(urlHash)) : {};
        if(urlHashJson.addCharacter) {
          $.newThreadButton.click();
          let character = urlHashJson.addCharacter;
          
          // UPGRADES (should be the same as the dexie db.upgrade code):
          upgradeCharacterFromOldVersion(character);

          let uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
          if(character.uuid && !uuidRegex.test(character.uuid)) {
            alert("The character you're trying to load has an invalid UUID. It will be imported without a UUID. Please see correct UUID format here:\n\nhttps://en.wikipedia.org/wiki/Universally_unique_identifier");
            delete character.uuid;
          }

          let editingExistingCharacter = false;
          if(character.uuid && await db.characters.get({uuid:character.uuid})) {
            editingExistingCharacter = true;
          }

          let submitButtonText = "add character";
          if(editingExistingCharacter) {
            submitButtonText = "save edits";
          }

          delete character.folderPath;

          let result = await characterDetailsPrompt(character, {editingExistingCharacter, submitButtonText});
          if(result) {
            if(editingExistingCharacter) {
              await db.characters.where({uuid:character.uuid}).modify(result);
              const editedCharacter = await db.characters.get({uuid:character.uuid});
              await createNewThreadWithCharacterId(editedCharacter.id);
            } else {
              const newCharacter = await addCharacter(result);
              await createNewThreadWithCharacterId(newCharacter.id);
            }
          }
          ignoreHashChange = true;
          window.location.hash = "";
          ignoreHashChange = false;
          return "addCharacter";
        } else {
          return null;
        }
      }
      window.addEventListener('hashchange', (event) => {
        if(!ignoreHashChange) {
          checkForHashCommand();
        }
      }, {passive: false});

      await renderThreadList();

      let customPostPageLoadMainThreadCode = (await db.misc.get("customPostPageLoadMainThreadCode"))?.value || "";
      if(customPostPageLoadMainThreadCode.trim()) {
        eval(customPostPageLoadMainThreadCode);
      }

      if(await checkForHashCommand() === null) {
        // if there are no threads, show the character selection screen
        if(!$("#chatThreads .thread")) {
          $.newThreadButton.click();
        } else {
          // otherwise click the most recently-interacted-with thread
          let allThreads = await db.threads.orderBy("lastViewTime").reverse().toArray();
          let thread = allThreads[0];
          if($.chatThreads.dataset.currentFolderPath !== thread.folderPath) {
            $.chatThreads.dataset.currentFolderPath = thread.folderPath;
            await renderThreadList();
          }
          let el = $.chatThreads.querySelector(`.thread[data-thread-id="${thread.id}"]`);
          if(!el) el = $.chatThreads.querySelector(`.thread`); // in case the 'last viewed' thread is in a different folder to the 'last messaged' thread (renderThreadList shows last messaged thread)
          el.click();
        }
      }

      try {
        await navigator.storage.persist().then(async (persistent) => {
          if(persistent) {
            console.log("Storage will not be cleared except by explicit user action.");
          } else {
            console.warn("Storage may be cleared by the browser under storage pressure.");
            let url = window.location.href;
            if (url.startsWith("http:")) {
              alert("It appears that you are hosting OpenCharacters locally, and that you are doing it via HTTP rather than HTTPS. Please be aware that this will not allow OpenCharacters to store data in a way that is 100% permanent. Your browser may clear your OpenCharacters data if your hard drive is nearly full. Please export your characters and threads frequently, and if at all possible, please switch to using HTTPS for local hosting.");
            } else {
              // Can't just use e.g. message count because they could have just imported a bunch of messages.
              let datesApplicationWasUsedInThisBrowser = (await db.misc.get("datesApplicationWasUsedInThisBrowser"))?.value ?? [];
              if(datesApplicationWasUsedInThisBrowser.length > 10) {
                alert("Your browser is not allowing OpenCharacters to store data in a way that is 100% permanent. Your browser may clear your OpenCharacters data if your hard drive is nearly full. The browser will eventually grant permission once it recognises that you are a regular user of this site (i.e. once you demonstrate that you trust this site), but until then, please be sure to backup/export your data often. If you're a regular user of OpenCharacters and you're still seeing this message after a week or so of use, please submit a bug report on our Discord server."); 
              }
            }
          }
        });
      } catch(e) {
        console.error(e);
      }

      try {
        let dateWarningLastGiven = (await db.misc.get("dateWarningLastGiven"))?.value;
        let currentDate = new Date();
        let giveWarning = (dateWarningLastGiven === undefined);
        if (!giveWarning) {
          let daysSinceWarning = (currentDate - dateWarningLastGiven) / (1000 * 3600 * 24);
          if (daysSinceWarning > 15) {
            giveWarning = true;
          }
        }
        if (giveWarning) {
          alert("Periodic warning: This page is experimental and has no warrantees, express or implied. Pricing information displayed is approximate. Please remember to regularly export your stories to avoid accidental loss.");
          await db.misc.put({key:"dateWarningLastGiven", value:currentDate});
        }
      } catch(e) {
        console.error(e);
      }
      console.log("Finished initialization.");

   
    </script>

    <script>
      try {
        let isSafari = navigator.vendor && navigator.vendor.indexOf('Apple') > -1 && navigator.userAgent && navigator.userAgent.indexOf('CriOS') == -1 && navigator.userAgent.indexOf('FxiOS') == -1;
        let isTouchScreen = window.matchMedia("(pointer: coarse)").matches;
        if(isSafari && window.innerWidth < 800 && isTouchScreen) {
          let viewportMetaEl = document.querySelector("[name=viewport]");
          if(!viewportMetaEl.getAttribute("content").includes("maximum-scale")) {
            viewportMetaEl.setAttribute("content", viewportMetaEl.getAttribute("content") + ", maximum-scale=1");
          }
          console.log("Safari iOS detected. Added maximum-scale attribute to prevent zooming:", viewportMetaEl.getAttribute("content"));
        }
      } catch(e) {
        console.error(e);
      }
    </script>

  </body>
</html>
